{
  "language": "Solidity",
  "sources": {
    "src/SectorRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/TimelockController.sol)\n\npragma solidity 0.8.16;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract SectorRegistry is Ownable {\n\tevent AddVault(address vault, string vaultType);\n\n\tconstructor() Ownable() {}\n\n\tfunction addVault(address vault, string memory vaultType) public onlyOwner {\n\t\temit AddVault(vault, vaultType);\n\t}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/vaults/scy/SCYBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ISuperComposableYield } from \"../../interfaces/scy/ISuperComposableYield.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20MetadataUpgradeable as IERC20Metadata } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport { Accounting } from \"../../common/Accounting.sol\";\nimport { ERC20Permit, EIP712 } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\nimport \"hardhat/console.sol\";\n\nabstract contract SCYBase is\n\tISuperComposableYield,\n\tReentrancyGuard,\n\tAccounting,\n\tERC20,\n\tERC20Permit\n{\n\tusing SafeERC20 for IERC20;\n\n\taddress internal constant NATIVE = address(0);\n\tuint256 internal constant ONE = 1e18;\n\tuint256 public constant MIN_LIQUIDITY = 1e3;\n\t// override if false\n\tbool public sendERC20ToStrategy = true;\n\n\t// solhint-disable no-empty-blocks\n\treceive() external payable {}\n\n\tconstructor(string memory _name, string memory _symbol)\n\t\tERC20(_name, _symbol)\n\t\tERC20Permit(_name)\n\t{}\n\n\t/*///////////////////////////////////////////////////////////////\n                    DEPOSIT/REDEEM USING BASE TOKENS\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @dev See {ISuperComposableYield-deposit}\n\t */\n\tfunction deposit(\n\t\taddress receiver,\n\t\taddress tokenIn,\n\t\tuint256 amountTokenToPull,\n\t\tuint256 minSharesOut\n\t) external payable nonReentrant returns (uint256 amountSharesOut) {\n\t\trequire(isValidBaseToken(tokenIn), \"SCY: Invalid tokenIn\");\n\n\t\tif (tokenIn == NATIVE && amountTokenToPull != 0) revert CantPullEth();\n\t\telse if (amountTokenToPull != 0) _transferIn(tokenIn, msg.sender, amountTokenToPull);\n\n\t\t// this depends on strategy\n\t\t// this supports depositing directly into strategy to save gas\n\t\tuint256 amountIn = _getFloatingAmount(tokenIn);\n\t\tif (amountIn == 0) revert ZeroAmount();\n\n\t\tamountSharesOut = _deposit(receiver, tokenIn, amountIn);\n\t\tif (amountSharesOut < minSharesOut) revert InsufficientOut(amountSharesOut, minSharesOut);\n\n\t\t// lock minimum liquidity if totalSupply is 0\n\t\tif (totalSupply() == 0) {\n\t\t\tif (MIN_LIQUIDITY > amountSharesOut) revert MinLiquidity();\n\t\t\tamountSharesOut -= MIN_LIQUIDITY;\n\t\t\t_mint(address(1), MIN_LIQUIDITY);\n\t\t}\n\n\t\t_mint(receiver, amountSharesOut);\n\t\temit Deposit(msg.sender, receiver, tokenIn, amountIn, amountSharesOut);\n\t}\n\n\t/**\n\t * @dev See {ISuperComposableYield-redeem}\n\t */\n\tfunction redeem(\n\t\taddress receiver,\n\t\tuint256 amountSharesToRedeem,\n\t\taddress tokenOut,\n\t\tuint256 minTokenOut\n\t) external nonReentrant returns (uint256 amountTokenOut) {\n\t\trequire(isValidBaseToken(tokenOut), \"SCY: invalid tokenOut\");\n\n\t\t// NOTE this is different from reference implementation in that\n\t\t// we don't support sending shares to contracts\n\n\t\t// this is to handle a case where the strategy sends funds directly to user\n\t\tuint256 amountToTransfer;\n\t\t(amountTokenOut, amountToTransfer) = _redeem(receiver, tokenOut, amountSharesToRedeem);\n\t\trequire(amountTokenOut >= minTokenOut, \"insufficient out\");\n\n\t\t_burn(msg.sender, amountSharesToRedeem);\n\t\tif (amountToTransfer > 0) _transferOut(tokenOut, receiver, amountToTransfer);\n\n\t\temit Redeem(msg.sender, receiver, tokenOut, amountSharesToRedeem, amountTokenOut);\n\t}\n\n\t/**\n\t * @notice mint shares based on the deposited base tokens\n\t * @param tokenIn base token address used to mint shares\n\t * @param amountDeposited amount of base tokens deposited\n\t * @return amountSharesOut amount of shares minted\n\t */\n\tfunction _deposit(\n\t\taddress receiver,\n\t\taddress tokenIn,\n\t\tuint256 amountDeposited\n\t) internal virtual returns (uint256 amountSharesOut);\n\n\t/**\n\t * @notice redeems base tokens based on amount of shares to be burned\n\t * @param tokenOut address of the base token to be redeemed\n\t * @param amountSharesToRedeem amount of shares to be burned\n\t * @return amountTokenOut amount of base tokens redeemed\n\t */\n\tfunction _redeem(\n\t\taddress receiver,\n\t\taddress tokenOut,\n\t\tuint256 amountSharesToRedeem\n\t) internal virtual returns (uint256 amountTokenOut, uint256 tokensToTransfer);\n\n\t/*///////////////////////////////////////////////////////////////\n                               EXCHANGE-RATE\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @dev See {ISuperComposableYield-exchangeRateCurrent}\n\t */\n\tfunction exchangeRateCurrent() external virtual override returns (uint256 res);\n\n\t/**\n\t * @dev See {ISuperComposableYield-exchangeRateStored}\n\t */\n\tfunction exchangeRateStored() external view virtual override returns (uint256 res);\n\n\t// VIRTUALS\n\n\tfunction _getFloatingAmount(address token) internal view virtual returns (uint256);\n\n\t/**\n\t * @notice See {ISuperComposableYield-getBaseTokens}\n\t */\n\tfunction getBaseTokens() external view virtual override returns (address[] memory res);\n\n\t/**\n\t * @dev See {ISuperComposableYield-isValidBaseToken}\n\t */\n\tfunction isValidBaseToken(address token) public view virtual override returns (bool);\n\n\tfunction _transferIn(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual;\n\n\tfunction _transferOut(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual;\n\n\tfunction _selfBalance(address token) internal view virtual returns (uint256);\n\n\tfunction _depositNative() internal virtual;\n\n\t// OVERRIDES\n\tfunction totalSupply() public view override(Accounting, ERC20) returns (uint256) {\n\t\treturn ERC20.totalSupply();\n\t}\n\n\terror CantPullEth();\n\terror MinLiquidity();\n\terror ZeroAmount();\n\terror InsufficientOut(uint256 amountOut, uint256 minOut);\n}\n"
    },
    "src/interfaces/scy/ISuperComposableYield.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.8.16;\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISuperComposableYield {\n\t/// @dev Emitted whenever the exchangeRate is updated\n\tevent ExchangeRateUpdated(uint256 oldExchangeRate, uint256 newExchangeRate);\n\n\t/// @dev Emitted when any base tokens is deposited to mint shares\n\tevent Deposit(\n\t\taddress indexed caller,\n\t\taddress indexed receiver,\n\t\taddress indexed tokenIn,\n\t\tuint256 amountDeposited,\n\t\tuint256 amountScyOut\n\t);\n\n\t/// @dev Emitted when any shares are redeemed for base tokens\n\tevent Redeem(\n\t\taddress indexed caller,\n\t\taddress indexed receiver,\n\t\taddress indexed tokenOut,\n\t\tuint256 amountScyToRedeem,\n\t\tuint256 amountTokenOut\n\t);\n\n\t/// @dev check assetInfo for more information\n\tenum AssetType {\n\t\tTOKEN,\n\t\tLIQUIDITY\n\t}\n\n\t/**\n\t * @notice mints an amount of shares by depositing a base token.\n\t * @param receiver shares recipient address\n\t * @param tokenIn address of the base tokens to mint shares\n\t * @param amountTokenToPull amount of base tokens to be transferred from (`msg.sender`)\n\t * @param minSharesOut reverts if amount of shares minted is lower than this\n\t * @return amountSharesOut amount of shares minted\n\t * @dev\n\t *\n\t * This contract receives base tokens using these two (possibly both) methods:\n\t * - The tokens have been transferred directly to this contract prior to calling deposit().\n\t * - Exactly `amountTokenToPull` are transferred to this contract using `transferFrom()` upon calling deposit().\n\t *\n\t * The amount of shares minted will be based on the combined amount of base tokens deposited\n\t * using the given two methods.\n\t *\n\t * Emits a {Deposit} event\n\t *\n\t * Requirements:\n\t * - (`baseTokenIn`) must be a valid base token.\n\t * - There must be an ongoing approval from (`msg.sender`) for this contract with\n\t * at least `amountTokenToPull` base tokens.\n\t */\n\tfunction deposit(\n\t\taddress receiver,\n\t\taddress tokenIn,\n\t\tuint256 amountTokenToPull,\n\t\tuint256 minSharesOut\n\t) external payable returns (uint256 amountSharesOut);\n\n\t/**\n\t * @notice redeems an amount of base tokens by burning some shares\n\t * @param receiver recipient address\n\t * @param amountSharesToPull amount of shares to be transferred from (`msg.sender`)\n\t * @param tokenOut address of the base token to be redeemed\n\t * @param minTokenOut reverts if amount of base token redeemed is lower than this\n\t * @return amountTokenOut amount of base tokens redeemed\n\t * @dev\n\t *\n\t * This contract receives shares using these two (possibly both) methods:\n\t * - The shares have been transferred directly to this contract prior to calling redeem().\n\t * - Exactly `amountSharesToPull` are transferred to this contract using `transferFrom()` upon calling redeem().\n\t *\n\t * The amount of base tokens redeemed based on the combined amount of shares deposited\n\t * using the given two methods\n\t *\n\t * Emits a {Redeem} event\n\t *\n\t * Requirements:\n\t * - (`tokenOut`) must be a valid base token.\n\t * - There must be an ongoing approval from (`msg.sender`) for this contract with\n\t * at least `amountSharesToPull` shares.\n\t */\n\tfunction redeem(\n\t\taddress receiver,\n\t\tuint256 amountSharesToPull,\n\t\taddress tokenOut,\n\t\tuint256 minTokenOut\n\t) external returns (uint256 amountTokenOut);\n\n\t/**\n     * @notice exchangeRateCurrent * scyBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of scy\n     he can mint must be X * exchangeRateCurrent / 1e18\n     * @dev SCYUtils's assetToScy & scyToAsset should be used instead of raw multiplication\n     & division\n     *\n     * May emit a {NewExchangeRate} event\n     */\n\tfunction exchangeRateCurrent() external returns (uint256 res);\n\n\t/**\n\t * @notice returns the previously updated and stored shares exchange rate\n\t * @dev the returned value may be outdated if exchangeRateCurrent() was not called for a\n\t * extended period of time\n\t */\n\tfunction exchangeRateStored() external view returns (uint256 res);\n\n\t/**\n\t * @notice returns the address of the underlying yield token\n\t */\n\tfunction yieldToken() external view returns (address);\n\n\t/**\n\t * @notice returns a list of all the base tokens that can be deposited to mint shares\n\t */\n\tfunction getBaseTokens() external view returns (address[] memory res);\n\n\t/**\n\t * @notice checks whether a token is a valid base token\n\t * @notice returns a boolean indicating whether this is a valid token\n\t */\n\tfunction isValidBaseToken(address token) external view returns (bool);\n\n\t/**\n    * @notice This function contains information to interpret what the asset is\n    * @notice decimals is the decimals to format asset balances\n    * @notice if asset is an ERC20 token, assetType = 0, assetAddress is the address of the token\n    * @notice if asset is liquidity of an AMM (like sqrt(k) in UniswapV2 forks), assetType = 1,\n    assetAddress is the address of the LP token\n    * @notice assetDecimals is the decimals of the asset\n    */\n\tfunction assetInfo()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tAssetType assetType,\n\t\t\taddress assetAddress,\n\t\t\tuint8 assetDecimals\n\t\t);\n\n\tfunction MIN_LIQUIDITY() external view returns (uint256);\n\n\tfunction underlying() external view returns (IERC20);\n\n\tfunction sendERC20ToStrategy() external view returns (bool);\n\n\tfunction strategy() external view returns (address);\n\n\tfunction underlyingToShares(uint256 amnt) external view returns (uint256);\n\n\tfunction sharesToUnderlying(uint256 shares) external view returns (uint256);\n}\n"
    },
    "src/common/Accounting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { FixedPointMathLib } from \"../libraries/FixedPointMathLib.sol\";\nimport { IERC4626Accounting } from \"../interfaces/ERC4626/IERC4626Accounting.sol\";\nimport \"hardhat/console.sol\";\n\nabstract contract Accounting is IERC4626Accounting {\n\tusing FixedPointMathLib for uint256;\n\n\tfunction totalAssets() public view virtual returns (uint256);\n\n\tfunction totalSupply() public view virtual returns (uint256);\n\n\tfunction toSharesAfterDeposit(uint256 assets) public view virtual returns (uint256) {\n\t\tuint256 supply = totalAssets() - assets;\n\t\treturn supply == 0 ? assets : assets.mulDivDown(supply, supply);\n\t}\n\n\tfunction convertToShares(uint256 assets) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n\t}\n\n\tfunction convertToAssets(uint256 shares) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n\t}\n\n\tfunction previewDeposit(uint256 assets) public view virtual returns (uint256) {\n\t\treturn convertToShares(assets);\n\t}\n\n\tfunction previewMint(uint256 shares) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n\t}\n\n\tfunction previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n\t}\n\n\tfunction previewRedeem(uint256 shares) public view virtual returns (uint256) {\n\t\treturn convertToAssets(shares);\n\t}\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/libraries/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n\t/*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n\tuint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n\tfunction mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n\t\treturn mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n\t}\n\n\tfunction mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n\t\treturn mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n\t}\n\n\tfunction divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n\t\treturn mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n\t}\n\n\tfunction divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n\t\treturn mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction mulDivDown(\n\t\tuint256 x,\n\t\tuint256 y,\n\t\tuint256 denominator\n\t) internal pure returns (uint256 z) {\n\t\tassembly {\n\t\t\t// Store x * y in z for now.\n\t\t\tz := mul(x, y)\n\n\t\t\t// Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n\t\t\tif iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n\t\t\t\trevert(0, 0)\n\t\t\t}\n\n\t\t\t// Divide z by the denominator.\n\t\t\tz := div(z, denominator)\n\t\t}\n\t}\n\n\tfunction mulDivUp(\n\t\tuint256 x,\n\t\tuint256 y,\n\t\tuint256 denominator\n\t) internal pure returns (uint256 z) {\n\t\tassembly {\n\t\t\t// Store x * y in z for now.\n\t\t\tz := mul(x, y)\n\n\t\t\t// Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n\t\t\tif iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n\t\t\t\trevert(0, 0)\n\t\t\t}\n\n\t\t\t// First, divide z - 1 by the denominator and add 1.\n\t\t\t// We allow z - 1 to underflow if z is 0, because we multiply the\n\t\t\t// end result by 0 if z is zero, ensuring we return 0 if z is zero.\n\t\t\tz := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n\t\t}\n\t}\n\n\tfunction rpow(\n\t\tuint256 x,\n\t\tuint256 n,\n\t\tuint256 scalar\n\t) internal pure returns (uint256 z) {\n\t\tassembly {\n\t\t\tswitch x\n\t\t\tcase 0 {\n\t\t\t\tswitch n\n\t\t\t\tcase 0 {\n\t\t\t\t\t// 0 ** 0 = 1\n\t\t\t\t\tz := scalar\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\t// 0 ** n = 0\n\t\t\t\t\tz := 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\tswitch mod(n, 2)\n\t\t\t\tcase 0 {\n\t\t\t\t\t// If n is even, store scalar in z for now.\n\t\t\t\t\tz := scalar\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\t// If n is odd, store x in z for now.\n\t\t\t\t\tz := x\n\t\t\t\t}\n\n\t\t\t\t// Shifting right by 1 is like dividing by 2.\n\t\t\t\tlet half := shr(1, scalar)\n\n\t\t\t\tfor {\n\t\t\t\t\t// Shift n right by 1 before looping to halve it.\n\t\t\t\t\tn := shr(1, n)\n\t\t\t\t} n {\n\t\t\t\t\t// Shift n right by 1 each iteration to halve it.\n\t\t\t\t\tn := shr(1, n)\n\t\t\t\t} {\n\t\t\t\t\t// Revert immediately if x ** 2 would overflow.\n\t\t\t\t\t// Equivalent to iszero(eq(div(xx, x), x)) here.\n\t\t\t\t\tif shr(128, x) {\n\t\t\t\t\t\trevert(0, 0)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store x squared.\n\t\t\t\t\tlet xx := mul(x, x)\n\n\t\t\t\t\t// Round to the nearest number.\n\t\t\t\t\tlet xxRound := add(xx, half)\n\n\t\t\t\t\t// Revert if xx + half overflowed.\n\t\t\t\t\tif lt(xxRound, xx) {\n\t\t\t\t\t\trevert(0, 0)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set x to scaled xxRound.\n\t\t\t\t\tx := div(xxRound, scalar)\n\n\t\t\t\t\t// If n is even:\n\t\t\t\t\tif mod(n, 2) {\n\t\t\t\t\t\t// Compute z * x.\n\t\t\t\t\t\tlet zx := mul(z, x)\n\n\t\t\t\t\t\t// If z * x overflowed:\n\t\t\t\t\t\tif iszero(eq(div(zx, x), z)) {\n\t\t\t\t\t\t\t// Revert if x is non-zero.\n\t\t\t\t\t\t\tif iszero(iszero(x)) {\n\t\t\t\t\t\t\t\trevert(0, 0)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Round to the nearest number.\n\t\t\t\t\t\tlet zxRound := add(zx, half)\n\n\t\t\t\t\t\t// Revert if zx + half overflowed.\n\t\t\t\t\t\tif lt(zxRound, zx) {\n\t\t\t\t\t\t\trevert(0, 0)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Return properly scaled zxRound.\n\t\t\t\t\t\tz := div(zxRound, scalar)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction sqrt(uint256 x) internal pure returns (uint256 z) {\n\t\tassembly {\n\t\t\t// Start off with z at 1.\n\t\t\tz := 1\n\n\t\t\t// Used below to help find a nearby power of 2.\n\t\t\tlet y := x\n\n\t\t\t// Find the lowest power of 2 that is at least sqrt(x).\n\t\t\tif iszero(lt(y, 0x100000000000000000000000000000000)) {\n\t\t\t\ty := shr(128, y) // Like dividing by 2 ** 128.\n\t\t\t\tz := shl(64, z) // Like multiplying by 2 ** 64.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x10000000000000000)) {\n\t\t\t\ty := shr(64, y) // Like dividing by 2 ** 64.\n\t\t\t\tz := shl(32, z) // Like multiplying by 2 ** 32.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x100000000)) {\n\t\t\t\ty := shr(32, y) // Like dividing by 2 ** 32.\n\t\t\t\tz := shl(16, z) // Like multiplying by 2 ** 16.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x10000)) {\n\t\t\t\ty := shr(16, y) // Like dividing by 2 ** 16.\n\t\t\t\tz := shl(8, z) // Like multiplying by 2 ** 8.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x100)) {\n\t\t\t\ty := shr(8, y) // Like dividing by 2 ** 8.\n\t\t\t\tz := shl(4, z) // Like multiplying by 2 ** 4.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x10)) {\n\t\t\t\ty := shr(4, y) // Like dividing by 2 ** 4.\n\t\t\t\tz := shl(2, z) // Like multiplying by 2 ** 2.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x8)) {\n\t\t\t\t// Equivalent to 2 ** z.\n\t\t\t\tz := shl(1, z)\n\t\t\t}\n\n\t\t\t// Shifting right by 1 is like dividing by 2.\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\n\t\t\t// Compute a rounded down version of z.\n\t\t\tlet zRoundDown := div(x, z)\n\n\t\t\t// If zRoundDown is smaller, use it.\n\t\t\tif lt(zRoundDown, z) {\n\t\t\t\tz := zRoundDown\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "src/interfaces/ERC4626/IERC4626Accounting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\ninterface IERC4626Accounting {\n\tfunction totalAssets() external view returns (uint256);\n\n\tfunction convertToShares(uint256 assets) external view returns (uint256);\n\n\tfunction convertToAssets(uint256 shares) external view returns (uint256);\n\n\tfunction previewDeposit(uint256 assets) external view returns (uint256);\n\n\tfunction previewMint(uint256 shares) external view returns (uint256);\n\n\tfunction previewWithdraw(uint256 assets) external view returns (uint256);\n\n\tfunction previewRedeem(uint256 shares) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "src/vaults/scy/SCYVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { SCYBase, IERC20, IERC20Metadata, SafeERC20 } from \"./SCYBase.sol\";\nimport { IMX } from \"../../strategies/imx/IMX.sol\";\nimport { Auth } from \"../../common/Auth.sol\";\nimport { Fees } from \"../../common/Fees.sol\";\nimport { SafeETH } from \"../../libraries/SafeETH.sol\";\nimport { SCYStrategy, Strategy } from \"./SCYStrategy.sol\";\nimport { FixedPointMathLib } from \"../../libraries/FixedPointMathLib.sol\";\nimport { IWETH } from \"../../interfaces/uniswap/IWETH.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract SCYVault is SCYStrategy, SCYBase, Fees {\n\tusing SafeERC20 for IERC20;\n\tusing FixedPointMathLib for uint256;\n\n\tevent Harvest(\n\t\taddress indexed treasury,\n\t\tuint256 underlyingProfit,\n\t\tuint256 underlyingFees,\n\t\tuint256 sharesFees,\n\t\tuint256 tvl\n\t);\n\n\taddress public strategy;\n\n\t// immutables\n\taddress public immutable yieldToken;\n\tuint256 public immutable strategyId; // strategy-specific id ex: for MasterChef or 1155\n\tIERC20 public immutable underlying;\n\n\tuint256 public maxTvl; // pack all params and balances\n\tuint256 public vaultTvl; // strategy balance in underlying\n\tuint256 public uBalance; // underlying balance held by vault\n\n\tevent MaxTvlUpdated(uint256 maxTvl);\n\tevent StrategyUpdated(address strategy);\n\n\tmodifier isInitialized() {\n\t\tif (strategy == address(0)) revert NotInitialized();\n\t\t_;\n\t}\n\n\tconstructor(\n\t\taddress _owner,\n\t\taddress _guardian,\n\t\taddress _manager,\n\t\tStrategy memory _strategy\n\t)\n\t\tSCYBase(_strategy.name, _strategy.symbol)\n\t\tAuth(_owner, _guardian, _manager)\n\t\tFees(_strategy.treasury, _strategy.performanceFee)\n\t{\n\t\t// strategy init\n\t\tyieldToken = _strategy.yieldToken;\n\t\tstrategy = _strategy.addr;\n\t\tstrategyId = _strategy.strategyId;\n\t\tunderlying = _strategy.underlying;\n\t\tmaxTvl = _strategy.maxTvl;\n\t}\n\n\t/*///////////////////////////////////////////////////////////////\n                    CONFIG\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction getMaxTvl() public view returns (uint256) {\n\t\treturn min(maxTvl, _stratMaxTvl());\n\t}\n\n\tfunction setMaxTvl(uint256 _maxTvl) public onlyRole(GUARDIAN) {\n\t\tmaxTvl = _maxTvl;\n\t\temit MaxTvlUpdated(min(maxTvl, _stratMaxTvl()));\n\t}\n\n\tfunction initStrategy(address _strategy) public onlyRole(GUARDIAN) {\n\t\tif (strategy != address(0)) revert NoReInit();\n\t\tstrategy = _strategy;\n\t\t_stratValidate();\n\t\temit StrategyUpdated(_strategy);\n\t}\n\n\tfunction updateStrategy(address _strategy) public onlyOwner {\n\t\tuint256 tvl = _stratGetAndUpdateTvl();\n\t\tif (tvl > 0) revert InvalidStrategyUpdate();\n\t\tstrategy = _strategy;\n\t\t_stratValidate();\n\t\temit StrategyUpdated(_strategy);\n\t}\n\n\tfunction _depositNative() internal override {\n\t\tuint256 balance = address(this).balance;\n\t\tIWETH(address(underlying)).deposit{ value: balance }();\n\t\tif (sendERC20ToStrategy) IERC20(underlying).safeTransfer(strategy, balance);\n\t}\n\n\tfunction _deposit(\n\t\taddress,\n\t\taddress token,\n\t\tuint256 amount\n\t) internal override isInitialized returns (uint256 sharesOut) {\n\t\t// if we have any float in the contract we cannot do deposit accounting\n\t\tif (uBalance > 0) revert DepositsPaused();\n\t\tif (token == NATIVE) _depositNative();\n\t\tif (!sendERC20ToStrategy) underlying.safeTransfer(strategy, amount);\n\t\tuint256 yieldTokenAdded = _stratDeposit(amount);\n\t\tsharesOut = toSharesAfterDeposit(yieldTokenAdded);\n\t\tvaultTvl += amount;\n\t}\n\n\tfunction _redeem(\n\t\taddress receiver,\n\t\taddress token,\n\t\tuint256 sharesToRedeem\n\t) internal override returns (uint256 amountTokenOut, uint256 amountToTransfer) {\n\t\tuint256 _totalSupply = totalSupply();\n\n\t\tuint256 yeildTokenRedeem = convertToAssets(sharesToRedeem);\n\n\t\t// vault may hold float of underlying, in this case, add a share of reserves to withdrawal\n\t\t// TODO why not use underlying.balanceOf?\n\t\tuint256 reserves = uBalance;\n\t\tuint256 shareOfReserves = (reserves * sharesToRedeem) / _totalSupply;\n\n\t\t// Update strategy underlying reserves balance\n\t\tif (shareOfReserves > 0) uBalance -= shareOfReserves;\n\n\t\treceiver = token == NATIVE ? address(this) : receiver;\n\n\t\t// if we also need to send the user share of reserves, we allways withdraw to vault first\n\t\t// if we don't we can have strategy withdraw directly to user if possible\n\t\tif (shareOfReserves > 0) {\n\t\t\t(amountTokenOut, amountToTransfer) = _stratRedeem(receiver, yeildTokenRedeem);\n\t\t\tamountTokenOut += shareOfReserves;\n\t\t\tamountToTransfer += shareOfReserves;\n\t\t} else (amountTokenOut, amountToTransfer) = _stratRedeem(receiver, yeildTokenRedeem);\n\t\tvaultTvl -= amountTokenOut;\n\n\t\t// it requested token is native, convert to native\n\t\tif (token == NATIVE) IWETH(address(underlying)).withdraw(amountToTransfer);\n\t}\n\n\t/// @notice harvest strategy\n\tfunction harvest(uint256 expectedTvl, uint256 maxDelta) external onlyRole(MANAGER) {\n\t\tuint256 tvl = _stratGetAndUpdateTvl() + underlying.balanceOf(address(this));\n\t\t_checkSlippage(expectedTvl, tvl, maxDelta);\n\t\tuint256 prevTvl = vaultTvl;\n\t\tif (tvl <= prevTvl) return;\n\n\t\tuint256 underlyingEarned = tvl - prevTvl;\n\t\tuint256 underlyingFees = (underlyingEarned * performanceFee) / 1e18;\n\t\tuint256 feeShares = convertToShares(underlyingFees);\n\n\t\t_mint(treasury, feeShares);\n\t\tvaultTvl = tvl;\n\t\temit Harvest(treasury, underlyingEarned, underlyingFees, feeShares, tvl);\n\t}\n\n\tfunction _checkSlippage(\n\t\tuint256 expectedValue,\n\t\tuint256 actualValue,\n\t\tuint256 maxDelta\n\t) internal pure {\n\t\tuint256 delta = expectedValue > actualValue\n\t\t\t? expectedValue - actualValue\n\t\t\t: actualValue - expectedValue;\n\t\tif (delta > maxDelta) revert SlippageExceeded();\n\t}\n\n\t/// @notice slippage is computed in shares\n\tfunction depositIntoStrategy(uint256 underlyingAmount, uint256 minAmountOut)\n\t\tpublic\n\t\tonlyRole(GUARDIAN)\n\t{\n\t\tif (underlyingAmount > uBalance) revert NotEnoughUnderlying();\n\t\tuBalance -= underlyingAmount;\n\t\tunderlying.safeTransfer(strategy, underlyingAmount);\n\t\tuint256 yAdded = _stratDeposit(underlyingAmount);\n\t\tuint256 virtualSharesOut = toSharesAfterDeposit(yAdded);\n\t\tif (virtualSharesOut < minAmountOut) revert SlippageExceeded();\n\t}\n\n\t/// @notice slippage is computed in underlying\n\tfunction withdrawFromStrategy(uint256 shares, uint256 minAmountOut) public onlyRole(GUARDIAN) {\n\t\tuint256 yieldTokenAmnt = convertToAssets(shares);\n\t\t(uint256 underlyingWithdrawn, ) = _stratRedeem(address(this), yieldTokenAmnt);\n\t\tif (underlyingWithdrawn < minAmountOut) revert SlippageExceeded();\n\t\tuBalance += underlyingWithdrawn;\n\t}\n\n\tfunction closePosition(uint256 minAmountOut) public onlyRole(GUARDIAN) {\n\t\tuint256 underlyingWithdrawn = _stratClosePosition();\n\t\tif (underlyingWithdrawn < minAmountOut) revert SlippageExceeded();\n\t\tuBalance += underlyingWithdrawn;\n\t}\n\n\tfunction getStrategyTvl() public view returns (uint256) {\n\t\treturn _strategyTvl();\n\t}\n\n\t/// no slippage check - slippage can be done on vault level\n\t/// against total expected balance of all strategies\n\tfunction getAndUpdateTvl() public returns (uint256 tvl) {\n\t\tuint256 stratTvl = _stratGetAndUpdateTvl();\n\t\tuint256 balance = underlying.balanceOf(address(this));\n\t\ttvl = balance + stratTvl;\n\t}\n\n\tfunction getTvl() public view returns (uint256 tvl) {\n\t\tuint256 stratTvl = _strategyTvl();\n\t\tuint256 balance = underlying.balanceOf(address(this));\n\t\ttvl = balance + stratTvl;\n\t}\n\n\tfunction totalAssets() public view override returns (uint256) {\n\t\treturn _selfBalance(yieldToken);\n\t}\n\n\tfunction isPaused() public view returns (bool) {\n\t\treturn uBalance > 0;\n\t}\n\n\t// used for estimates only\n\tfunction exchangeRateUnderlying() public view returns (uint256) {\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0) return _stratCollateralToUnderlying();\n\t\tuint256 tvl = underlying.balanceOf(address(this)) + _strategyTvl();\n\t\treturn tvl.mulDivUp(ONE, _totalSupply);\n\t}\n\n\tfunction underlyingBalance(address user) external view returns (uint256) {\n\t\tuint256 userBalance = balanceOf(user);\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0 || userBalance == 0) return 0;\n\t\tuint256 tvl = underlying.balanceOf(address(this)) + _strategyTvl();\n\t\treturn (tvl * userBalance) / _totalSupply;\n\t}\n\n\tfunction underlyingToShares(uint256 uAmnt) public view returns (uint256) {\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0) return uAmnt.mulDivDown(ONE, _stratCollateralToUnderlying());\n\t\treturn uAmnt.mulDivDown(_totalSupply, getTvl());\n\t}\n\n\tfunction sharesToUnderlying(uint256 shares) public view returns (uint256) {\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0) return (shares * _stratCollateralToUnderlying()) / ONE;\n\t\treturn shares.mulDivDown(getTvl(), _totalSupply);\n\t}\n\n\t///\n\t///  Yield Token Overrides\n\t///\n\n\tfunction assetInfo()\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tAssetType assetType,\n\t\t\taddress assetAddress,\n\t\t\tuint8 assetDecimals\n\t\t)\n\t{\n\t\taddress yToken = yieldToken;\n\t\treturn (AssetType.LIQUIDITY, yToken, IERC20Metadata(yToken).decimals());\n\t}\n\n\tfunction underlyingDecimals() public view returns (uint8) {\n\t\treturn IERC20Metadata(address(underlying)).decimals();\n\t}\n\n\t/// make sure to override this - actual logic should use floating strategy balances\n\tfunction _getFloatingAmount(address token)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256 fltAmnt)\n\t{\n\t\tif (token == address(underlying)) return underlying.balanceOf(strategy);\n\t\tif (token == NATIVE) return address(this).balance;\n\t}\n\n\tfunction decimals() public view override returns (uint8) {\n\t\treturn IERC20Metadata(yieldToken).decimals();\n\t}\n\n\t/**\n\t * @dev See {ISuperComposableYield-exchangeRateCurrent}\n\t */\n\tfunction exchangeRateCurrent() public view virtual override returns (uint256) {\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0) return ONE;\n\t\treturn (_selfBalance(yieldToken) * ONE) / _totalSupply;\n\t}\n\n\t/**\n\t * @dev See {ISuperComposableYield-exchangeRateStored}\n\t */\n\n\tfunction exchangeRateStored() external view virtual override returns (uint256) {\n\t\treturn exchangeRateCurrent();\n\t}\n\n\tfunction getBaseTokens() external view virtual override returns (address[] memory res) {\n\t\tres[0] = address(underlying);\n\t}\n\n\tfunction isValidBaseToken(address token) public view virtual override returns (bool) {\n\t\treturn token == address(underlying);\n\t}\n\n\t// send funds to strategy\n\tfunction _transferIn(\n\t\taddress token,\n\t\taddress from,\n\t\tuint256 amount\n\t) internal virtual override {\n\t\taddress to = sendERC20ToStrategy ? strategy : address(this);\n\t\tIERC20(token).safeTransferFrom(from, to, amount);\n\t\t// if (token == NATIVE) {\n\t\t// \t// if strategy logic lives in this contract, don't do anything\n\t\t// \tif (strategy != address(this)) return SafeETH.safeTransferETH(to, amount);\n\t\t// } else IERC20(token).safeTransferFrom(from, to, amount);\n\t}\n\n\t// send funds to user\n\tfunction _transferOut(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual override {\n\t\tif (token == NATIVE) {\n\t\t\tSafeETH.safeTransferETH(to, amount);\n\t\t} else {\n\t\t\tIERC20(token).safeTransfer(to, amount);\n\t\t}\n\t}\n\n\t// todo handle internal float balances\n\tfunction _selfBalance(address token) internal view virtual override returns (uint256) {\n\t\treturn (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n\t}\n\n\t/**\n\t * @dev Returns the smallest of two numbers.\n\t */\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a < b ? a : b;\n\t}\n\n\terror InvalidStrategyUpdate();\n\terror NoReInit();\n\terror InvalidStrategy();\n\terror NotInitialized();\n\terror DepositsPaused();\n\terror StrategyExists();\n\terror StrategyDoesntExist();\n\terror NotEnoughUnderlying();\n\terror SlippageExceeded();\n\terror BadStaticCall();\n}\n"
    },
    "src/strategies/imx/IMX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IMXCore } from \"./IMXCore.sol\";\nimport { IMXFarm } from \"./IMXFarm.sol\";\nimport { IMXConfig } from \"../../interfaces/Structs.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract IMX is IMXCore, IMXFarm {\n\tfunction initialize(IMXConfig memory config) public initializer {\n\t\t__Auth_init_(config.owner, config.guardian, config.manager);\n\n\t\t__IMXFarm_init_(\n\t\t\tconfig.underlying,\n\t\t\tconfig.uniPair,\n\t\t\tconfig.poolToken,\n\t\t\tconfig.farmRouter,\n\t\t\tconfig.farmToken\n\t\t);\n\n\t\t// HedgedLP should allways be intialized last\n\t\t__IMX_init_(config.vault, config.underlying, config.short, config.maxTvl);\n\t}\n\n\tfunction tarotBorrow(\n\t\taddress a,\n\t\taddress b,\n\t\tuint256 c,\n\t\tbytes calldata data\n\t) external {\n\t\timpermaxBorrow(a, b, c, data);\n\t}\n\n\tfunction tarotRedeem(\n\t\taddress a,\n\t\tuint256 redeemAmount,\n\t\tbytes calldata data\n\t) external {\n\t\timpermaxRedeem(a, redeemAmount, data);\n\t}\n}\n"
    },
    "src/common/Auth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract Auth is AccessControl {\n\tevent OwnershipTransferInitiated(address owner, address pendingOwner);\n\tevent OwnershipTransferred(address oldOwner, address newOwner);\n\n\t////////// CONSTANTS //////////\n\n\t/// Update vault params, perform time-sensitive operations, set manager\n\tbytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n\n\t/// Hot-wallet bots that route funds between vaults, rebalance and harvest strategies\n\tbytes32 public constant MANAGER = keccak256(\"MANAGER\");\n\n\t/// Add and remove vaults and strategies and other critical operations behind timelock\n\t/// Default admin role\n\t/// There should only be one owner, so it is not a role\n\taddress public owner;\n\taddress public pendingOwner;\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"ONLY_OWNER\");\n\t\t_;\n\t}\n\n\tconstructor(\n\t\taddress _owner,\n\t\taddress guardian,\n\t\taddress manager\n\t) {\n\t\t/// Set up the roles\n\t\t// owner can manage all roles\n\t\towner = _owner;\n\t\temit OwnershipTransferred(address(0), owner);\n\n\t\t// TODO do we want cascading roles like this?\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, owner);\n\t\t_grantRole(GUARDIAN, owner);\n\t\t_grantRole(GUARDIAN, guardian);\n\t\t_grantRole(MANAGER, owner);\n\t\t_grantRole(MANAGER, guardian);\n\t\t_grantRole(MANAGER, manager);\n\n\t\t/// Allow the guardian role to manage manager\n\t\t_setRoleAdmin(MANAGER, GUARDIAN);\n\t}\n\n\t// ----------- Ownership -----------\n\n\t/// @dev Init transfer of ownership of the contract to a new account (`_pendingOwner`).\n\t/// @param _pendingOwner pending owner of contract\n\t/// Can only be called by the current owner.\n\tfunction transferOwnership(address _pendingOwner) external onlyOwner {\n\t\tpendingOwner = _pendingOwner;\n\t\temit OwnershipTransferInitiated(owner, pendingOwner);\n\t}\n\n\t/// @dev Accept transfer of ownership of the contract.\n\t/// Can only be called by the pendingOwner.\n\tfunction acceptOwnership() external {\n\t\trequire(msg.sender == pendingOwner, \"ONLY_PENDING_OWNER\");\n\t\taddress oldOwner = owner;\n\t\towner = pendingOwner;\n\n\t\t// revoke the DEFAULT ADMIN ROLE from prev owner\n\t\t_revokeRole(DEFAULT_ADMIN_ROLE, oldOwner);\n\t\t_revokeRole(GUARDIAN, oldOwner);\n\t\t_revokeRole(MANAGER, oldOwner);\n\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, owner);\n\t\t_grantRole(GUARDIAN, owner);\n\t\t_grantRole(MANAGER, owner);\n\n\t\temit OwnershipTransferred(oldOwner, owner);\n\t}\n}\n"
    },
    "src/common/Fees.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Auth } from \"./Auth.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract Fees is Auth {\n\tusing SafeERC20 for IERC20;\n\n\tconstructor(address _treasury, uint256 _performanceFee) {\n\t\ttreasury = _treasury;\n\t\tperformanceFee = _performanceFee;\n\t\temit SetTreasury(_treasury);\n\t\temit SetPerformanceFee(_performanceFee);\n\t}\n\n\t/// @notice Emitted when the fee percentage is updated.\n\t/// @param performanceFee The new fee percentage.\n\tevent SetPerformanceFee(uint256 performanceFee);\n\n\tevent SetTreasury(address indexed treasury);\n\n\t/// @notice The percentage of profit recognized each harvest to reserve as fees.\n\t/// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\n\tuint256 public performanceFee;\n\n\taddress public treasury;\n\n\t/// @notice Sets a new performanceFee.\n\t/// @param _performanceFee The new performance fee.\n\tfunction setPerformanceFee(uint256 _performanceFee) public onlyOwner {\n\t\t// A fee percentage over 100% doesn't make sense.\n\t\trequire(_performanceFee <= 1e18, \"FEE_TOO_HIGH\");\n\n\t\t// Update the fee percentage.\n\t\tperformanceFee = _performanceFee;\n\t\temit SetPerformanceFee(performanceFee);\n\t}\n\n\t/// @notice Updates treasury.\n\t/// @param _treasury New treasury address.\n\tfunction setTreasury(address _treasury) public onlyOwner {\n\t\ttreasury = _treasury;\n\t\temit SetTreasury(_treasury);\n\t}\n}\n"
    },
    "src/libraries/SafeETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nlibrary SafeETH {\n\tfunction safeTransferETH(address to, uint256 amount) internal {\n\t\tbool callStatus;\n\n\t\tassembly {\n\t\t\t// Transfer the ETH and store if it succeeded or not.\n\t\t\tcallStatus := call(gas(), to, amount, 0, 0, 0, 0)\n\t\t}\n\n\t\trequire(callStatus, \"ETH_TRANSFER_FAILED\");\n\t}\n}\n"
    },
    "src/vaults/scy/SCYStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { IERC20 } from \"./SCYBase.sol\";\n\nstruct Strategy {\n\tstring symbol;\n\tstring name;\n\taddress addr;\n\tuint256 strategyId; // this is strategy specific token if 1155\n\taddress yieldToken;\n\tIERC20 underlying;\n\tuint256 performanceFee;\n\taddress treasury;\n\tuint128 maxTvl; // pack all params and balances\n\tuint128 balance; // strategy balance in underlying\n\tuint128 uBalance; // underlying balance\n\tuint128 yBalance; // yield token balance\n}\n\nabstract contract SCYStrategy {\n\tfunction _stratDeposit(uint256 amount) internal virtual returns (uint256);\n\n\tfunction _stratRedeem(address to, uint256 amount)\n\t\tinternal\n\t\tvirtual\n\t\treturns (uint256 amntOut, uint256 amntToTransfer);\n\n\tfunction _stratClosePosition() internal virtual returns (uint256);\n\n\tfunction _stratGetAndUpdateTvl() internal virtual returns (uint256);\n\n\tfunction _strategyTvl() internal view virtual returns (uint256);\n\n\tfunction _stratMaxTvl() internal view virtual returns (uint256);\n\n\tfunction _stratCollateralToUnderlying() internal view virtual returns (uint256);\n\n\tfunction _stratValidate() internal virtual;\n}\n"
    },
    "src/interfaces/uniswap/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IWETH {\n\tfunction deposit() external payable;\n\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\tfunction withdraw(uint256) external;\n\n\tfunction balanceOf(address) external returns (uint256);\n}\n"
    },
    "src/strategies/imx/IMXCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20Upgradeable as SafeERC20, IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20MetadataUpgradeable as IERC20Metadata } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { IBaseU, HarvestSwapParms } from \"../mixins/upgradable/IBaseU.sol\";\nimport { IIMXFarmU } from \"../mixins/upgradable/IIMXFarmU.sol\";\nimport { UniUtils, IUniswapV2Pair } from \"../../libraries/UniUtils.sol\";\nimport { FixedPointMathLib } from \"../../libraries/FixedPointMathLib.sol\";\n\nimport { IMXAuthU } from \"./IMXAuthU.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract IMXCore is\n\tInitializable,\n\tReentrancyGuardUpgradeable,\n\tIMXAuthU,\n\tIBaseU,\n\tIIMXFarmU\n{\n\tusing FixedPointMathLib for uint256;\n\tusing UniUtils for IUniswapV2Pair;\n\tusing SafeERC20 for IERC20;\n\n\tevent Deposit(address sender, uint256 amount);\n\tevent Redeem(address sender, uint256 amount);\n\t// event RebalanceLoan(address indexed sender, uint256 startLoanHealth, uint256 updatedLoanHealth);\n\tevent SetRebalanceThreshold(uint256 rebalanceThreshold);\n\tevent SetMaxTvl(uint256 maxTvl);\n\t// this determines our default leverage position\n\tevent SetSafetyMarginSqrt(uint256 safetyMarginSqrt);\n\n\tevent Harvest(uint256 harvested); // this is actual the tvl before harvest\n\tevent Rebalance(uint256 shortPrice, uint256 tvlBeforeRebalance, uint256 positionOffset);\n\tevent SetMaxPriceOffset(uint256 maxPriceOffset);\n\n\tuint256 constant MINIMUM_LIQUIDITY = 1000;\n\tuint256 constant BPS_ADJUST = 10000;\n\tuint256 constant MIN_LOAN_HEALTH = 1.02e18;\n\n\tIERC20 private _underlying;\n\tIERC20 private _short;\n\n\tuint256 private _maxTvl;\n\tuint16 public rebalanceThreshold = 400; // 4% of lp\n\t// price move before liquidation\n\tuint256 private _safetyMarginSqrt = 1.140175425e18; // sqrt of 130%\n\tuint256 public maxPriceOffset = .2e18;\n\n\tmodifier checkPrice(uint256 expectedPrice, uint256 maxDelta) {\n\t\t// parameter validation\n\t\t// to prevent manipulation by manager\n\t\tif (!hasRole(GUARDIAN, msg.sender)) {\n\t\t\tuint256 oraclePrice = _shortToUnderlyingOracle(1e18);\n\t\t\tuint256 oracleDelta = oraclePrice > expectedPrice\n\t\t\t\t? oraclePrice - expectedPrice\n\t\t\t\t: expectedPrice - oraclePrice;\n\t\t\tif ((1e18 * (oracleDelta + maxDelta)) / expectedPrice > maxPriceOffset)\n\t\t\t\trevert OverMaxPriceOffset();\n\t\t}\n\n\t\tuint256 currentPrice = _shortToUnderlying(1e18);\n\t\tuint256 delta = expectedPrice > currentPrice\n\t\t\t? expectedPrice - currentPrice\n\t\t\t: currentPrice - expectedPrice;\n\t\tif (delta > maxDelta) revert SlippageExceeded();\n\t\t_;\n\t}\n\n\tfunction __IMX_init_(\n\t\taddress vault_,\n\t\taddress underlying_,\n\t\taddress short_,\n\t\tuint256 maxTvl_\n\t) internal onlyInitializing {\n\t\tvault = vault_;\n\t\t_underlying = IERC20(underlying_);\n\t\t_short = IERC20(short_);\n\n\t\t// _underlying.safeApprove(vault, type(uint256).max);\n\n\t\t// init default params\n\t\t// deployer is not owner so we set these manually\n\t\t_maxTvl = maxTvl_;\n\t\temit SetMaxTvl(maxTvl_);\n\n\t\t// TODO param?\n\t\trebalanceThreshold = 400;\n\t\temit SetRebalanceThreshold(400);\n\n\t\tmaxPriceOffset = .2e18;\n\t\temit SetMaxPriceOffset(maxPriceOffset);\n\n\t\t_safetyMarginSqrt = 1.140175425e18;\n\t\temit SetSafetyMarginSqrt(_safetyMarginSqrt);\n\t}\n\n\t// guardian can adjust max price offset if needed\n\tfunction setMaxPriceOffset(uint256 _maxPriceOffset) public onlyRole(GUARDIAN) {\n\t\tmaxPriceOffset = _maxPriceOffset;\n\t\temit SetMaxPriceOffset(_maxPriceOffset);\n\t}\n\n\tfunction safetyMarginSqrt() public view override returns (uint256) {\n\t\treturn _safetyMarginSqrt;\n\t}\n\n\tfunction decimals() public view returns (uint8) {\n\t\treturn IERC20Metadata(address(_underlying)).decimals();\n\t}\n\n\t// OWNER CONFIG\n\n\tfunction setRebalanceThreshold(uint16 rebalanceThreshold_) public onlyOwner {\n\t\trebalanceThreshold = rebalanceThreshold_;\n\t\temit SetRebalanceThreshold(rebalanceThreshold_);\n\t}\n\n\tfunction setSafetyMarginSqrt(uint256 safetyMarginSqrt_) public onlyOwner {\n\t\t_safetyMarginSqrt = safetyMarginSqrt_;\n\t\temit SetSafetyMarginSqrt(_safetyMarginSqrt);\n\t}\n\n\tfunction setMaxTvl(uint256 maxTvl_) public onlyRole(GUARDIAN) {\n\t\t_maxTvl = maxTvl_;\n\t\temit SetMaxTvl(maxTvl_);\n\t}\n\n\t// PUBLIC METHODS\n\n\tfunction short() public view override returns (IERC20) {\n\t\treturn _short;\n\t}\n\n\tfunction underlying() public view override returns (IERC20) {\n\t\treturn _underlying;\n\t}\n\n\t// deposit underlying and recieve lp tokens\n\tfunction deposit(uint256 underlyingAmnt) external onlyVault nonReentrant returns (uint256) {\n\t\tif (underlyingAmnt == 0) return 0; // cannot deposit 0\n\t\tuint256 tvl = getAndUpdateTVL();\n\t\trequire(underlyingAmnt + tvl <= getMaxTvl(), \"STRAT: OVER_MAX_TVL\");\n\t\tuint256 startBalance = collateralToken().balanceOf(address(this));\n\t\t_increasePosition(underlyingAmnt);\n\t\tuint256 endBalance = collateralToken().balanceOf(address(this));\n\t\treturn endBalance - startBalance;\n\t}\n\n\t// redeem lp for underlying\n\tfunction redeem(uint256 removeCollateral, address recipient)\n\t\tpublic\n\t\tonlyVault\n\t\treturns (uint256 amountTokenOut)\n\t{\n\t\t// this is the full amount of LP tokens totalSupply of shares is entitled to\n\t\t_decreasePosition(removeCollateral);\n\n\t\t// TODO make sure we never have any extra underlying dust sitting around\n\t\t// all 'extra' underlying should allways be transferred back to the vault\n\n\t\tunchecked {\n\t\t\tamountTokenOut = _underlying.balanceOf(address(this));\n\t\t}\n\t\t_underlying.safeTransfer(recipient, amountTokenOut);\n\t\temit Redeem(msg.sender, amountTokenOut);\n\t}\n\n\t// decreases position based to desired LP amount\n\t// ** does not rebalance remaining portfolio\n\t// ** make sure to update lending positions before calling this\n\tfunction _decreasePosition(uint256 removeCollateral) internal {\n\t\t// make sure we are not close to liquidation\n\t\tif (loanHealth() < MIN_LOAN_HEALTH) revert LowLoanHealth();\n\n\t\t(uint256 uBorrowBalance, uint256 sBorrowBalance) = _updateAndGetBorrowBalances();\n\n\t\tuint256 balance = collateralToken().balanceOf(address(this));\n\t\tuint256 lp = _getLiquidity(balance);\n\n\t\t// remove lp & repay underlying loan\n\t\t// round up to avoid under-repaying\n\t\tuint256 removeLp = lp.mulDivUp(removeCollateral, balance);\n\t\tuint256 uRepay = uBorrowBalance.mulDivUp(removeCollateral, balance);\n\t\tuint256 sRepay = sBorrowBalance.mulDivUp(removeCollateral, balance);\n\n\t\t_removeIMXLiquidity(removeLp, uRepay, sRepay);\n\t}\n\n\t// increases the position based on current desired balance\n\t// ** does not rebalance remaining portfolio\n\tfunction _increasePosition(uint256 amntUnderlying) internal {\n\t\tif (amntUnderlying < MINIMUM_LIQUIDITY) return; // avoid imprecision\n\t\t(uint256 uLp, ) = _getLPBalances();\n\t\t(uint256 uBorrowBalance, uint256 sBorrowBalance) = _getBorrowBalances();\n\n\t\tuint256 tvl = getAndUpdateTVL() - amntUnderlying;\n\n\t\tuint256 uBorrow;\n\t\tuint256 sBorrow;\n\t\tuint256 aUddLp;\n\t\tuint256 sAddLp;\n\n\t\tif (tvl == 0) {\n\t\t\tuBorrow = (_optimalUBorrow() * amntUnderlying) / 1e18;\n\t\t\taUddLp = amntUnderlying + uBorrow;\n\t\t\tsBorrow = _underlyingToShort(aUddLp);\n\t\t\tsAddLp = sBorrow;\n\t\t} else {\n\t\t\t// if tvl > 0 we need to keep the exact proportions of current position\n\t\t\t// to ensure we have correct accounting independent of price moves\n\t\t\tuBorrow = (uBorrowBalance * amntUnderlying) / tvl;\n\t\t\taUddLp = (uLp * amntUnderlying) / tvl;\n\t\t\tsBorrow = (sBorrowBalance * amntUnderlying) / tvl;\n\t\t\tsAddLp = _underlyingToShort(aUddLp);\n\t\t}\n\n\t\t_addIMXLiquidity(aUddLp, sAddLp, uBorrow, sBorrow);\n\t}\n\n\t// use the return of the function to estimate pending harvest via staticCall\n\tfunction harvest(HarvestSwapParms calldata harvestParams)\n\t\texternal\n\t\tonlyRole(MANAGER)\n\t\tnonReentrant\n\t\treturns (uint256 farmHarvest)\n\t{\n\t\t(uint256 startTvl, , , , , ) = getTVL();\n\t\tfarmHarvest = _harvestFarm(harvestParams);\n\n\t\t// compound our lp position\n\t\t_increasePosition(_underlying.balanceOf(address(this)));\n\t\temit Harvest(startTvl);\n\t}\n\n\t// There is not a situation where we would need this\n\t// function rebalanceLoan() public {\n\t// \tuint256 tvl = getOracleTvl();\n\t// \tuint256 tvl1 = getTotalTVL();\n\n\t// \tuint256 uBorrow = (tvl * _optimalUBorrow()) / 1e18;\n\t// \t(uint256 uBorrowBalance, ) = _getBorrowBalances();\n\n\t// \tif (uBorrowBalance <= uBorrow) return;\n\t// \tuint256 uRepay = uBorrowBalance - uBorrow;\n\t// \t(uint256 uLp, ) = _getLPBalances();\n\n\t// \tuint256 lp = _getLiquidity();\n\n\t// \t// remove lp & repay underlying loan\n\t// \tuint256 removeLp = (lp * uRepay) / uLp;\n\t// \tuint256 sRepay = type(uint256).max;\n\t// \t_removeIMXLiquidity(removeLp, uRepay, sRepay);\n\t// }\n\n\tfunction rebalance(uint256 expectedPrice, uint256 maxDelta)\n\t\texternal\n\t\tonlyRole(MANAGER)\n\t\tcheckPrice(expectedPrice, maxDelta)\n\t\tnonReentrant\n\t{\n\t\t// call this first to ensure we use an updated borrowBalance when computing offset\n\t\tuint256 tvl = getAndUpdateTVL();\n\t\tuint256 positionOffset = getPositionOffset();\n\n\t\t// don't rebalance unless we exceeded the threshold\n\t\tif (positionOffset <= rebalanceThreshold) revert RebalanceThreshold();\n\n\t\tif (tvl == 0) return;\n\t\tuint256 targetUBorrow = (tvl * _optimalUBorrow()) / 1e18;\n\t\tuint256 targetUnderlyingLP = tvl + targetUBorrow;\n\n\t\t(uint256 underlyingLp, uint256 shortLP) = _getLPBalances();\n\t\tuint256 targetShortLp = _underlyingToShort(targetUnderlyingLP);\n\t\t(uint256 uBorrowBalance, uint256 sBorrowBalance) = _updateAndGetBorrowBalances();\n\n\t\t// TODO account for uBalance\n\t\t// uint256 uBalance = underlying().balanceOf(address(this));\n\n\t\tif (underlyingLp > targetUnderlyingLP) {\n\t\t\t// TODO: we may need to borrow underlying\n\n\t\t\tuint256 uRepay = uBorrowBalance > targetUBorrow ? uBorrowBalance - targetUBorrow : 0;\n\t\t\tuint256 sRepay = sBorrowBalance > targetShortLp ? sBorrowBalance - targetShortLp : 0;\n\n\t\t\t// TODO check this\n\t\t\tuint256 lp = _getLiquidity();\n\t\t\tuint256 removeLp = lp - (lp * targetUnderlyingLP) / underlyingLp;\n\t\t\t_removeIMXLiquidity(removeLp, uRepay, sRepay);\n\t\t} else if (targetUnderlyingLP > underlyingLp) {\n\t\t\tuint256 uBorrow = targetUBorrow > uBorrowBalance ? targetUBorrow - uBorrowBalance : 0;\n\t\t\tuint256 sBorrow = targetShortLp > sBorrowBalance ? targetShortLp - sBorrowBalance : 0;\n\n\t\t\t// extra underlying balance will get re-paid automatically\n\t\t\t_addIMXLiquidity(\n\t\t\t\ttargetUnderlyingLP - underlyingLp,\n\t\t\t\ttargetShortLp - shortLP,\n\t\t\t\tuBorrow,\n\t\t\t\tsBorrow\n\t\t\t);\n\t\t}\n\t\temit Rebalance(_shortToUnderlying(1e18), positionOffset, tvl);\n\t}\n\n\t// vault handles slippage\n\tfunction closePosition() public onlyVault returns (uint256 balance) {\n\t\t(uint256 uRepay, uint256 sRepay) = _updateAndGetBorrowBalances();\n\t\tuint256 removeLp = _getLiquidity();\n\t\t_removeIMXLiquidity(removeLp, uRepay, sRepay);\n\t\t// transfer funds to vault\n\t\tbalance = _underlying.balanceOf(address(this));\n\t\t_underlying.safeTransfer(vault, balance);\n\t}\n\n\t// TVL\n\n\tfunction getMaxTvl() public view returns (uint256) {\n\t\t(, uint256 sBorrow) = _getBorrowBalances();\n\t\tuint256 availableToBorrow = sBorrowable().totalSupply() - sBorrowable().totalBorrows();\n\t\treturn\n\t\t\tmin(\n\t\t\t\t_maxTvl,\n\t\t\t\t// adjust the availableToBorrow to account for leverage\n\t\t\t\t_shortToUnderlying(\n\t\t\t\t\tsBorrow + (availableToBorrow * 1e18) / (_optimalUBorrow() + 1e18)\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\t// TODO should we compute pending farm & lending rewards here?\n\tfunction getAndUpdateTVL() public returns (uint256 tvl) {\n\t\t(uint256 uBorrow, uint256 shortPosition) = _updateAndGetBorrowBalances();\n\t\tuint256 borrowBalance = _shortToUnderlying(shortPosition) + uBorrow;\n\t\tuint256 shortP = _short.balanceOf(address(this));\n\t\tuint256 shortBalance = shortP == 0\n\t\t\t? 0\n\t\t\t: _shortToUnderlying(_short.balanceOf(address(this)));\n\t\t(uint256 underlyingLp, ) = _getLPBalances();\n\t\tuint256 underlyingBalance = _underlying.balanceOf(address(this));\n\t\ttvl = underlyingLp * 2 - borrowBalance + underlyingBalance + shortBalance;\n\t}\n\n\tfunction getTotalTVL() public view returns (uint256 tvl) {\n\t\t(tvl, , , , , ) = getTVL();\n\t}\n\n\t/// THere is no situation where we would need this\n\t// function getOracleTvl() public returns (uint256 tvl) {\n\t// \t(uint256 underlyingBorrow, uint256 borrowPosition) = _updateAndGetBorrowBalances();\n\t// \tuint256 borrowBalance = _shortToUnderlyingOracle(borrowPosition) + underlyingBorrow;\n\n\t// \tuint256 shortPosition = _short.balanceOf(address(this));\n\t// \tuint256 shortBalance = shortPosition == 0 ? 0 : _shortToUnderlyingOracle(shortPosition);\n\n\t// \t(uint256 underlyingLp, uint256 shortLp) = _getLPBalances();\n\t// \tuint256 lpBalance = underlyingLp + _shortToUnderlyingOracle(shortLp);\n\t// \tuint256 underlyingBalance = _underlying.balanceOf(address(this));\n\n\t// \ttvl = lpBalance - borrowBalance + underlyingBalance + shortBalance;\n\t// }\n\n\tfunction getTVL()\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tuint256 tvl,\n\t\t\tuint256,\n\t\t\tuint256 borrowPosition,\n\t\t\tuint256 borrowBalance,\n\t\t\tuint256 lpBalance,\n\t\t\tuint256 underlyingBalance\n\t\t)\n\t{\n\t\tuint256 underlyingBorrow;\n\t\t(underlyingBorrow, borrowPosition) = _getBorrowBalances();\n\t\tborrowBalance = _shortToUnderlying(borrowPosition) + underlyingBorrow;\n\n\t\tuint256 shortPosition = _short.balanceOf(address(this));\n\t\tuint256 shortBalance = shortPosition == 0 ? 0 : _shortToUnderlying(shortPosition);\n\n\t\t(uint256 underlyingLp, uint256 shortLp) = _getLPBalances();\n\t\tlpBalance = underlyingLp + _shortToUnderlying(shortLp);\n\t\tunderlyingBalance = _underlying.balanceOf(address(this));\n\n\t\ttvl = lpBalance - borrowBalance + underlyingBalance + shortBalance;\n\t}\n\n\tfunction getPositionOffset() public view returns (uint256 positionOffset) {\n\t\t(, uint256 shortLp) = _getLPBalances();\n\t\t(, uint256 borrowBalance) = _getBorrowBalances();\n\t\tuint256 shortBalance = shortLp + _short.balanceOf(address(this));\n\t\tif (shortBalance == borrowBalance) return 0;\n\t\t// if short lp > 0 and borrowBalance is 0 we are off by inf, returning 100% should be enough\n\t\tif (borrowBalance == 0) return 10000;\n\t\t// this is the % by which our position has moved from beeing balanced\n\n\t\tpositionOffset = shortBalance > borrowBalance\n\t\t\t? ((shortBalance - borrowBalance) * BPS_ADJUST) / borrowBalance\n\t\t\t: ((borrowBalance - shortBalance) * BPS_ADJUST) / borrowBalance;\n\t}\n\n\t// UTILS\n\tfunction getExpectedPrice() external view returns (uint256) {\n\t\treturn _shortToUnderlying(1e18);\n\t}\n\n\tfunction getLiquidity() external view returns (uint256) {\n\t\treturn _getLiquidity();\n\t}\n\n\t// used to estimate price of collateral token in underlying\n\tfunction collateralToUnderlying() external view returns (uint256) {\n\t\t(uint256 uR, uint256 sR, ) = pair().getReserves();\n\t\t(uR, sR) = address(_underlying) == pair().token0() ? (uR, sR) : (sR, uR);\n\t\tuint256 lp = pair().totalSupply();\n\t\t// for deposit of 1 underlying we get 1+_optimalUBorrow worth or lp -> collateral token\n\t\treturn (1e18 * (uR * _getLiquidity(1e18))) / lp / (1e18 + _optimalUBorrow());\n\t}\n\n\t/**\n\t * @dev Returns the smallest of two numbers.\n\t */\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a < b ? a : b;\n\t}\n\n\terror RebalanceThreshold();\n\terror LowLoanHealth();\n\terror SlippageExceeded();\n\terror OverMaxPriceOffset();\n}\n"
    },
    "src/strategies/imx/IMXFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ICollateral, IPoolToken, IBorrowable, ImpermaxChef } from \"../../interfaces/imx/IImpermax.sol\";\nimport { HarvestSwapParms, IIMXFarmU, IERC20, SafeERC20, IUniswapV2Pair, IUniswapV2Router01 } from \"../mixins/upgradable/IIMXFarmU.sol\";\nimport { UniUtils } from \"../../libraries/UniUtils.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { CallType, CalleeData, AddLiquidityAndMintCalldata, BorrowBCalldata, RemoveLiqAndRepayCalldata } from \"../../interfaces/Structs.sol\";\n\nimport \"hardhat/console.sol\";\n\nabstract contract IMXFarm is Initializable, IIMXFarmU {\n\tusing SafeERC20 for IERC20;\n\tusing UniUtils for IUniswapV2Pair;\n\t// using FixedPointMathLib for uint256;\n\n\tIUniswapV2Pair public _pair;\n\tICollateral private _collateralToken;\n\tIBorrowable private _uBorrowable;\n\tIBorrowable private _sBorrowable;\n\tIPoolToken private stakedToken;\n\tImpermaxChef private _impermaxChef;\n\n\tIERC20 private _farmToken;\n\tIUniswapV2Router01 private _farmRouter;\n\n\tbool public flip;\n\n\tfunction __IMXFarm_init_(\n\t\taddress underlying_,\n\t\taddress pair_,\n\t\taddress collateralToken_,\n\t\taddress farmRouter_,\n\t\taddress farmToken_\n\t) internal onlyInitializing {\n\t\t_pair = IUniswapV2Pair(pair_);\n\t\t_collateralToken = ICollateral(collateralToken_);\n\t\t_uBorrowable = IBorrowable(_collateralToken.borrowable0());\n\t\t_sBorrowable = IBorrowable(_collateralToken.borrowable1());\n\n\t\tif (underlying_ != _uBorrowable.underlying()) {\n\t\t\tflip = true;\n\t\t\t(_uBorrowable, _sBorrowable) = (_sBorrowable, _uBorrowable);\n\t\t}\n\t\tstakedToken = IPoolToken(_collateralToken.underlying());\n\t\t_impermaxChef = ImpermaxChef(_uBorrowable.borrowTracker());\n\t\t_farmToken = IERC20(farmToken_);\n\t\t_farmRouter = IUniswapV2Router01(farmRouter_);\n\n\t\t// necessary farm approvals\n\t\t_farmToken.safeApprove(address(farmRouter_), type(uint256).max);\n\t}\n\n\tfunction impermaxChef() public view override returns (ImpermaxChef) {\n\t\treturn _impermaxChef;\n\t}\n\n\tfunction collateralToken() public view override returns (ICollateral) {\n\t\treturn _collateralToken;\n\t}\n\n\tfunction sBorrowable() public view override returns (IBorrowable) {\n\t\treturn _sBorrowable;\n\t}\n\n\tfunction uBorrowable() public view override returns (IBorrowable) {\n\t\treturn _uBorrowable;\n\t}\n\n\tfunction farmRouter() public view override returns (IUniswapV2Router01) {\n\t\treturn _farmRouter;\n\t}\n\n\tfunction pair() public view override returns (IUniswapV2Pair) {\n\t\treturn _pair;\n\t}\n\n\tfunction _addIMXLiquidity(\n\t\tuint256 underlyingAmnt,\n\t\tuint256 shortAmnt,\n\t\tuint256 uBorrow,\n\t\tuint256 sBorrow\n\t) internal virtual override {\n\t\t_sBorrowable.borrowApprove(address(_sBorrowable), sBorrow);\n\n\t\t// mint collateral\n\t\tbytes memory addLPData = abi.encode(\n\t\t\tCalleeData({\n\t\t\t\tcallType: CallType.ADD_LIQUIDITY_AND_MINT,\n\t\t\t\tdata: abi.encode(\n\t\t\t\t\tAddLiquidityAndMintCalldata({ uAmnt: underlyingAmnt, sAmnt: shortAmnt })\n\t\t\t\t)\n\t\t\t})\n\t\t);\n\n\t\t// borrow short data\n\t\tbytes memory borrowSData = abi.encode(\n\t\t\tCalleeData({\n\t\t\t\tcallType: CallType.BORROWB,\n\t\t\t\tdata: abi.encode(BorrowBCalldata({ borrowAmount: uBorrow, data: addLPData }))\n\t\t\t})\n\t\t);\n\n\t\t// flashloan borrow then add lp\n\t\t_sBorrowable.borrow(address(this), address(this), sBorrow, borrowSData);\n\t}\n\n\tfunction impermaxBorrow(\n\t\taddress,\n\t\taddress,\n\t\tuint256,\n\t\tbytes calldata data\n\t) public {\n\t\t// ensure that msg.sender is correct\n\t\trequire(\n\t\t\tmsg.sender == address(_sBorrowable) || msg.sender == address(_uBorrowable),\n\t\t\t\"IMXFarm: NOT_BORROWABLE\"\n\t\t);\n\t\tCalleeData memory calleeData = abi.decode(data, (CalleeData));\n\n\t\tif (calleeData.callType == CallType.ADD_LIQUIDITY_AND_MINT) {\n\t\t\tAddLiquidityAndMintCalldata memory d = abi.decode(\n\t\t\t\tcalleeData.data,\n\t\t\t\t(AddLiquidityAndMintCalldata)\n\t\t\t);\n\t\t\t_addLp(d.uAmnt, d.sAmnt);\n\t\t} else if (calleeData.callType == CallType.BORROWB) {\n\t\t\tBorrowBCalldata memory d = abi.decode(calleeData.data, (BorrowBCalldata));\n\t\t\t_uBorrowable.borrow(address(this), address(this), d.borrowAmount, d.data);\n\t\t}\n\t}\n\n\tfunction _addLp(uint256 uAmnt, uint256 sAmnt) internal {\n\t\t{\n\t\t\tuint256 sBalance = short().balanceOf(address(this));\n\t\t\tuint256 uBalance = underlying().balanceOf(address(this));\n\n\t\t\t// if we have extra short tokens, trade them for underlying\n\t\t\tif (sBalance > sAmnt) {\n\t\t\t\t// TODO edge case - not enough underlying?\n\t\t\t\tuBalance += pair()._swapExactTokensForTokens(\n\t\t\t\t\tsBalance - sAmnt,\n\t\t\t\t\taddress(short()),\n\t\t\t\t\taddress(underlying())\n\t\t\t\t);\n\t\t\t} else if (sAmnt > sBalance) {\n\t\t\t\tuBalance -= pair()._swapTokensForExactTokens(\n\t\t\t\t\tsAmnt - sBalance,\n\t\t\t\t\taddress(underlying()),\n\t\t\t\t\taddress(short())\n\t\t\t\t);\n\t\t\t}\n\t\t\t// we know that now our sBalance = sAmnt\n\t\t\tif (uBalance < uAmnt) {\n\t\t\t\tuAmnt = uBalance;\n\t\t\t\tsAmnt = _underlyingToShort(uAmnt);\n\t\t\t} else if (uBalance > uAmnt) {\n\t\t\t\tunderlying().safeTransfer(address(_uBorrowable), uBalance - uAmnt);\n\t\t\t}\n\t\t}\n\n\t\tunderlying().safeTransfer(address(_pair), uAmnt);\n\t\tshort().safeTransfer(address(_pair), sAmnt);\n\n\t\tuint256 liquidity = _pair.mint(address(this));\n\n\t\t// first we create staked token, then collateral token\n\t\tIERC20(address(_pair)).safeTransfer(address(stakedToken), liquidity);\n\t\tstakedToken.mint(address(_collateralToken));\n\t\t_collateralToken.mint(address(this));\n\t}\n\n\tfunction _removeIMXLiquidity(\n\t\tuint256 removeLpAmnt,\n\t\tuint256 repayUnderlying,\n\t\tuint256 repayShort\n\t) internal override {\n\t\tuint256 redeemAmount = (removeLpAmnt * 1e18) / stakedToken.exchangeRate() + 1;\n\n\t\tbytes memory data = abi.encode(\n\t\t\tRemoveLiqAndRepayCalldata({\n\t\t\t\tremoveLpAmnt: removeLpAmnt,\n\t\t\t\trepayUnderlying: repayUnderlying,\n\t\t\t\trepayShort: repayShort\n\t\t\t})\n\t\t);\n\n\t\t_collateralToken.flashRedeem(address(this), redeemAmount, data);\n\t}\n\n\tfunction impermaxRedeem(\n\t\taddress,\n\t\tuint256 redeemAmount,\n\t\tbytes calldata data\n\t) public {\n\t\trequire(msg.sender == address(_collateralToken), \"IMXFarm: NOT_COLLATERAL\");\n\n\t\t// (uint256 , uint256 shortfall) = _collateralToken.accountLiquidity(address(this));\n\n\t\tRemoveLiqAndRepayCalldata memory d = abi.decode(data, (RemoveLiqAndRepayCalldata));\n\n\t\t// redeem withdrawn staked coins\n\t\tIERC20(address(stakedToken)).transfer(address(stakedToken), redeemAmount);\n\t\tstakedToken.redeem(address(this));\n\n\t\t// TODO this is not flash-swap safe!!!\n\t\t// add slippage param check modifier\n\n\t\t// remove collateral\n\t\t(, uint256 shortAmnt) = _removeLiquidity(d.removeLpAmnt);\n\n\t\t// trade extra tokens\n\n\t\t// if we have extra short tokens, trade them for underlying\n\t\tif (shortAmnt > d.repayShort) {\n\t\t\t// TODO edge case - not enough underlying?\n\t\t\tpair()._swapExactTokensForTokens(\n\t\t\t\tshortAmnt - d.repayShort,\n\t\t\t\taddress(short()),\n\t\t\t\taddress(underlying())\n\t\t\t);\n\t\t\tshortAmnt = d.repayShort;\n\t\t}\n\t\t// if we know the exact amount of short we must repay, then ensure we have that amount\n\t\telse if (d.repayShort > shortAmnt && d.repayShort != type(uint256).max) {\n\t\t\tpair()._swapTokensForExactTokens(\n\t\t\t\td.repayShort - shortAmnt,\n\t\t\t\taddress(underlying()),\n\t\t\t\taddress(short())\n\t\t\t);\n\t\t\tshortAmnt = d.repayShort;\n\t\t}\n\n\t\tuint256 uBalance = underlying().balanceOf(address(this));\n\n\t\t// repay short loan\n\t\tshort().safeTransfer(address(_sBorrowable), shortAmnt);\n\t\t_sBorrowable.borrow(address(this), address(0), 0, new bytes(0));\n\n\t\t// repay underlying loan\n\t\tunderlying().safeTransfer(\n\t\t\taddress(_uBorrowable),\n\t\t\td.repayUnderlying > uBalance ? uBalance : d.repayUnderlying\n\t\t);\n\t\t_uBorrowable.borrow(address(this), address(0), 0, new bytes(0));\n\n\t\tuint256 cAmount = (redeemAmount * 1e18) / _collateralToken.exchangeRate() + 1;\n\n\t\t// uint256 colBal = _collateralToken.balanceOf(address(this));\n\t\t// TODO add tests to make ensure cAmount < colBal\n\n\t\t// return collateral token\n\t\tIERC20(address(_collateralToken)).transfer(\n\t\t\taddress(_collateralToken),\n\t\t\t// colBal < cAmount ? colBal : cAmount\n\t\t\tcAmount\n\t\t);\n\t}\n\n\tfunction pendingHarvest() external view override returns (uint256 harvested) {\n\t\tif (address(_impermaxChef) == address(0)) return 0;\n\t\tharvested =\n\t\t\t_impermaxChef.pendingReward(address(_sBorrowable), address(this)) +\n\t\t\t_impermaxChef.pendingReward(address(_uBorrowable), address(this));\n\t}\n\n\tfunction harvestIsEnabled() public view returns (bool) {\n\t\treturn address(_impermaxChef) != address(0);\n\t}\n\n\tfunction _harvestFarm(HarvestSwapParms calldata harvestParams)\n\t\tinternal\n\t\toverride\n\t\treturns (uint256 harvested)\n\t{\n\t\t// rewards are not enabled\n\t\tif (address(_impermaxChef) == address(0)) return 0;\n\t\taddress[] memory borrowables = new address[](2);\n\t\tborrowables[0] = address(_sBorrowable);\n\t\tborrowables[1] = address(_uBorrowable);\n\n\t\tconsole.log(\"chef\", address(_impermaxChef));\n\t\t_impermaxChef.massHarvest(borrowables, address(this));\n\n\t\tharvested = _farmToken.balanceOf(address(this));\n\t\tconsole.log(\"harvested\", harvested);\n\t\tif (harvested == 0) return harvested;\n\n\t\t_swap(_farmRouter, harvestParams, address(_farmToken), harvested);\n\t\temit HarvestedToken(address(_farmToken), harvested);\n\t}\n\n\tfunction _getLiquidity() internal view override returns (uint256) {\n\t\treturn _getLiquidity(_collateralToken.balanceOf(address(this)));\n\t}\n\n\tfunction _getLiquidity(uint256 balance) internal view override returns (uint256) {\n\t\tif (balance == 0) return 0;\n\t\treturn\n\t\t\t(stakedToken.exchangeRate() * (_collateralToken.exchangeRate() * (balance - 1))) /\n\t\t\t1e18 /\n\t\t\t1e18;\n\t}\n\n\tfunction _getBorrowBalances() internal view override returns (uint256, uint256) {\n\t\treturn (\n\t\t\t_uBorrowable.borrowBalance(address(this)),\n\t\t\t_sBorrowable.borrowBalance(address(this))\n\t\t);\n\t}\n\n\tfunction accrueInterest() public override {\n\t\t_sBorrowable.accrueInterest();\n\t\t_uBorrowable.accrueInterest();\n\t}\n\n\tfunction _updateAndGetBorrowBalances() internal override returns (uint256, uint256) {\n\t\taccrueInterest();\n\t\treturn _getBorrowBalances();\n\t}\n\n\t// borrow amount of underlying for every 1e18 of deposit\n\tfunction _optimalUBorrow() internal view override returns (uint256 uBorrow) {\n\t\tuint256 l = _collateralToken.liquidationIncentive();\n\t\t// this is the adjusted safety margin - how far we stay from liquidation\n\t\tuint256 s = (_collateralToken.safetyMarginSqrt() * safetyMarginSqrt()) / 1e18;\n\t\tuBorrow = (1e18 * (2e18 - (l * s) / 1e18)) / ((l * 1e18) / s + (l * s) / 1e18 - 2e18);\n\t}\n\n\tfunction loanHealth() public view override returns (uint256) {\n\t\tuint256 balance = IERC20(address(_collateralToken)).balanceOf(address(this));\n\t\tif (balance == 0) return 100e18;\n\t\tuint256 liq = (balance * _collateralToken.exchangeRate()) / 1e18;\n\t\t(uint256 available, uint256 shortfall) = _collateralToken.accountLiquidity(address(this));\n\t\treturn shortfall == 0 ? (1e18 * (liq + available)) / liq : (1e18 * (liq - shortfall)) / liq;\n\t}\n\n\tfunction _shortToUnderlyingOracle(uint256 amount) internal view override returns (uint256) {\n\t\t(uint256 price0, uint256 price1) = collateralToken().getPrices();\n\t\treturn flip ? (amount * price0) / price1 : (amount * price1) / price0;\n\t}\n\n\t// TODO RM - can do this in JS or in tests\n\t// function getIMXLiquidity() external view returns (uint256 leverage) {\n\t// \tuint256 collateral = (_collateralToken.exchangeRate() *\n\t// \t\t_collateralToken.balanceOf(address(this))) / 1e18;\n\n\t// \tuint256 amount0 = _uBorrowable.borrowBalance(address(this));\n\t// \tuint256 amount1 = _sBorrowable.borrowBalance(address(this));\n\n\t// \t(uint256 price0, uint256 price1) = _collateralToken.getPrices();\n\n\t// \tuint256 value0 = (amount0 * price0) / 1e18;\n\t// \tuint256 value1 = (amount1 * price1) / 1e18;\n\t// \tif (flip) (value0, value1) = (value1, value0);\n\n\t// \tleverage = (collateral * 1e18) / (collateral - value0 - value1 + 1);\n\t// \tconsole.log(\"leverage\", (collateral * 1e18) / (collateral - value0 - value1 + 1));\n\t// }\n}\n"
    },
    "src/interfaces/Structs.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nenum CallType {\n\tADD_LIQUIDITY_AND_MINT,\n\tBORROWB,\n\tREMOVE_LIQ_AND_REPAY\n}\n\nstruct CalleeData {\n\tCallType callType;\n\tbytes data;\n}\nstruct AddLiquidityAndMintCalldata {\n\tuint256 uAmnt;\n\tuint256 sAmnt;\n}\nstruct BorrowBCalldata {\n\tuint256 borrowAmount;\n\tbytes data;\n}\nstruct RemoveLiqAndRepayCalldata {\n\tuint256 removeLpAmnt;\n\tuint256 repayUnderlying;\n\tuint256 repayShort;\n\t// uint256 amountAMin;\n\t// uint256 amountBMin;\n}\n\nstruct HarvestSwapParms {\n\taddress[] path; //path that the token takes\n\tuint256 min; // min price of in token * 1e18 (computed externally based on spot * slippage + fees)\n\tuint256 deadline;\n}\n\nstruct IMXConfig {\n\taddress vault;\n\taddress underlying;\n\taddress short;\n\taddress uniPair;\n\taddress poolToken;\n\taddress farmToken;\n\taddress farmRouter;\n\tuint256 maxTvl;\n\taddress owner;\n\taddress manager;\n\taddress guardian;\n}\n\nstruct Config {\n\taddress underlying;\n\taddress short;\n\taddress cTokenLend;\n\taddress cTokenBorrow;\n\taddress uniPair;\n\taddress uniFarm;\n\taddress farmToken;\n\tuint256 farmId;\n\taddress farmRouter;\n\taddress comptroller;\n\taddress lendRewardRouter;\n\taddress lendRewardToken;\n\taddress vault;\n\tstring symbol;\n\tstring name;\n\tuint256 maxTvl;\n}\n"
    },
    "src/strategies/mixins/upgradable/IBaseU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport { HarvestSwapParms } from \"../../../interfaces/Structs.sol\";\n\nabstract contract IBaseU {\n\tfunction short() public view virtual returns (IERC20);\n\n\tfunction underlying() public view virtual returns (IERC20);\n}\n"
    },
    "src/strategies/mixins/upgradable/IIMXFarmU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport { IBorrowable, ICollateral, ImpermaxChef } from \"../../../interfaces/imx/IImpermax.sol\";\n\nimport { IBaseU, HarvestSwapParms } from \"./IBaseU.sol\";\nimport { IUniLpU, IUniswapV2Pair, SafeERC20, IERC20 } from \"./IUniLpU.sol\";\nimport { IFarmableU, IUniswapV2Router01 } from \"./IFarmableU.sol\";\n\nabstract contract IIMXFarmU is IBaseU, IFarmableU, IUniLpU {\n\tfunction loanHealth() public view virtual returns (uint256);\n\n\tfunction sBorrowable() public view virtual returns (IBorrowable);\n\n\tfunction uBorrowable() public view virtual returns (IBorrowable);\n\n\tfunction collateralToken() public view virtual returns (ICollateral);\n\n\tfunction impermaxChef() public view virtual returns (ImpermaxChef);\n\n\tfunction pendingHarvest() external view virtual returns (uint256 harvested);\n\n\tfunction farmRouter() public view virtual returns (IUniswapV2Router01);\n\n\tfunction _getBorrowBalances()\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (uint256 underlyingAmnt, uint256 shortAmnt);\n\n\tfunction _updateAndGetBorrowBalances()\n\t\tinternal\n\t\tvirtual\n\t\treturns (uint256 underlyingAmnt, uint256 shortAmnt);\n\n\tfunction _optimalUBorrow() internal view virtual returns (uint256 uBorrow);\n\n\tfunction _harvestFarm(HarvestSwapParms calldata swapParams) internal virtual returns (uint256);\n\n\tfunction safetyMarginSqrt() public view virtual returns (uint256);\n\n\tfunction accrueInterest() public virtual;\n\n\tfunction _addIMXLiquidity(\n\t\tuint256 underlyingAmnt,\n\t\tuint256 shortAmnt,\n\t\tuint256 uBorrow,\n\t\tuint256 sBorrow\n\t) internal virtual;\n\n\tfunction _removeIMXLiquidity(\n\t\tuint256 removeLp,\n\t\tuint256 repayUnderlying,\n\t\tuint256 repayShort\n\t) internal virtual;\n\n\tfunction _shortToUnderlyingOracle(uint256 amount) internal view virtual returns (uint256);\n}\n"
    },
    "src/libraries/UniUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\nimport \"../interfaces/uniswap/IUniswapV2Pair.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router01.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Factory.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nlibrary UniUtils {\n\tusing SafeERC20 for IERC20;\n\n\tfunction _getPairTokens(IUniswapV2Pair pair) internal view returns (address, address) {\n\t\treturn (pair.token0(), pair.token1());\n\t}\n\n\tfunction _getPairReserves(\n\t\tIUniswapV2Pair pair,\n\t\taddress tokenA,\n\t\taddress tokenB\n\t) internal view returns (uint256 reserveA, uint256 reserveB) {\n\t\t(address token0, ) = _sortTokens(tokenA, tokenB);\n\t\t(uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\t\t(reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n\t}\n\n\t// given some amount of an asset and lp reserves, returns an equivalent amount of the other asset\n\tfunction _quote(\n\t\tuint256 amountA,\n\t\tuint256 reserveA,\n\t\tuint256 reserveB\n\t) internal pure returns (uint256 amountB) {\n\t\trequire(amountA > 0, \"UniUtils: INSUFFICIENT_AMOUNT\");\n\t\trequire(reserveA > 0 && reserveB > 0, \"UniUtils: INSUFFICIENT_LIQUIDITY\");\n\t\tamountB = (amountA * reserveB) / reserveA;\n\t}\n\n\tfunction _sortTokens(address tokenA, address tokenB)\n\t\tinternal\n\t\tpure\n\t\treturns (address token0, address token1)\n\t{\n\t\trequire(tokenA != tokenB, \"UniUtils: IDENTICAL_ADDRESSES\");\n\t\t(token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n\t\trequire(token0 != address(0), \"UniUtils: ZERO_ADDRESS\");\n\t}\n\n\tfunction _getAmountOut(\n\t\tIUniswapV2Pair pair,\n\t\tuint256 amountIn,\n\t\taddress inToken,\n\t\taddress outToken\n\t) internal view returns (uint256 amountOut) {\n\t\trequire(amountIn > 0, \"UniUtils: INSUFFICIENT_INPUT_AMOUNT\");\n\t\t(uint256 reserveIn, uint256 reserveOut) = _getPairReserves(pair, inToken, outToken);\n\t\tuint256 amountInWithFee = amountIn * 997;\n\t\tuint256 numerator = amountInWithFee * reserveOut;\n\t\tuint256 denominator = reserveIn * 1000 + amountInWithFee;\n\t\tamountOut = numerator / denominator;\n\t}\n\n\tfunction _getAmountIn(\n\t\tIUniswapV2Pair pair,\n\t\tuint256 amountOut,\n\t\taddress inToken,\n\t\taddress outToken\n\t) internal view returns (uint256 amountIn) {\n\t\trequire(amountOut > 0, \"UniUtils: INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\t(uint256 reserveIn, uint256 reserveOut) = _getPairReserves(pair, inToken, outToken);\n\t\tuint256 numerator = reserveIn * amountOut * 1000;\n\t\tuint256 denominator = (reserveOut - amountOut) * 997;\n\t\tamountIn = (numerator / denominator) + 1;\n\t}\n\n\tfunction _swapExactTokensForTokens(\n\t\tIUniswapV2Pair pair,\n\t\tuint256 amountIn,\n\t\taddress inToken,\n\t\taddress outToken\n\t) internal returns (uint256) {\n\t\tuint256 amountOut = _getAmountOut(pair, amountIn, inToken, outToken);\n\t\tif (amountOut == 0) return 0;\n\t\t(address token0, ) = _sortTokens(outToken, inToken);\n\t\t(uint256 amount0Out, uint256 amount1Out) = inToken == token0\n\t\t\t? (uint256(0), amountOut)\n\t\t\t: (amountOut, uint256(0));\n\n\t\tIERC20(inToken).safeTransfer(address(pair), amountIn);\n\t\tpair.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\t\treturn amountOut;\n\t}\n\n\tfunction _swapTokensForExactTokens(\n\t\tIUniswapV2Pair pair,\n\t\tuint256 amountOut,\n\t\taddress inToken,\n\t\taddress outToken\n\t) internal returns (uint256) {\n\t\tuint256 amountIn = _getAmountIn(pair, amountOut, inToken, outToken);\n\t\t(address token0, ) = _sortTokens(outToken, inToken);\n\t\t(uint256 amount0Out, uint256 amount1Out) = inToken == token0\n\t\t\t? (uint256(0), amountOut)\n\t\t\t: (amountOut, uint256(0));\n\n\t\tIERC20(inToken).safeTransfer(address(pair), amountIn);\n\t\tpair.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\t\treturn amountIn;\n\t}\n}\n"
    },
    "src/strategies/imx/IMXAuthU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20Upgradeable as SafeERC20, IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { SafeETH } from \"../../libraries/SafeETH.sol\";\n\nimport { AuthU } from \"../../common/AuthU.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract IMXAuthU is AuthU {\n\tusing SafeERC20 for IERC20;\n\n\taddress public vault;\n\n\tmodifier onlyVault() {\n\t\trequire(msg.sender == vault, \"Strat: ONLY_VAULT\");\n\t\t_;\n\t}\n\n\tevent EmergencyWithdraw(address indexed recipient, IERC20[] tokens);\n\n\t// emergency only - send stuck tokens to the owner\n\t// TODO make arbitrary calls from owner?\n\tfunction emergencyWithdraw(address recipient, IERC20[] calldata tokens)\n\t\texternal\n\t\tonlyRole(GUARDIAN)\n\t{\n\t\tfor (uint256 i = 0; i < tokens.length; i++) {\n\t\t\tIERC20 token = tokens[i];\n\t\t\tuint256 balance = token.balanceOf(address(this));\n\t\t\tif (balance != 0) token.safeTransfer(recipient, balance);\n\t\t}\n\t\tif (address(this).balance > 0) SafeETH.safeTransferETH(recipient, address(this).balance);\n\t\temit EmergencyWithdraw(recipient, tokens);\n\t}\n\n\tuint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/interfaces/imx/IImpermax.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\ninterface IMXRouter2 {\n\tfunction mint(\n\t\taddress collateralToken,\n\t\tuint256 amount,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 tokens);\n\n\tfunction borrow(\n\t\taddress borrowable,\n\t\tuint256 amount,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbytes memory permitData\n\t) external;\n\n\tfunction borrowETH(\n\t\taddress borrowable,\n\t\tuint256 amountETH,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbytes memory permitData\n\t) external;\n}\n\ninterface IPoolToken {\n\tfunction totalBalance() external view returns (uint256);\n\n\tfunction mint(address minter) external returns (uint256 mintTokens);\n\n\tfunction underlying() external view returns (address);\n\n\tfunction exchangeRate() external view returns (uint256);\n\n\tfunction redeem(address redeemer) external returns (uint256 redeemAmount);\n}\n\ninterface IBorrowable {\n\tfunction borrow(\n\t\taddress borrower,\n\t\taddress receiver,\n\t\tuint256 borrowAmount,\n\t\tbytes calldata data\n\t) external;\n\n\tfunction borrowApprove(address spender, uint256 value) external returns (bool);\n\n\tfunction accrueInterest() external;\n\n\tfunction borrowBalance(address borrower) external view returns (uint256);\n\n\tfunction underlying() external view returns (address);\n\n\tfunction exchangeRate() external returns (uint256);\n\n\tfunction exchangeRateLast() external view returns (uint256);\n\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction totalBorrows() external view returns (uint256);\n\n\tfunction borrowTracker() external view returns (address);\n}\n\ninterface ICollateral {\n\tfunction safetyMarginSqrt() external view returns (uint256);\n\n\tfunction liquidationIncentive() external view returns (uint256);\n\n\tfunction underlying() external view returns (address);\n\n\tfunction borrowable0() external view returns (address);\n\n\tfunction borrowable1() external view returns (address);\n\n\tfunction accountLiquidity(address account)\n\t\texternal\n\t\tview\n\t\treturns (uint256 liquidity, uint256 shortfall);\n\n\tfunction flashRedeem(\n\t\taddress redeemer,\n\t\tuint256 redeemAmount,\n\t\tbytes calldata data\n\t) external;\n\n\tfunction mint(address minter) external returns (uint256 mintTokens);\n\n\tfunction exchangeRate() external view returns (uint256);\n\n\tfunction getPrices() external view returns (uint256 price0, uint256 price1);\n\n\tfunction balanceOf(address) external view returns (uint256);\n\n\tfunction getTwapPrice112x112() external view returns (uint224 twapPrice112x112);\n\n\tfunction simpleUniswapOracle() external view returns (address);\n\n\tfunction tarotPriceOracle() external view returns (address);\n}\n\ninterface ImpermaxChef {\n\tfunction pendingReward(address borrowable, address _user) external view returns (uint256);\n\n\tfunction harvest(address borrowable, address to) external;\n\n\tfunction massHarvest(address[] calldata borrowables, address to) external;\n}\n"
    },
    "src/strategies/mixins/upgradable/IUniLpU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20Upgradeable as SafeERC20, IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { IUniswapV2Pair } from \"../../../interfaces/uniswap/IUniswapV2Pair.sol\";\nimport { UniUtils } from \"../../../libraries/UniUtils.sol\";\n\nimport { IBaseU, HarvestSwapParms } from \"./IBaseU.sol\";\nimport { ILp } from \"../ILp.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract IUniLpU is IBaseU, ILp {\n\tusing SafeERC20 for IERC20;\n\tusing UniUtils for IUniswapV2Pair;\n\n\tfunction pair() public view virtual returns (IUniswapV2Pair);\n\n\tfunction _quote(\n\t\tuint256 amount,\n\t\taddress token0,\n\t\taddress token1\n\t) internal view virtual override returns (uint256 price) {\n\t\tif (amount == 0) return 0;\n\t\t(uint256 reserve0, uint256 reserve1) = pair()._getPairReserves(token0, token1);\n\t\tprice = UniUtils._quote(amount, reserve0, reserve1);\n\t}\n\n\t// should only be called after oracle or user-input swap price check\n\tfunction _addLiquidity(uint256 amountToken0, uint256 amountToken1)\n\t\tinternal\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256 liquidity)\n\t{\n\t\tunderlying().safeTransfer(address(pair()), amountToken0);\n\t\tshort().safeTransfer(address(pair()), amountToken1);\n\t\tliquidity = pair().mint(address(this));\n\t}\n\n\tfunction _removeLiquidity(uint256 liquidity)\n\t\tinternal\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256, uint256)\n\t{\n\t\tIERC20(address(pair())).safeTransfer(address(pair()), liquidity);\n\t\t(address tokenA, ) = UniUtils._sortTokens(address(underlying()), address(short()));\n\t\t(uint256 amountToken0, uint256 amountToken1) = pair().burn(address(this));\n\t\treturn\n\t\t\ttokenA == address(underlying())\n\t\t\t\t? (amountToken0, amountToken1)\n\t\t\t\t: (amountToken1, amountToken0);\n\t}\n\n\t// fetches and sorts the reserves for a uniswap pair\n\tfunction getUnderlyingShortReserves() public view returns (uint256 reserveA, uint256 reserveB) {\n\t\t(reserveA, reserveB) = pair()._getPairReserves(address(underlying()), address(short()));\n\t}\n\n\tfunction _getLPBalances()\n\t\tinternal\n\t\tview\n\t\toverride\n\t\treturns (uint256 underlyingBalance, uint256 shortBalance)\n\t{\n\t\tuint256 totalLp = _getLiquidity();\n\t\t(uint256 totalUnderlyingBalance, uint256 totalShortBalance) = getUnderlyingShortReserves();\n\t\tuint256 total = pair().totalSupply();\n\t\tunderlyingBalance = (totalUnderlyingBalance * totalLp) / total;\n\t\tshortBalance = (totalShortBalance * totalLp) / total;\n\t}\n\n\t// this is the current uniswap price\n\tfunction _shortToUnderlying(uint256 amount) internal view virtual returns (uint256) {\n\t\treturn amount == 0 ? 0 : _quote(amount, address(short()), address(underlying()));\n\t}\n\n\t// this is the current uniswap price\n\tfunction _underlyingToShort(uint256 amount) internal view virtual returns (uint256) {\n\t\treturn amount == 0 ? 0 : _quote(amount, address(underlying()), address(short()));\n\t}\n}\n"
    },
    "src/strategies/mixins/upgradable/IFarmableU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IUniswapV2Router01 } from \"../../../interfaces/uniswap/IUniswapV2Router01.sol\";\nimport { IBaseU, HarvestSwapParms } from \"./IBaseU.sol\";\n\nabstract contract IFarmableU is IBaseU {\n\tevent HarvestedToken(address indexed token, uint256 amount);\n\n\tfunction _swap(\n\t\tIUniswapV2Router01 router,\n\t\tHarvestSwapParms calldata swapParams,\n\t\taddress fromToken,\n\t\tuint256 amount\n\t) internal {\n\t\treturn _swapTo(router, swapParams, fromToken, amount, address(this));\n\t}\n\n\tfunction _swapTo(\n\t\tIUniswapV2Router01 router,\n\t\tHarvestSwapParms calldata swapParams,\n\t\taddress fromToken,\n\t\tuint256 amount,\n\t\taddress to\n\t) internal {\n\t\taddress out = swapParams.path[swapParams.path.length - 1];\n\t\t// ensure malicious harvester is not trading with wrong tokens\n\t\t// TODO should we add more validation to prevent malicious path?\n\t\trequire(\n\t\t\t((swapParams.path[0] == address(fromToken) && (out == address(short()))) ||\n\t\t\t\tout == address(underlying())),\n\t\t\t\"IFarmable: BAD_PATH\"\n\t\t);\n\t\trouter.swapExactTokensForTokens(\n\t\t\tamount,\n\t\t\tswapParams.min,\n\t\t\tswapParams.path, // optimal route determined externally\n\t\t\tto,\n\t\t\tswapParams.deadline\n\t\t);\n\t}\n}\n"
    },
    "src/interfaces/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IUniswapV2Pair {\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\tfunction name() external pure returns (string memory);\n\n\tfunction symbol() external pure returns (string memory);\n\n\tfunction decimals() external pure returns (uint8);\n\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction balanceOf(address owner) external view returns (uint256);\n\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\tfunction approve(address spender, uint256 value) external returns (bool);\n\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) external returns (bool);\n\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\n\tfunction nonces(address owner) external view returns (uint256);\n\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\tevent Mint(address indexed sender, uint256 amount0, uint256 amount1);\n\tevent Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n\tevent Swap(\n\t\taddress indexed sender,\n\t\tuint256 amount0In,\n\t\tuint256 amount1In,\n\t\tuint256 amount0Out,\n\t\tuint256 amount1Out,\n\t\taddress indexed to\n\t);\n\tevent Sync(uint112 reserve0, uint112 reserve1);\n\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n\tfunction factory() external view returns (address);\n\n\tfunction token0() external view returns (address);\n\n\tfunction token1() external view returns (address);\n\n\tfunction getReserves()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint112 reserve0,\n\t\t\tuint112 reserve1,\n\t\t\tuint32 blockTimestampLast\n\t\t);\n\n\tfunction price0CumulativeLast() external view returns (uint256);\n\n\tfunction price1CumulativeLast() external view returns (uint256);\n\n\tfunction kLast() external view returns (uint256);\n\n\tfunction mint(address to) external returns (uint256 liquidity);\n\n\tfunction burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n\tfunction swap(\n\t\tuint256 amount0Out,\n\t\tuint256 amount1Out,\n\t\taddress to,\n\t\tbytes calldata data\n\t) external;\n\n\tfunction skim(address to) external;\n\n\tfunction sync() external;\n\n\tfunction initialize(address, address) external;\n}\n"
    },
    "src/strategies/mixins/ILp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nabstract contract ILp {\n\tfunction _quote(\n\t\tuint256 amount,\n\t\taddress token0,\n\t\taddress token1\n\t) internal view virtual returns (uint256 price);\n\n\tfunction _getLiquidity() internal view virtual returns (uint256);\n\n\tfunction _getLiquidity(uint256) internal view virtual returns (uint256);\n\n\tfunction _addLiquidity(uint256 amountToken0, uint256 amountToken1)\n\t\tinternal\n\t\tvirtual\n\t\treturns (uint256 liquidity);\n\n\tfunction _removeLiquidity(uint256 liquidity) internal virtual returns (uint256, uint256);\n\n\tfunction _getLPBalances()\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (uint256 underlyingBalance, uint256 shortBalance);\n}\n"
    },
    "src/interfaces/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IUniswapV2Router01 {\n\tfunction factory() external pure returns (address);\n\n\tfunction WETH() external pure returns (address);\n\n\tfunction addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 amountADesired,\n\t\tuint256 amountBDesired,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t)\n\t\texternal\n\t\treturns (\n\t\t\tuint256 amountA,\n\t\t\tuint256 amountB,\n\t\t\tuint256 liquidity\n\t\t);\n\n\tfunction addLiquidityETH(\n\t\taddress token,\n\t\tuint256 amountTokenDesired,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t)\n\t\texternal\n\t\tpayable\n\t\treturns (\n\t\t\tuint256 amountToken,\n\t\t\tuint256 amountETH,\n\t\t\tuint256 liquidity\n\t\t);\n\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidity,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountA, uint256 amountB);\n\n\tfunction removeLiquidityETH(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountToken, uint256 amountETH);\n\n\tfunction removeLiquidityWithPermit(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidity,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint256 amountA, uint256 amountB);\n\n\tfunction removeLiquidityETHWithPermit(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint256 amountToken, uint256 amountETH);\n\n\tfunction swapExactTokensForTokens(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapTokensForExactTokens(\n\t\tuint256 amountOut,\n\t\tuint256 amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapExactETHForTokens(\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable returns (uint256[] memory amounts);\n\n\tfunction swapTokensForExactETH(\n\t\tuint256 amountOut,\n\t\tuint256 amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapExactTokensForETH(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapETHForExactTokens(\n\t\tuint256 amountOut,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable returns (uint256[] memory amounts);\n\n\tfunction quote(\n\t\tuint256 amountA,\n\t\tuint256 reserveA,\n\t\tuint256 reserveB\n\t) external pure returns (uint256 amountB);\n\n\tfunction getAmountOut(\n\t\tuint256 amountIn,\n\t\tuint256 reserveIn,\n\t\tuint256 reserveOut\n\t) external pure returns (uint256 amountOut);\n\n\tfunction getAmountIn(\n\t\tuint256 amountOut,\n\t\tuint256 reserveIn,\n\t\tuint256 reserveOut\n\t) external pure returns (uint256 amountIn);\n\n\tfunction getAmountsOut(uint256 amountIn, address[] calldata path)\n\t\texternal\n\t\tview\n\t\treturns (uint256[] memory amounts);\n\n\tfunction getAmountsIn(uint256 amountOut, address[] calldata path)\n\t\texternal\n\t\tview\n\t\treturns (uint256[] memory amounts);\n}\n"
    },
    "src/interfaces/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IUniswapV2Factory {\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n\tfunction feeTo() external view returns (address);\n\n\tfunction feeToSetter() external view returns (address);\n\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n\n\tfunction allPairs(uint256) external view returns (address pair);\n\n\tfunction allPairsLength() external view returns (uint256);\n\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n\n\tfunction setFeeTo(address) external;\n\n\tfunction setFeeToSetter(address) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "src/common/AuthU.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\ncontract AuthU is AccessControlUpgradeable {\n\tevent OwnershipTransferInitiated(address owner, address pendingOwner);\n\tevent OwnershipTransferred(address oldOwner, address newOwner);\n\n\t////////// CONSTANTS //////////\n\n\t/// Update vault params, perform time-sensitive operations, set manager\n\tbytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n\n\t/// Hot-wallet bots that route funds between vaults, rebalance and harvest strategies\n\tbytes32 public constant MANAGER = keccak256(\"MANAGER\");\n\n\t/// Add and remove vaults and strategies and other critical operations behind timelock\n\t/// Default admin role\n\t/// There should only be one owner, so it is not a role\n\taddress public owner;\n\taddress public pendingOwner;\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"ONLY_OWNER\");\n\t\t_;\n\t}\n\n\t/// security no undefined constructor\n\tconstructor() {}\n\n\tfunction __Auth_init_(\n\t\taddress _owner,\n\t\taddress guardian,\n\t\taddress manager\n\t) public onlyInitializing {\n\t\t/// Set up the roles\n\t\t// owner can manage all roles\n\t\towner = _owner;\n\t\temit OwnershipTransferred(address(0), owner);\n\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, owner);\n\t\t_grantRole(GUARDIAN, owner);\n\t\t_grantRole(GUARDIAN, guardian);\n\t\t_grantRole(MANAGER, owner);\n\t\t_grantRole(MANAGER, guardian);\n\t\t_grantRole(MANAGER, manager);\n\n\t\t/// Allow the guardian role to manage manager\n\t\t_setRoleAdmin(MANAGER, GUARDIAN);\n\t}\n\n\t// ----------- Ownership -----------\n\n\t/// @dev Init transfer of ownership of the contract to a new account (`_pendingOwner`).\n\t/// @param _pendingOwner pending owner of contract\n\t/// Can only be called by the current owner.\n\tfunction transferOwnership(address _pendingOwner) external onlyOwner {\n\t\tpendingOwner = _pendingOwner;\n\t\temit OwnershipTransferInitiated(owner, pendingOwner);\n\t}\n\n\t/// @dev Accept transfer of ownership of the contract.\n\t/// Can only be called by the pendingOwner.\n\tfunction acceptOwnership() external {\n\t\trequire(msg.sender == pendingOwner, \"ONLY_PENDING_OWNER\");\n\t\taddress oldOwner = owner;\n\t\towner = pendingOwner;\n\n\t\t// revoke the DEFAULT ADMIN ROLE from prev owner\n\t\t_revokeRole(DEFAULT_ADMIN_ROLE, oldOwner);\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, owner);\n\n\t\temit OwnershipTransferred(oldOwner, owner);\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/vaults/ERC4626/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { FixedPointMathLib } from \"../../libraries/FixedPointMathLib.sol\";\nimport { IERC4626 } from \"../../interfaces/ERC4626/IERC4626.sol\";\nimport { Auth } from \"../../common/Auth.sol\";\nimport { Accounting } from \"../../common/Accounting.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Fees } from \"../../common/Fees.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is Auth, Accounting, Fees, IERC4626, ERC20 {\n\tusing SafeERC20 for ERC20;\n\tusing FixedPointMathLib for uint256;\n\n\t/*//////////////////////////////////////////////////////////////\n                               CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n\t// locked liquidity to prevent rounding errors\n\tuint256 public constant MIN_LIQUIDITY = 1e3;\n\n\t/*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n\tERC20 immutable asset;\n\n\tconstructor(\n\t\tERC20 _asset,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\taddress _owner,\n\t\taddress _guardian,\n\t\taddress _manager,\n\t\taddress _treasury,\n\t\tuint256 _performanceFee\n\t) ERC20(_name, _symbol) Auth(_owner, _guardian, _manager) Fees(_treasury, _performanceFee) {\n\t\tasset = _asset;\n\t}\n\n\tfunction decimals() public view override returns (uint8) {\n\t\treturn asset.decimals();\n\t}\n\n\tfunction totalAssets() public view virtual override returns (uint256) {\n\t\treturn asset.balanceOf(address(this));\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n\t\t// This check is no longer necessary because we use MIN_LIQUIDITY\n\t\t// Check for rounding error since we round down in previewDeposit.\n\t\t// require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\t\tshares = previewDeposit(assets);\n\n\t\t// Need to transfer before minting or ERC777s could reenter.\n\t\tasset.safeTransferFrom(msg.sender, address(this), assets);\n\n\t\t// lock minimum liquidity if totalSupply is 0\n\t\tif (totalSupply() == 0) {\n\t\t\tif (MIN_LIQUIDITY > shares) revert MinLiquidity();\n\t\t\tshares -= MIN_LIQUIDITY;\n\t\t\t_mint(address(1), MIN_LIQUIDITY);\n\t\t}\n\n\t\t_mint(receiver, shares);\n\n\t\temit Deposit(msg.sender, receiver, assets, shares);\n\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n\t\tassets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n\t\t// Need to transfer before minting or ERC777s could reenter.\n\t\tasset.safeTransferFrom(msg.sender, address(this), assets);\n\n\t\t_mint(receiver, shares);\n\n\t\temit Deposit(msg.sender, receiver, assets, shares);\n\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction withdraw(\n\t\tuint256 assets,\n\t\taddress receiver,\n\t\taddress owner\n\t) public virtual returns (uint256 shares) {\n\t\tshares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n\t\t// if not owner, allowance must be enforced\n\t\tif (msg.sender != owner) _spendAllowance(owner, msg.sender, shares);\n\n\t\tbeforeWithdraw(assets, shares);\n\n\t\t_burn(owner, shares);\n\n\t\temit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n\t\tasset.safeTransfer(receiver, assets);\n\t}\n\n\tfunction redeem(\n\t\tuint256 shares,\n\t\taddress receiver,\n\t\taddress owner\n\t) public virtual returns (uint256 assets) {\n\t\t// if not owner, allowance must be enforced\n\t\tif (msg.sender != owner) _spendAllowance(owner, msg.sender, shares);\n\n\t\t// This check is no longer necessary because we use MIN_LIQUIDITY\n\t\t// Check for rounding error since we round down in previewRedeem.\n\t\t// require((assets = previewRedeem(shares)) != 0, \"ZEROassetS\");\n\t\tassets = previewRedeem(shares);\n\n\t\tbeforeWithdraw(assets, shares);\n\n\t\t_burn(owner, shares);\n\n\t\temit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n\t\tasset.safeTransfer(receiver, assets);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction maxDeposit(address) public view virtual returns (uint256) {\n\t\treturn type(uint256).max;\n\t}\n\n\tfunction maxMint(address) public view virtual returns (uint256) {\n\t\treturn type(uint256).max;\n\t}\n\n\tfunction maxWithdraw(address owner) public view virtual returns (uint256) {\n\t\treturn convertToAssets(balanceOf(owner));\n\t}\n\n\tfunction maxRedeem(address owner) public view virtual returns (uint256) {\n\t\treturn balanceOf(owner);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n\tfunction afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n\n\t// OVERRIDES\n\tfunction totalSupply() public view override(Accounting, ERC20) returns (uint256) {\n\t\treturn ERC20.totalSupply();\n\t}\n\n\terror MinLiquidity();\n}\n"
    },
    "src/interfaces/ERC4626/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\ninterface IERC4626 {\n\tevent Deposit(\n\t\taddress indexed sender,\n\t\taddress indexed owner,\n\t\tuint256 assets,\n\t\tuint256 shares\n\t);\n\n\tevent Withdraw(\n\t\taddress indexed sender,\n\t\taddress indexed receiver,\n\t\taddress indexed owner,\n\t\tuint256 assets,\n\t\tuint256 shares\n\t);\n\n\t/*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n\tfunction mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n\tfunction withdraw(\n\t\tuint256 assets,\n\t\taddress receiver,\n\t\taddress owner\n\t) external returns (uint256 shares);\n\n\tfunction redeem(\n\t\tuint256 shares,\n\t\taddress receiver,\n\t\taddress owner\n\t) external returns (uint256 assets);\n\n\t/*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n\tfunction maxMint(address receiver) external view returns (uint256 maxShares);\n\n\tfunction maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n\tfunction maxRedeem(address owner) external view returns (uint256 maxShares);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "src/vaults/SectorVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC4626, FixedPointMathLib, SafeERC20 } from \"./ERC4626/ERC4626.sol\";\nimport { ISCYStrategy } from \"../interfaces/scy/ISCYStrategy.sol\";\nimport { BatchedWithdraw } from \"./ERC4626/BatchedWithdraw.sol\";\n\nimport \"hardhat/console.sol\";\n\n// TODO native asset deposit + flow\n\nstruct RedeemParams {\n\tISCYStrategy strategy;\n\tuint256 amountSharesToRedeem;\n\tuint256 minTokenOut;\n}\n\nstruct DepositParams {\n\tISCYStrategy strategy;\n\tuint256 amountIn;\n\tuint256 minSharesOut;\n}\n\ncontract SectorVault is ERC4626, BatchedWithdraw {\n\tusing FixedPointMathLib for uint256;\n\tusing SafeERC20 for ERC20;\n\n\tevent Harvest(\n\t\taddress indexed treasury,\n\t\tuint256 underlyingProfit,\n\t\tuint256 underlyingFees,\n\t\tuint256 sharesFees,\n\t\tuint256 strategyTvl\n\t);\n\n\t/// if vaults accepts native asset we set asset to address 0;\n\taddress internal constant NATIVE = address(0);\n\n\tmapping(ISCYStrategy => bool) public strategyExists;\n\taddress[] strategyIndex;\n\tuint256 totalStrategyHoldings;\n\n\tconstructor(\n\t\tERC20 asset_,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\taddress _owner,\n\t\taddress _guardian,\n\t\taddress _manager,\n\t\taddress _treasury,\n\t\tuint256 _perforamanceFee\n\t) ERC4626(asset_, _name, _symbol, _owner, _guardian, _manager, _treasury, _perforamanceFee) {}\n\n\tfunction addStrategy(ISCYStrategy strategy) public onlyOwner {\n\t\tif (strategyExists[strategy]) revert StrategyExists();\n\n\t\t/// make sure underlying matches\n\t\tif (address(strategy.underlying()) != address(asset)) revert WrongUnderlying();\n\n\t\tstrategyExists[strategy] = true;\n\t\tstrategyIndex.push(address(strategy));\n\t}\n\n\tfunction removeStrategy(ISCYStrategy strategy) public onlyOwner {\n\t\tif (!strategyExists[strategy]) revert StrategyNotFound();\n\t\tstrategyExists[strategy] = false;\n\t\tuint256 length = strategyIndex.length;\n\t\t// replace current index with last strategy and pop the index array\n\t\tfor (uint256 i; i <= length; i++) {\n\t\t\tif (address(strategy) == strategyIndex[i]) {\n\t\t\t\tstrategyIndex[i] = strategyIndex[length - 1];\n\t\t\t\tstrategyIndex.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\t/// We compute expected tvl off-chain first, to ensure this transactions isn't sandwitched\n\tfunction harvest(uint256 expectedTvl, uint256 maxDelta) public onlyRole(MANAGER) {\n\t\tuint256 updatedStratHoldings = _getStrategyHoldings();\n\t\tuint256 tvl = updatedStratHoldings + asset.balanceOf(address(this));\n\t\t_checkSlippage(expectedTvl, tvl, maxDelta);\n\n\t\tuint256 profit = updatedStratHoldings > totalStrategyHoldings\n\t\t\t? updatedStratHoldings - totalStrategyHoldings\n\t\t\t: 0;\n\n\t\t// if we suffered losses, update totalStrategyHoldings BEFORE _processWithdraw\n\t\tif (totalStrategyHoldings > updatedStratHoldings)\n\t\t\ttotalStrategyHoldings = updatedStratHoldings;\n\n\t\t// process withdrawals if we have enough balance\n\t\t// withdrawFromStrategies should be called before this\n\t\t// note we are using the totalStrategyHoldings from previous harvest if there is a profit\n\t\t// this prevents harvest front-running and adds a dynamic fee to withdrawals\n\t\tif (pendingWithdrawal != 0 && pendingWithdrawal < asset.balanceOf(address(this)))\n\t\t\t_processWithdraw(convertToShares(1e18));\n\n\t\t// take vault fees\n\t\tif (profit == 0) {\n\t\t\temit Harvest(treasury, 0, 0, 0, tvl);\n\t\t\treturn;\n\t\t}\n\n\t\t// since profit > 0 we have not updated totalStrategyHoldings yet\n\t\ttotalStrategyHoldings = updatedStratHoldings;\n\t\tuint256 underlyingFees = (profit * performanceFee) / 1e18;\n\t\tuint256 feeShares = convertToShares(underlyingFees);\n\n\t\temit Harvest(treasury, profit, underlyingFees, feeShares, tvl);\n\t\t_mint(treasury, feeShares);\n\t}\n\n\t/// this can be done in parts in case gas limit is reached\n\tfunction withdrawFromStrategies(RedeemParams[] calldata params) public onlyRole(MANAGER) {\n\t\tfor (uint256 i; i <= params.length; i++) {\n\t\t\tRedeemParams memory param = params[i];\n\t\t\tISCYStrategy strategy = param.strategy;\n\t\t\t// no need to push share tokens - contract can burn them\n\t\t\tuint256 amountOut = strategy.redeem(\n\t\t\t\taddress(this),\n\t\t\t\tparam.amountSharesToRedeem,\n\t\t\t\taddress(asset), // token out is allways asset\n\t\t\t\tparam.minTokenOut\n\t\t\t);\n\t\t\ttotalStrategyHoldings -= amountOut;\n\t\t}\n\t}\n\n\t/// this can be done in parts in case gas limit is reached\n\tfunction despositIntoStrategies(DepositParams[] calldata params) public onlyRole(MANAGER) {\n\t\tfor (uint256 i; i <= params.length; i++) {\n\t\t\tDepositParams memory param = params[i];\n\t\t\tISCYStrategy strategy = param.strategy;\n\t\t\t/// push funds to avoid approvals\n\t\t\tERC20(asset).safeTransfer(strategy.strategy(), param.amountIn);\n\t\t\tstrategy.deposit(address(this), address(asset), param.amountIn, param.minSharesOut);\n\t\t\ttotalStrategyHoldings += param.amountIn;\n\t\t}\n\t}\n\n\t/// gets accurate strategy holdings denominated in asset\n\tfunction _getStrategyHoldings() internal returns (uint256 tvl) {\n\t\tuint256 lastIndex = strategyIndex.length;\n\t\t/// TODO compute realistic limit for strategy array lengh to stay within gas limit\n\t\tfor (uint256 i; i < lastIndex; i++) {\n\t\t\tISCYStrategy strategy = ISCYStrategy(payable(strategyIndex[i]));\n\t\t\ttvl += strategy.getAndUpdateTvl();\n\t\t}\n\t}\n\n\tfunction _checkSlippage(\n\t\tuint256 expectedValue,\n\t\tuint256 actualValue,\n\t\tuint256 maxDelta\n\t) internal pure {\n\t\tuint256 delta = expectedValue > actualValue\n\t\t\t? expectedValue - actualValue\n\t\t\t: actualValue - expectedValue;\n\t\tif (delta > maxDelta) revert SlippageExceeded();\n\t}\n\n\t/// returns expected tvl (used for estimate)\n\tfunction getTvl() public view returns (uint256 tvl) {\n\t\tuint256 length = strategyIndex.length;\n\t\t// there should be no untrusted strategies in this array\n\t\tfor (uint256 i; i < length; i++) {\n\t\t\tISCYStrategy strategy = ISCYStrategy(payable(strategyIndex[i]));\n\t\t\ttvl += strategy.getTvl();\n\t\t}\n\t\ttvl += asset.balanceOf(address(this));\n\t}\n\n\tfunction totalAssets() public view virtual override returns (uint256) {\n\t\treturn asset.balanceOf(address(this)) + totalStrategyHoldings;\n\t}\n\n\t/// INTERFACE UTILS\n\n\tfunction balanceOfUnderlying(address user) public view returns (uint256) {\n\t\tuint256 shares = balanceOf(user);\n\t\treturn sharesToUnderlying(shares);\n\t}\n\n\t/// @dev current exchange rate (different from previewDeposit rate)\n\t/// this should be used for estiamtes of withdrawals\n\tfunction sharesToUnderlying(uint256 shares) public view returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\t\treturn supply == 0 ? shares : shares.mulDivDown(getTvl(), supply);\n\t}\n\n\t/// @dev current exchange rate (different from previewDeposit / previewWithdrawal rate)\n\t/// this should be used estimate of deposit fee\n\tfunction underlyingToShares(uint256 underlyingAmnt) public view returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\t\treturn supply == 0 ? underlyingAmnt : underlyingAmnt.mulDivDown(supply, getTvl());\n\t}\n\n\tfunction underlyingDecimals() public view returns (uint8) {\n\t\treturn asset.decimals();\n\t}\n\n\tfunction underlying() public view returns (address) {\n\t\treturn address(asset);\n\t}\n\n\t/// OVERRIDES\n\n\tfunction withdraw(\n\t\tuint256 assets,\n\t\taddress receiver,\n\t\taddress owner\n\t) public pure override(ERC4626, BatchedWithdraw) returns (uint256 shares) {\n\t\treturn super.withdraw(assets, receiver, owner);\n\t}\n\n\tfunction redeem(\n\t\tuint256 shares,\n\t\taddress receiver,\n\t\taddress owner\n\t) public virtual override(ERC4626, BatchedWithdraw) returns (uint256 assets) {\n\t\treturn super.redeem(shares, receiver, owner);\n\t}\n\n\terror WrongUnderlying();\n\terror SlippageExceeded();\n\terror StrategyExists();\n\terror StrategyNotFound();\n}\n"
    },
    "src/interfaces/scy/ISCYStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISCYStrategy {\n\tfunction deposit(\n\t\taddress receiver,\n\t\taddress tokenIn,\n\t\tuint256 amountTokenToPull,\n\t\tuint256 minSharesOut\n\t) external payable returns (uint256 amountSharesOut);\n\n\tfunction redeem(\n\t\taddress receiver,\n\t\tuint256 amountSharesToPull,\n\t\taddress tokenOut,\n\t\tuint256 minTokenOut\n\t) external returns (uint256 amountTokenOut);\n\n\tfunction underlying() external view returns (IERC20);\n\n\tfunction strategy() external view returns (address);\n\n\tfunction getAndUpdateTvl() external returns (uint256 tvl);\n\n\tfunction getTvl() external view returns (uint256 tvl);\n}\n"
    },
    "src/vaults/ERC4626/BatchedWithdraw.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC4626 } from \"./ERC4626.sol\";\n\nstruct WithdrawRecord {\n\tuint256 timestamp;\n\tuint256 amount;\n}\n\n/// TODO withdraw time limit? and cancel after?\n/// TODO cancel withdraw?\n\nabstract contract BatchedWithdraw is ERC4626 {\n\tusing SafeERC20 for ERC20;\n\n\tevent RequestWithdraw(address indexed caller, address indexed owner, uint256 shares);\n\n\tuint256 public withdrawTimestamp;\n\tuint256 public withdrawSharePrice; // exchage rate 1e18 shares to underlying\n\tuint256 public pendingWithdrawal;\n\n\tmapping(address => WithdrawRecord) public withdrawLedger;\n\n\tfunction requestRedeem(uint256 shares) public {\n\t\treturn requestRedeem(shares, msg.sender);\n\t}\n\n\tfunction requestRedeem(uint256 shares, address owner) public {\n\t\tif (msg.sender != owner) _spendAllowance(owner, msg.sender, shares);\n\t\t// TODO should we burn shares right away?\n\t\t_transfer(owner, address(this), shares);\n\t\tWithdrawRecord storage withdrawRecord = withdrawLedger[msg.sender];\n\t\twithdrawRecord.timestamp = block.timestamp;\n\t\twithdrawRecord.amount += shares;\n\t\tpendingWithdrawal += shares;\n\t\temit RequestWithdraw(msg.sender, owner, shares);\n\t}\n\n\tfunction withdraw(\n\t\tuint256,\n\t\taddress,\n\t\taddress\n\t) public pure virtual override returns (uint256) {\n\t\trevert NotImplemented();\n\t}\n\n\tfunction redeem(\n\t\tuint256,\n\t\taddress receiver,\n\t\taddress\n\t) public virtual override returns (uint256 amountOut) {\n\t\treturn redeem(receiver);\n\t}\n\n\t/// @dev safest UI method\n\tfunction redeem() public virtual returns (uint256 amountOut) {\n\t\treturn redeem(msg.sender);\n\t}\n\n\tfunction redeem(address receiver) public virtual returns (uint256 amountOut) {\n\t\tWithdrawRecord storage withdrawRecord = withdrawLedger[msg.sender];\n\t\tif (withdrawRecord.amount == 0) revert ZeroAmount();\n\t\tif (withdrawRecord.timestamp > withdrawTimestamp) revert NotReady();\n\t\tamountOut = (withdrawRecord.amount * withdrawSharePrice) / 1e18;\n\t\tuint256 burnShares = withdrawRecord.amount;\n\t\tpendingWithdrawal -= withdrawRecord.amount;\n\t\twithdrawRecord.amount = 0;\n\t\t_burn(address(this), burnShares);\n\t\tERC20(asset).transfer(receiver, amountOut);\n\t\temit Withdraw(msg.sender, receiver, owner, amountOut, burnShares);\n\t}\n\n\t/// @notice enables withdrawal made prior to current timestamp\n\t/// based specified exchange rate\n\tfunction _processWithdraw(uint256 _sharesToUnderlying) internal {\n\t\twithdrawSharePrice = _sharesToUnderlying;\n\t\twithdrawTimestamp = block.timestamp;\n\t}\n\n\t/// UTILS\n\tfunction redeemIsReady(address user) external view returns (bool) {\n\t\tWithdrawRecord storage withdrawRecord = withdrawLedger[user];\n\t\treturn withdrawTimestamp >= withdrawRecord.timestamp;\n\t}\n\n\tfunction getWithdrawStatus(address user) external view returns (WithdrawRecord memory) {\n\t\treturn withdrawLedger[user];\n\t}\n\n\terror NotImplemented();\n\terror NotReady();\n\terror ZeroAmount();\n}\n"
    },
    "src/vaults/IMXLend.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { SCYStrategy, Strategy } from \"./scy/SCYStrategy.sol\";\nimport { IPoolToken, IBorrowable } from \"../interfaces/imx/IImpermax.sol\";\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SCYVault } from \"./scy/SCYVault.sol\";\nimport { SafeETH } from \"./../libraries/SafeETH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract IMXLend is SCYStrategy, SCYVault {\n\tusing SafeERC20 for IERC20;\n\n\tconstructor(\n\t\taddress _owner,\n\t\taddress guardian,\n\t\taddress manager,\n\t\tStrategy memory _strategy\n\t) SCYVault(_owner, guardian, manager, _strategy) {}\n\n\tfunction _stratValidate() internal view override {\n\t\tif (\n\t\t\taddress(underlying) != IPoolToken(strategy).underlying() ||\n\t\t\tyieldToken != address(strategy)\n\t\t) revert InvalidStrategy();\n\t}\n\n\tfunction _stratDeposit(uint256) internal override returns (uint256) {\n\t\treturn IPoolToken(strategy).mint(address(this));\n\t}\n\n\tfunction _stratRedeem(address to, uint256 amount)\n\t\tinternal\n\t\toverride\n\t\treturns (uint256 amountOut, uint256 amntToTransfer)\n\t{\n\t\tIERC20(yieldToken).safeTransfer(strategy, amount);\n\t\tamntToTransfer = 0;\n\t\tamountOut = IPoolToken(strategy).redeem(to);\n\t}\n\n\tfunction _stratGetAndUpdateTvl() internal override returns (uint256) {\n\t\t// exchange rate does the accrual\n\t\tuint256 exchangeRate = IBorrowable(strategy).exchangeRate();\n\t\tuint256 balance = IERC20(strategy).balanceOf(address(this));\n\t\tuint256 underlyingBalance = (balance * exchangeRate) / 1e18;\n\t\treturn underlyingBalance;\n\t}\n\n\tfunction _strategyTvl() internal view override returns (uint256) {\n\t\tuint256 balance = IERC20(strategy).balanceOf(address(this));\n\t\tuint256 exchangeRate = IBorrowable(strategy).exchangeRateLast();\n\t\tuint256 underlyingBalance = (balance * exchangeRate) / 1e18;\n\t\treturn underlyingBalance;\n\t}\n\n\tfunction _stratClosePosition() internal override returns (uint256) {\n\t\tuint256 yeildTokenAmnt = IERC20(strategy).balanceOf(address(this));\n\t\tIERC20(strategy).safeTransfer(strategy, yeildTokenAmnt);\n\t\treturn IPoolToken(strategy).redeem(address(this));\n\t}\n\n\t// TOOD fraction of total deposits\n\tfunction _stratMaxTvl() internal pure override returns (uint256) {\n\t\treturn type(uint256).max;\n\t}\n\n\tfunction _stratCollateralToUnderlying() internal view override returns (uint256) {\n\t\treturn IBorrowable(strategy).exchangeRateLast();\n\t}\n\n\tfunction _getFloatingAmount(address token) internal view override returns (uint256) {\n\t\tif (token == address(underlying))\n\t\t\treturn underlying.balanceOf(strategy) - IPoolToken(strategy).totalBalance();\n\t\treturn _selfBalance(token);\n\t}\n}\n"
    },
    "src/common/FeesU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20Upgradeable as SafeERC20, IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { AuthU } from \"./AuthU.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract FeesU is AuthU {\n\tusing SafeERC20 for IERC20;\n\n\t/// @notice The percentage of profit recognized each harvest to reserve as fees.\n\t/// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\n\tuint256 public feePercent;\n\n\t/// @notice Emitted when the fee percentage is updated.\n\t/// @param user The authorized user who triggered the update.\n\t/// @param newFeePercent The new fee percentage.\n\tevent FeePercentUpdated(address indexed user, uint256 newFeePercent);\n\n\t/// @notice Sets a new fee percentage.\n\t/// @param newFeePercent The new fee percentage.\n\tfunction setFeePercent(uint256 newFeePercent) public onlyOwner {\n\t\t// A fee percentage over 100% doesn't make sense.\n\t\trequire(newFeePercent <= 1e18, \"FEE_TOO_HIGH\");\n\n\t\t// Update the fee percentage.\n\t\tfeePercent = newFeePercent;\n\n\t\temit FeePercentUpdated(msg.sender, newFeePercent);\n\t}\n\n\t/// @notice Emitted after fees are claimed.\n\t/// @param user The authorized user who claimed the fees.\n\t/// @param amount The amount of vault that were claimed.\n\tevent FeesClaimed(address indexed user, uint256 amount);\n\n\t/// @notice Claims fees accrued from harvests.\n\t/// @param amount The amount of vault tokens to claim.\n\t/// @dev Accrued fees are measured as rvTokens held by the Vault.\n\tfunction claimFees(uint256 amount) external onlyRole(\"MANAGER\") {\n\t\temit FeesClaimed(msg.sender, amount);\n\n\t\t// Transfer the provided amount of rvTokens to the caller.\n\t\tIERC20(address(this)).safeTransfer(msg.sender, amount);\n\t}\n\n\tuint256[50] private __gap;\n}\n"
    },
    "src/strategies/mixins/IUniLp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IUniswapV2Pair } from \"../../interfaces/uniswap/IUniswapV2Pair.sol\";\nimport { UniUtils } from \"../../libraries/UniUtils.sol\";\n\nimport { IBase } from \"./IBase.sol\";\nimport { ILp } from \"./ILp.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract IUniLp is IBase, ILp {\n\tusing SafeERC20 for IERC20;\n\tusing UniUtils for IUniswapV2Pair;\n\n\tfunction pair() public view virtual returns (IUniswapV2Pair);\n\n\t// should only be called after oracle or user-input swap price check\n\tfunction _addLiquidity(uint256 amountToken0, uint256 amountToken1)\n\t\tinternal\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256 liquidity)\n\t{\n\t\tunderlying().safeTransfer(address(pair()), amountToken0);\n\t\tshort().safeTransfer(address(pair()), amountToken1);\n\t\tliquidity = pair().mint(address(this));\n\t}\n\n\tfunction _removeLiquidity(uint256 liquidity)\n\t\tinternal\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256, uint256)\n\t{\n\t\tIERC20(address(pair())).safeTransfer(address(pair()), liquidity);\n\t\t(address tokenA, ) = UniUtils._sortTokens(address(underlying()), address(short()));\n\t\t(uint256 amountToken0, uint256 amountToken1) = pair().burn(address(this));\n\t\treturn\n\t\t\ttokenA == address(underlying())\n\t\t\t\t? (amountToken0, amountToken1)\n\t\t\t\t: (amountToken1, amountToken0);\n\t}\n\n\tfunction _quote(\n\t\tuint256 amount,\n\t\taddress token0,\n\t\taddress token1\n\t) internal view virtual override returns (uint256 price) {\n\t\tif (amount == 0) return 0;\n\t\t(uint256 reserve0, uint256 reserve1) = pair()._getPairReserves(token0, token1);\n\t\tprice = UniUtils._quote(amount, reserve0, reserve1);\n\t}\n\n\t// fetches and sorts the reserves for a uniswap pair\n\tfunction getUnderlyingShortReserves() public view returns (uint256 reserveA, uint256 reserveB) {\n\t\t(reserveA, reserveB) = pair()._getPairReserves(address(underlying()), address(short()));\n\t}\n\n\tfunction _getLPBalances()\n\t\tinternal\n\t\tview\n\t\toverride\n\t\treturns (uint256 underlyingBalance, uint256 shortBalance)\n\t{\n\t\tuint256 totalLp = _getLiquidity();\n\t\t(uint256 totalUnderlyingBalance, uint256 totalShortBalance) = getUnderlyingShortReserves();\n\t\tuint256 total = pair().totalSupply();\n\t\tunderlyingBalance = (totalUnderlyingBalance * totalLp) / total;\n\t\tshortBalance = (totalShortBalance * totalLp) / total;\n\t}\n}\n"
    },
    "src/strategies/mixins/IBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { HarvestSwapParms } from \"../../interfaces/Structs.sol\";\n\n// all interfaces need to inherit from base\nabstract contract IBase {\n\tbool public isInitialized;\n\n\tmodifier initializer() {\n\t\trequire(isInitialized == false, \"INITIALIZED\");\n\t\t_;\n\t}\n\n\tfunction short() public view virtual returns (IERC20);\n\n\tfunction underlying() public view virtual returns (IERC20);\n}\n"
    },
    "src/strategies/mixins/IUniFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IBase, HarvestSwapParms } from \"./IBase.sol\";\nimport { IUniLp, SafeERC20, IERC20 } from \"./IUniLp.sol\";\nimport { IFarmable, IUniswapV2Router01 } from \"./IFarmable.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract IUniFarm is IBase, IUniLp, IFarmable {\n\tfunction _depositIntoFarm(uint256 amount) internal virtual;\n\n\tfunction _withdrawFromFarm(uint256 amount) internal virtual;\n\n\tfunction _harvestFarm(HarvestSwapParms[] calldata swapParams)\n\t\tinternal\n\t\tvirtual\n\t\treturns (uint256[] memory);\n\n\tfunction _getFarmLp() internal view virtual returns (uint256);\n\n\tfunction _addFarmApprovals() internal virtual;\n\n\tfunction farmRouter() public view virtual returns (IUniswapV2Router01);\n}\n"
    },
    "src/strategies/mixins/IFarmable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IUniswapV2Router01 } from \"../../interfaces/uniswap/IUniswapV2Router01.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { HarvestSwapParms, IBase } from \"./IBase.sol\";\n\nabstract contract IFarmable is IBase {\n\tusing SafeERC20 for IERC20;\n\n\tevent HarvestedToken(address indexed token, uint256 amount);\n\n\tfunction _swap(\n\t\tIUniswapV2Router01 router,\n\t\tHarvestSwapParms calldata swapParams,\n\t\taddress from,\n\t\tuint256 amount\n\t) internal {\n\t\taddress out = swapParams.path[swapParams.path.length - 1];\n\t\t// ensure malicious harvester is not trading with wrong tokens\n\t\t// TODO should we add more validation to prevent malicious path?\n\t\trequire(\n\t\t\t((swapParams.path[0] == address(from) && (out == address(short()))) ||\n\t\t\t\tout == address(underlying())),\n\t\t\t\"IFarmable: WRONG_PATH\"\n\t\t);\n\t\trouter.swapExactTokensForTokens(\n\t\t\tamount,\n\t\t\tswapParams.min,\n\t\t\tswapParams.path, // optimal route determined externally\n\t\t\taddress(this),\n\t\t\tswapParams.deadline\n\t\t);\n\t}\n}\n"
    },
    "src/interfaces/imx/IVaultToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport { IUniswapV2Router01 } from \"../uniswap/IUniswapV2Router01.sol\";\n\ninterface IVaultToken {\n\t/*** Tarot ERC20 ***/\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\tfunction name() external pure returns (string memory);\n\n\tfunction symbol() external pure returns (string memory);\n\n\tfunction decimals() external pure returns (uint8);\n\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction balanceOf(address owner) external view returns (uint256);\n\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\tfunction approve(address spender, uint256 value) external returns (bool);\n\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) external returns (bool);\n\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\n\tfunction nonces(address owner) external view returns (uint256);\n\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\t/*** Pool Token ***/\n\n\tevent Mint(\n\t\taddress indexed sender,\n\t\taddress indexed minter,\n\t\tuint256 mintAmount,\n\t\tuint256 mintTokens\n\t);\n\tevent Redeem(\n\t\taddress indexed sender,\n\t\taddress indexed redeemer,\n\t\tuint256 redeemAmount,\n\t\tuint256 redeemTokens\n\t);\n\tevent Sync(uint256 totalBalance);\n\n\tfunction underlying() external view returns (address);\n\n\tfunction factory() external view returns (address);\n\n\tfunction totalBalance() external view returns (uint256);\n\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n\tfunction exchangeRate() external view returns (uint256);\n\n\tfunction mint(address minter) external returns (uint256 mintTokens);\n\n\tfunction redeem(address redeemer) external returns (uint256 redeemAmount);\n\n\tfunction skim(address to) external;\n\n\tfunction sync() external;\n\n\tfunction _setFactory() external;\n\n\t/*** VaultToken ***/\n\n\tevent Reinvest(address indexed caller, uint256 reward, uint256 bounty);\n\n\tfunction isVaultToken() external pure returns (bool);\n\n\tfunction router() external view returns (IUniswapV2Router01);\n\n\t// function masterChef() external view returns (IMasterChef);\n\n\tfunction rewardsToken() external view returns (address);\n\n\tfunction WETH() external view returns (address);\n\n\tfunction token0() external view returns (address);\n\n\tfunction token1() external view returns (address);\n\n\tfunction swapFeeFactor() external view returns (uint256);\n\n\tfunction pid() external view returns (uint256);\n\n\tfunction REINVEST_BOUNTY() external pure returns (uint256);\n\n\tfunction getReserves()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint112 reserve0,\n\t\t\tuint112 reserve1,\n\t\t\tuint32 blockTimestampLast\n\t\t);\n\n\tfunction price0CumulativeLast() external view returns (uint256);\n\n\tfunction price1CumulativeLast() external view returns (uint256);\n\n\tfunction reinvest() external;\n}\n"
    },
    "src/vaults/IMXVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { SCYStrategy, Strategy } from \"./scy/SCYStrategy.sol\";\nimport { IMX } from \"../strategies/imx/IMX.sol\";\nimport { SCYVault, IERC20 } from \"./scy/SCYVault.sol\";\n\ncontract IMXVault is SCYStrategy, SCYVault {\n\tconstructor(\n\t\taddress _owner,\n\t\taddress guardian,\n\t\taddress manager,\n\t\tStrategy memory _strategy\n\t) SCYVault(_owner, guardian, manager, _strategy) {}\n\n\tfunction _stratValidate() internal view override {\n\t\tif (\n\t\t\taddress(underlying) != address(IMX(strategy).underlying()) ||\n\t\t\tyieldToken != address(IMX(strategy).collateralToken())\n\t\t) revert InvalidStrategy();\n\t}\n\n\tfunction _stratDeposit(uint256 amount) internal override returns (uint256) {\n\t\treturn IMX(strategy).deposit(amount);\n\t}\n\n\tfunction _stratRedeem(address recipient, uint256 yeildTokenAmnt)\n\t\tinternal\n\t\toverride\n\t\treturns (uint256 amountOut, uint256 amntToTransfer)\n\t{\n\t\t// strategy doesn't transfer tokens to user\n\t\t// TODO it should?\n\t\tamountOut = IMX(strategy).redeem(yeildTokenAmnt, recipient);\n\t\tamntToTransfer = 0;\n\t}\n\n\tfunction _stratGetAndUpdateTvl() internal override returns (uint256) {\n\t\treturn IMX(strategy).getAndUpdateTVL();\n\t}\n\n\tfunction _strategyTvl() internal view override returns (uint256) {\n\t\treturn IMX(strategy).getTotalTVL();\n\t}\n\n\tfunction _stratClosePosition() internal override returns (uint256) {\n\t\treturn IMX(strategy).closePosition();\n\t}\n\n\tfunction _stratMaxTvl() internal view override returns (uint256) {\n\t\treturn IMX(strategy).getMaxTvl();\n\t}\n\n\tfunction _stratCollateralToUnderlying() internal view override returns (uint256) {\n\t\treturn IMX(strategy).collateralToUnderlying();\n\t}\n\n\tfunction _selfBalance(address token) internal view virtual override returns (uint256) {\n\t\tif (token == yieldToken) return IERC20(token).balanceOf(strategy);\n\t\treturn (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n\t}\n}\n"
    },
    "src/vaults/SectorCrossVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { BatchedWithdraw } from \"./ERC4626/BatchedWithdraw.sol\";\nimport { ERC4626 } from \"./ERC4626/ERC4626.sol\";\nimport { IXAdapter } from \"../interfaces/adapters/IXAdapter.sol\";\nimport { SocketIntegrator } from \"../common/SocketIntegrator.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract SectorCrossVault is BatchedWithdraw, SocketIntegrator {\n\tenum msgType {\n\t\tNONE,\n\t\tDEPOSIT,\n\t\tREDEEM,\n\t\tREQUESTREDEEM,\n\t\tREQUESTVALUEOFSHARES,\n\t\tEMERGENCYWITHDRAW\n\t}\n\n\tstruct Vault {\n\t\tuint16 chainId;\n\t\taddress adapter;\n\t\tbool allowed;\n\t}\n\n\tstruct Request {\n\t\tuint256 timestamp;\n\t\tuint256 chainId;\n\t\taddress vault;\n\t}\n\n\tstruct HarvestLedger {\n\t\tuint256 depositValue;\n\t\tbool isOpen;\n\t\tuint256 openIndex;\n\t\tRequest[] request;\n\t}\n\n\t// TODO Implement functions with harvestLock modifier\n\n\t// Controls deposits\n\tmapping(address => Vault) public depositedVaults;\n\n\t// Keep track of depositedVaults\n\t// TODO Has to implement push to this array\n\taddress[] internal vaultsArr;\n\n\t// Harvest state\n\tHarvestLedger public harvestLedger;\n\t// Controls emergency withdraw\n\tbool internal emergencyEnabled = false;\n\n\tconstructor(\n\t\tERC20 _asset,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\taddress _owner,\n\t\taddress _guardian,\n\t\taddress _manager,\n\t\taddress _treasury,\n\t\tuint256 _perforamanceFee\n\t) ERC4626(_asset, _name, _symbol, _owner, _guardian, _manager, _treasury, _perforamanceFee) {\n\t\t// Not sure if needed\n\t\t// TODO check if needed\n\t\tharvestLedger.openIndex = 0;\n\t\tharvestLedger.isOpen = false;\n\t\tharvestLedger.depositValue = 0;\n\t}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\tCross Vault Interface\n\t/////////////////////////////////////////////////////*/\n\n\tfunction depositIntoVaults(address[] calldata vaults, uint256[] calldata amounts)\n\t\tpublic\n\t\tonlyRole(MANAGER)\n\t\tcheckInputSize(vaults.length, amounts.length)\n\t{\n\t\tfor (uint256 i = 0; i < vaults.length; ) {\n\t\t\tVault memory tmpVault = depositedVaults[vaults[i]];\n\n\t\t\tif (!tmpVault.allowed) revert VaultNotAllowed(vaults[i]);\n\n\t\t\tif (tmpVault.adapter == address(0)) {\n\t\t\t\tBatchedWithdraw(vaults[i]).deposit(amounts[i], address(this));\n\t\t\t} else {\n\t\t\t\tIXAdapter(tmpVault.adapter).sendMessage(\n\t\t\t\t\tamounts[i],\n\t\t\t\t\tvaults[i],\n\t\t\t\t\taddress(this),\n\t\t\t\t\ttmpVault.chainId,\n\t\t\t\t\tuint16(msgType.DEPOSIT),\n\t\t\t\t\tuint16(block.chainid)\n\t\t\t\t);\n\n\t\t\t\temit BridgeAsset(uint16(block.chainid), tmpVault.chainId, amounts[i]);\n\t\t\t}\n\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction requestRedeemFromVaults(address[] calldata vaults, uint256[] calldata shares)\n\t\tpublic\n\t\tonlyRole(MANAGER)\n\t\tcheckInputSize(vaults.length, shares.length)\n\t{\n\t\tfor (uint256 i = 0; i < vaults.length; ) {\n\t\t\tVault memory tmpVault = depositedVaults[vaults[i]];\n\n\t\t\tif (!tmpVault.allowed) revert VaultNotAllowed(vaults[i]);\n\n\t\t\tif (tmpVault.adapter == address(0)) {\n\t\t\t\tBatchedWithdraw(vaults[i]).requestRedeem(shares[i]);\n\t\t\t} else {\n\t\t\t\tIXAdapter(tmpVault.adapter).sendMessage(\n\t\t\t\t\tshares[i],\n\t\t\t\t\tvaults[i],\n\t\t\t\t\taddress(this),\n\t\t\t\t\ttmpVault.chainId,\n\t\t\t\t\tuint16(msgType.REQUESTREDEEM),\n\t\t\t\t\tuint16(block.chainid)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction redeemFromVaults(address[] calldata vaults, uint256[] calldata shares)\n\t\tpublic\n\t\tonlyRole(MANAGER)\n\t\tcheckInputSize(vaults.length, shares.length)\n\t{\n\t\tfor (uint256 i = 0; i < vaults.length; ) {\n\t\t\tVault memory tmpVault = depositedVaults[vaults[i]];\n\n\t\t\tif (tmpVault.allowed) revert VaultNotAllowed(vaults[i]);\n\n\t\t\tif (tmpVault.adapter == address(0)) {\n\t\t\t\tBatchedWithdraw(vaults[i]).redeem(shares[i], address(this), address(this));\n\t\t\t} else {\n\t\t\t\tIXAdapter(tmpVault.adapter).sendMessage(\n\t\t\t\t\tshares[i],\n\t\t\t\t\tvaults[i],\n\t\t\t\t\taddress(this),\n\t\t\t\t\ttmpVault.chainId,\n\t\t\t\t\tuint16(msgType.REDEEM),\n\t\t\t\t\tuint16(block.chainid)\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Not sure if it should request manager intervention after redeem when in different chains\n\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Not sure if caller has to pass array of vaults\n\t// Can be dangerous if manager fails or forgets an address\n\t// TODO asks loaner\n\tfunction harvestVaults(address[] calldata vaults) public onlyRole(MANAGER) {\n\t\tuint256 depositValue = 0;\n\n\t\tif (harvestLedger.isOpen) revert OnGoingHarvest();\n\n\t\tfor (uint256 i = 0; i < vaults.length; ) {\n\t\t\tVault memory tmpVault = depositedVaults[vaults[i]];\n\n\t\t\tif (tmpVault.adapter == address(0)) {\n\t\t\t\tdepositValue +=\n\t\t\t\t\tBatchedWithdraw(vaults[i]).balanceOf(address(this)) *\n\t\t\t\t\tBatchedWithdraw(vaults[i]).withdrawSharePrice();\n\t\t\t} else {\n\t\t\t\tIXAdapter(tmpVault.adapter).sendMessage(\n\t\t\t\t\t0,\n\t\t\t\t\tvaults[i],\n\t\t\t\t\taddress(this),\n\t\t\t\t\ttmpVault.chainId,\n\t\t\t\t\tuint16(msgType.REQUESTVALUEOFSHARES),\n\t\t\t\t\tuint16(block.chainid)\n\t\t\t\t);\n\n\t\t\t\tharvestLedger.request.push(Request(block.timestamp, tmpVault.chainId, vaults[i]));\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tharvestLedger.depositValue = depositValue;\n\t\tharvestLedger.isOpen = true;\n\t}\n\n\tfunction finalizeHarvest(uint256 expectedValue, uint256 maxDelta) public onlyRole(MANAGER) {\n\t\tHarvestLedger memory hLedger = harvestLedger;\n\n\t\t// Compute actual tvl\n\t\tuint256 actualValue = 0;\n\n\t\tif (!hLedger.isOpen) revert HarvestNotOpen();\n\n\t\t// Get all values from message board\n\t\tuint256 i = hLedger.openIndex;\n\t\twhile (i < hLedger.request.length) {\n\t\t\tVault memory tmpVault = depositedVaults[hLedger.request[i].vault];\n\n\t\t\t// If timestamp > message.timestamp transaction will revert\n\t\t\tuint256 value = IXAdapter(tmpVault.adapter).readMessage(\n\t\t\t\thLedger.request[i].vault,\n\t\t\t\ttmpVault.chainId,\n\t\t\t\thLedger.request[i].timestamp\n\t\t\t);\n\t\t\tactualValue += value;\n\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t// Check if tvl is expected before commiting\n\t\tuint256 delta = expectedValue > actualValue\n\t\t\t? expectedValue - actualValue\n\t\t\t: actualValue - expectedValue;\n\t\tif (delta > maxDelta) revert SlippageExceeded();\n\n\t\t// Commit values\n\t\twithdrawSharePrice = (hLedger.depositValue + actualValue) / totalSupply();\n\n\t\t// Change harvest status\n\t\tharvestLedger.openIndex = i;\n\t\tharvestLedger.depositValue = 0;\n\t\tharvestLedger.isOpen = false;\n\t}\n\n\t// TODO Implement calculations with point fix library\n\tfunction emergencyWithdraw() external {\n\t\tif (!emergencyEnabled) revert EmergencyNotEnabled();\n\n\t\tuint256 userShares = balanceOf(msg.sender);\n\n\t\t_burn(msg.sender, userShares);\n\t\tuint256 userPerc = userShares / totalSupply();\n\n\t\tfor (uint256 i = 0; i < vaultsArr.length; ) {\n\t\t\tVault memory tmpVault = depositedVaults[vaultsArr[i]];\n\t\t\tBatchedWithdraw vault = BatchedWithdraw(vaultsArr[i]);\n\n\t\t\tuint256 transferShares = vault.balanceOf(address(this)) * userPerc;\n\n\t\t\tif (tmpVault.adapter == address(0)) {\n\t\t\t\tvault.transfer(msg.sender, transferShares);\n\t\t\t} else {\n\t\t\t\tIXAdapter(tmpVault.adapter).sendMessage(\n\t\t\t\t\ttransferShares,\n\t\t\t\t\tvaultsArr[i],\n\t\t\t\t\taddress(this),\n\t\t\t\t\ttmpVault.chainId,\n\t\t\t\t\tuint16(msgType.EMERGENCYWITHDRAW),\n\t\t\t\t\tuint16(block.chainid)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\tVault Management\n\t/////////////////////////////////////////////////////*/\n\n\t// Add to array of addresses\n\tfunction addVault(\n\t\taddress vault,\n\t\tuint16 chainId,\n\t\taddress adapter,\n\t\tbool allowed\n\t) external onlyOwner {\n\t\tVault memory tmpVault = depositedVaults[vault];\n\n\t\tif (tmpVault.chainId != 0 || tmpVault.adapter != address(0) || tmpVault.allowed != false)\n\t\t\trevert VaultAlreadyAdded();\n\n\t\tdepositedVaults[vault] = Vault(chainId, adapter, allowed);\n\t\temit AddVault(vault, chainId, adapter);\n\t}\n\n\tfunction updateVaultAdapter(address vault, address adapter) external onlyOwner {\n\t\tdepositedVaults[vault].adapter = adapter;\n\n\t\temit UpdateVaultAdapter(vault, adapter);\n\t}\n\n\tfunction changeVaultStatus(address vault, bool allowed) external onlyOwner {\n\t\tdepositedVaults[vault].allowed = allowed;\n\n\t\temit ChangeVaultStatus(vault, allowed);\n\t}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\t\tModifiers\n\t/////////////////////////////////////////////////////*/\n\n\tmodifier checkInputSize(uint256 size0, uint256 size1) {\n\t\tif (size0 != size1) revert InputSizeNotAppropriate();\n\t\t_;\n\t}\n\n\tmodifier harvestLock() {\n\t\tif (harvestLedger.isOpen) revert OnGoingHarvest();\n\t\t_;\n\t}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\t\tEvents\n\t/////////////////////////////////////////////////////*/\n\n\tevent AddVault(address vault, uint16 chainId, address adapter);\n\tevent UpdateVaultAdapter(address vault, address adapter);\n\tevent ChangeVaultStatus(address vault, bool status);\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\t\tErrors\n\t/////////////////////////////////////////////////////*/\n\n\terror InputSizeNotAppropriate();\n\terror HarvestNotOpen();\n\t// error InsufficientReturnOut();\n\terror VaultNotAllowed(address vault);\n\terror VaultAlreadyAdded();\n\terror SlippageExceeded();\n\terror OnGoingHarvest();\n\terror EmergencyNotEnabled();\n}\n"
    },
    "src/interfaces/adapters/IXAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\ninterface IXAdapter {\n\tfunction sendMessage(\n\t\tuint256 amount,\n\t\taddress dstVautAddress,\n\t\taddress srcVaultAddress,\n\t\tuint256 destChainId,\n\t\tuint16 messageType,\n\t\tuint256 srcChainId\n\t) external;\n\n\tfunction readMessage(\n\t\taddress senderVautAddress,\n\t\tuint256 senderChainId,\n\t\tuint256 timestamp\n\t) external returns (uint256);\n}\n"
    },
    "src/common/SocketIntegrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { Auth } from \"./Auth.sol\";\n\nabstract contract SocketIntegrator is Auth {\n\t/// @notice Struct encoded in Bungee calldata\n\t/// @dev Derived from socket registry contract\n\tstruct MiddlewareRequest {\n\t\tuint256 id;\n\t\tuint256 optionalNativeAmount;\n\t\taddress inputToken;\n\t\tbytes data;\n\t}\n\n\t/// @notice Struct encoded in Bungee calldata\n\t/// @dev Derived from socket registry contract\n\tstruct BridgeRequest {\n\t\tuint256 id;\n\t\tuint256 optionalNativeAmount;\n\t\taddress inputToken;\n\t\tbytes data;\n\t}\n\n\t/// @notice Struct encoded in Bungee calldata\n\t/// @dev Derived from socket registry contract\n\tstruct UserRequest {\n\t\taddress receiverAddress;\n\t\tuint256 toChainId;\n\t\tuint256 amount;\n\t\tMiddlewareRequest middlewareRequest;\n\t\tBridgeRequest bridgeRequest;\n\t}\n\n\t/// @notice Decode the socket request calldata\n\t/// @dev Currently not in use due to undertainity in bungee api response\n\t/// @param _data Bungee txn calldata\n\t/// @return userRequest parsed calldata\n\tfunction decodeSocketRegistryCalldata(bytes memory _data)\n\t\tinternal\n\t\tpure\n\t\treturns (UserRequest memory userRequest)\n\t{\n\t\tbytes memory callDataWithoutSelector = slice(_data, 4, _data.length - 4);\n\t\t(userRequest) = abi.decode(callDataWithoutSelector, (UserRequest));\n\t}\n\n\t/// @notice Decodes and verifies socket calldata\n\t/// @param _data Bungee txn calldata\n\t/// @param _chainId chainId to check in bungee calldata\n\t/// @param _inputToken inputWantToken to check in bungee calldata\n\t/// @param _receiverAddress receiving address to check in bungee calldata\n\tfunction verifySocketCalldata(\n\t\tbytes memory _data,\n\t\tuint256 _chainId,\n\t\taddress _inputToken,\n\t\taddress _receiverAddress\n\t) internal pure {\n\t\tUserRequest memory userRequest;\n\t\t(userRequest) = decodeSocketRegistryCalldata(_data);\n\n\t\tif (userRequest.toChainId != _chainId) {\n\t\t\trevert(\"Invalid chainId\");\n\t\t}\n\t\tif (userRequest.receiverAddress != _receiverAddress) {\n\t\t\trevert(\"Invalid receiver address\");\n\t\t}\n\t\tif (userRequest.bridgeRequest.inputToken != _inputToken) {\n\t\t\trevert(\"Invalid input token\");\n\t\t}\n\t}\n\n\t// This one has to integrate with layerZero message sender\n\tfunction startBridgeRoute(\n\t\tuint32 _fromChainId,\n\t\tuint32 _toChainId,\n\t\tuint256 amount\n\t) public onlyRole(MANAGER) {\n\t\temit BridgeAsset(_fromChainId, _toChainId, amount);\n\t}\n\n\t// This function will change to depositCrossChain\n\t/// @notice Sends tokens using Bungee middleware. Assumes tokens already present in contract. Manages allowance and transfer.\n\t/// @dev Currently not verifying the middleware request calldata. Use very carefully\n\t/// @param allowanceTarget address to allow tokens to swipe\n\t/// @param socketRegistry address to send bridge txn to\n\t/// @param destinationAddress address of receiver\n\t/// @param amount amount of tokens to bridge\n\t/// @param destinationChainId chain Id of receiving chain\n\t/// @param data calldata of txn to be sent\n\tfunction sendTokens(\n\t\taddress asset,\n\t\taddress allowanceTarget,\n\t\taddress socketRegistry,\n\t\taddress destinationAddress,\n\t\tuint256 amount,\n\t\tuint256 destinationChainId,\n\t\tbytes calldata data\n\t) public onlyRole(MANAGER) {\n\t\tverifySocketCalldata(data, destinationChainId, asset, destinationAddress);\n\n\t\tERC20(asset).approve(msg.sender, amount);\n\t\tERC20(asset).approve(allowanceTarget, amount);\n\t\t(bool success, ) = socketRegistry.call(data);\n\n\t\tif (!success) revert BridgeError();\n\t}\n\n\t/*\n\t * @notice Helper to slice memory bytes\n\t * @author Gonalo S <goncalo.sa@consensys.net>\n\t *\n\t * @dev refer https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n\t */\n\tfunction slice(\n\t\tbytes memory _bytes,\n\t\tuint256 _start,\n\t\tuint256 _length\n\t) internal pure returns (bytes memory) {\n\t\trequire(_length + 31 >= _length, \"slice_overflow\");\n\t\trequire(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n\t\tbytes memory tempBytes;\n\n\t\tassembly {\n\t\t\tswitch iszero(_length)\n\t\t\tcase 0 {\n\t\t\t\t// Get a location of some free memory and store it in tempBytes as\n\t\t\t\t// Solidity does for memory variables.\n\t\t\t\ttempBytes := mload(0x40)\n\n\t\t\t\t// The first word of the slice result is potentially a partial\n\t\t\t\t// word read from the original array. To read it, we calculate\n\t\t\t\t// the length of that partial word and start copying that many\n\t\t\t\t// bytes into the array. The first word we copy will start with\n\t\t\t\t// data we don't care about, but the last `lengthmod` bytes will\n\t\t\t\t// land at the beginning of the contents of the new array. When\n\t\t\t\t// we're done copying, we overwrite the full first word with\n\t\t\t\t// the actual length of the slice.\n\t\t\t\tlet lengthmod := and(_length, 31)\n\n\t\t\t\t// The multiplication in the next line is necessary\n\t\t\t\t// because when slicing multiples of 32 bytes (lengthmod == 0)\n\t\t\t\t// the following copy loop was copying the origin's length\n\t\t\t\t// and then ending prematurely not copying everything it should.\n\t\t\t\tlet mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\t\t\t\tlet end := add(mc, _length)\n\n\t\t\t\tfor {\n\t\t\t\t\t// The multiplication in the next line has the same exact purpose\n\t\t\t\t\t// as the one above.\n\t\t\t\t\tlet cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\t\t\t\t} lt(mc, end) {\n\t\t\t\t\tmc := add(mc, 0x20)\n\t\t\t\t\tcc := add(cc, 0x20)\n\t\t\t\t} {\n\t\t\t\t\tmstore(mc, mload(cc))\n\t\t\t\t}\n\n\t\t\t\tmstore(tempBytes, _length)\n\n\t\t\t\t//update free-memory pointer\n\t\t\t\t//allocating the array padded to 32 bytes like the compiler does now\n\t\t\t\tmstore(0x40, and(add(mc, 31), not(31)))\n\t\t\t}\n\t\t\t//if we want a zero-length slice let's just return a zero-length array\n\t\t\tdefault {\n\t\t\t\ttempBytes := mload(0x40)\n\t\t\t\t//zero out the 32 bytes slice we are about to return\n\t\t\t\t//we need to do it because Solidity does not garbage collect\n\t\t\t\tmstore(tempBytes, 0)\n\n\t\t\t\tmstore(0x40, add(tempBytes, 0x20))\n\t\t\t}\n\t\t}\n\n\t\treturn tempBytes;\n\t}\n\n\tevent BridgeAsset(uint32 _fromChainId, uint32 _toChainId, uint256 amount);\n\terror BridgeError();\n}\n"
    },
    "src/bank/Bank.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { ERC1155Supply, ERC1155, IERC165 } from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\";\nimport { Auth, AccessControl } from \"../common/Auth.sol\";\nimport { IBank, Pool } from \"./IBank.sol\";\n\n// import \"hardhat/console.sol\";\n\n// TODO: should fees be computed in the bank or in vaults?\n// we can simplify this contract if so\ncontract Bank is IBank, ERC1155Supply, Auth {\n\t/// ERRORS\n\terror PoolNotFound();\n\terror PoolExists();\n\n\tuint256 constant BASIS_POINTS = 10000;\n\tuint256 internal constant ONE = 1e18;\n\tuint256 public constant MIN_LIQUIDITY = 10**3;\n\n\t/// List of pools\n\tmapping(uint256 => Pool) public pools;\n\n\taddress public treasury;\n\n\tconstructor(\n\t\tstring memory uri, // ex: https://game.example/api/item/{id}.json\n\t\taddress owner,\n\t\taddress guardian,\n\t\taddress manager,\n\t\taddress _treasury\n\t) ERC1155(uri) Auth(owner, guardian, manager) {\n\t\ttreasury = _treasury;\n\t\temit SetTreasury(_treasury);\n\t}\n\n\t///\n\t/// @param id          id of vault's pool\n\t/// @param account     owner of the shares\n\t/// @param poolTokens  amount of pool tokens deposited\n\t/// @param totalTokens balance of pool tokens in the vault\n\t///\n\t/// @return shares amount of shares minted\n\tfunction deposit(\n\t\tuint96 id,\n\t\taddress account,\n\t\tuint256 poolTokens,\n\t\tuint256 totalTokens\n\t) external override returns (uint256 shares) {\n\t\tuint256 tokenId = getTokenId(msg.sender, id);\n\t\tif (!pools[tokenId].exists) revert PoolNotFound();\n\t\tshares = _assetToShares(tokenId, poolTokens, totalTokens);\n\t\t/// Mint the shares to the owner\n\t\t_mint(account, tokenId, shares, \"\");\n\t\temit Deposit(id, msg.sender, account, shares);\n\t}\n\n\t///\n\t/// @param id          id of vault's pool\n\t/// @param shares  amount of pool tokens deposited\n\t/// @param recipient recipient\n\t///\n\tfunction mint(\n\t\tuint96 id,\n\t\taddress recipient,\n\t\tuint256 shares\n\t) public {\n\t\tuint256 tokenId = getTokenId(msg.sender, id);\n\t\tif (!pools[tokenId].exists) revert PoolNotFound();\n\t\t_mint(recipient, tokenId, shares, \"\");\n\t\temit Deposit(id, msg.sender, recipient, shares);\n\t}\n\n\t/// @dev should only be called by vault\n\t///\n\t/// @param id          id of vault's pool\n\t/// @param poolTokens  amount of pool tokens deposited\n\t/// @param totalTokens balance of pool tokens in the vault\n\t///\n\t/// @return shares amount of shares minted\n\tfunction assetToShares(\n\t\tuint96 id,\n\t\tuint256 poolTokens,\n\t\tuint256 totalTokens\n\t) public view returns (uint256 shares) {\n\t\tuint256 tokenId = getTokenId(msg.sender, id);\n\t\tshares = _assetToShares(tokenId, poolTokens, totalTokens);\n\t}\n\n\t///\n\t/// @param tokenId     id token\n\t/// @param poolTokens  amount of pool tokens deposited\n\t/// @param totalTokens balance of pool tokens in the vault\n\t///\n\t/// @return shares amount of shares minted\n\tfunction _assetToShares(\n\t\tuint256 tokenId,\n\t\tuint256 poolTokens,\n\t\tuint256 totalTokens\n\t) internal view returns (uint256 shares) {\n\t\t/// Get the current total amount of shares of the pool\n\t\tuint256 _totalSupply = totalSupply(tokenId);\n\n\t\tif (_totalSupply == 0) {\n\t\t\t// MIN_LIQUIDITY amount gets locked on first deposit\n\t\t\tshares = poolTokens - MIN_LIQUIDITY;\n\t\t} else {\n\t\t\t/// When converting between pool tokens and shares, we always maintain this formula:\n\t\t\t/// (shares / totalShares) = (poolTokens / totalTokens)\n\t\t\t///\n\t\t\t/// When depositing pool tokens and minting shares, this formula can be rearranged to:\n\t\t\t/// shares = (totalShares * poolTokens) / totalTokens\n\t\t\t///\n\t\t\t/// Since the pool tokens have already been deposited before we mint the shares,\n\t\t\t/// we subtract these tokens from the total. This gives us the total before depositing:\n\t\t\t/// shares = (totalShares * poolTokens) / (totalTokens - poolTokens)\n\t\t\tshares = (_totalSupply * poolTokens) / (totalTokens - poolTokens);\n\t\t}\n\t}\n\n\t///\n\t/// @param id          id of vault's pool\n\t/// @param account     owner of the shares\n\t/// @param shares      amount of shares to burn\n\t/// @param totalTokens balance of pool tokens in the vault\n\t///\n\t/// @return poolTokens amount of pool tokens to withdraw\n\tfunction withdraw(\n\t\tuint96 id,\n\t\taddress account,\n\t\tuint256 shares,\n\t\tuint256 totalTokens\n\t) external override returns (uint256 poolTokens) {\n\t\tuint256 tokenId = getTokenId(msg.sender, id);\n\t\tif (!pools[tokenId].exists) revert PoolNotFound();\n\n\t\tuint256 _totalSupply = totalSupply(tokenId);\n\n\t\t/// Burn the shares from the owner\n\t\t_burn(account, tokenId, shares);\n\n\t\t/// Calculate the amount of pool tokens to withdraw --\n\t\t///\n\t\t/// When converting between pool tokens and shares, we always maintain this formula:\n\t\t/// (shares / totalShares) = (poolTokens / totalTokens)\n\t\t///\n\t\t/// When withdrawing pool tokens and burning shares, this formula can be rearranged to:\n\t\t/// poolTokens = (totalTokens * shares) / totalShares\n\t\t///\n\t\t/// Since the shares have already been burned before\n\t\t/// we withdraw use totalSupply before burn\n\t\tpoolTokens = (totalTokens * shares) / _totalSupply;\n\t\temit Withdraw(id, msg.sender, account, shares);\n\n\t\treturn poolTokens;\n\t}\n\n\t///\n\t/// @param id      id of vault's asset\n\t/// @param shares  amount of pool tokens deposited\n\t/// @param account user account\n\t///\n\tfunction burn(\n\t\tuint96 id,\n\t\tuint256 shares,\n\t\taddress account\n\t) public {\n\t\tuint256 tokenId = getTokenId(msg.sender, id);\n\t\tif (!pools[tokenId].exists) revert PoolNotFound();\n\t\t_burn(account, tokenId, shares);\n\t\temit Withdraw(id, msg.sender, account, shares);\n\t}\n\n\t///\n\t/// @param id          vault pool id\n\t/// @param poolTokens  amount of pool tokens compounded\n\t/// @param totalTokens balance of pool tokens in the vault\n\t/// @param recipient  of fees\n\t///\n\t/// @return shares amount of shares minted\n\tfunction takeFees(\n\t\tuint96 id,\n\t\taddress recipient,\n\t\tuint256 poolTokens,\n\t\tuint256 totalTokens\n\t) external override returns (uint256 shares) {\n\t\tuint256 tokenId = getTokenId(msg.sender, id);\n\n\t\tPool storage pool = pools[tokenId];\n\t\tif (!pool.exists) revert PoolNotFound();\n\n\t\t/// Check if there is a management fee\n\t\tif (pool.managementFee == 0) return shares;\n\n\t\t// we fallback to treasury address if recipient is not privided\n\t\trecipient = recipient == address(0) ? treasury : recipient;\n\n\t\t/// Compounding deposits pool tokens and mints shares to the treasury according to the compound fee\n\t\t///\n\t\t/// When depositing, we use this formula to convert pool tokens to shares:\n\t\t/// shares = (totalShares * poolTokens) / (totalTokens - poolTokens)\n\t\t///\n\t\t/// When compounding, we multiply the shares from this formula by the compound fee as a percentage:\n\t\t/// shares = ((totalShares * poolTokens) / (totalTokens - poolTokens)) * (compoundFee / ONE_HUNDRED_PERCENT)\n\t\t///\n\t\t/// To increase precision, we rearrange this to perform all multiplication before division:\n\t\t/// shares = ((totalShares * poolTokens) * compoundFee) / ((totalTokens - poolTokens) * ONE_HUNDRED_PERCENT)\n\t\tshares =\n\t\t\t((totalSupply(tokenId) * poolTokens) * pool.managementFee) /\n\t\t\t((totalTokens - poolTokens) * BASIS_POINTS);\n\n\t\t_mint(recipient, tokenId, shares, \"\");\n\n\t\temit TakeFees(id, msg.sender, shares);\n\n\t\treturn shares;\n\t}\n\n\t////////// GOVERNANCE FUNCTIONS //////////\n\n\t///\n\t/// Add a new pool to the bank\n\t///\n\tfunction addPool(Pool calldata newPool) external onlyRole(GUARDIAN) {\n\t\tuint256 tokenId = getTokenId(newPool.vault, newPool.id);\n\t\tif (pools[tokenId].exists) revert PoolExists();\n\n\t\t/// Add pool to the pools array\n\t\tpools[tokenId] = Pool({\n\t\t\tvault: newPool.vault,\n\t\t\tid: newPool.id,\n\t\t\tdecimals: newPool.decimals,\n\t\t\tmanagementFee: newPool.managementFee,\n\t\t\texists: true\n\t\t});\n\n\t\t/// Emit an event\n\t\temit AddPool(newPool.id, newPool.vault, tokenId);\n\t}\n\n\tfunction setTreasury(address _treasury) external onlyRole(GUARDIAN) {\n\t\ttreasury = _treasury;\n\t\temit SetTreasury(_treasury);\n\t}\n\n\tfunction totalShares(address vault, uint96 poolId)\n\t\texternal\n\t\tview\n\t\toverride(IBank)\n\t\treturns (uint256)\n\t{\n\t\tuint256 tokenId = getTokenId(vault, poolId);\n\t\treturn totalSupply(tokenId);\n\t}\n\n\t/// TODO: make sure this is superior to a lookup table\n\t/// token ids are a combination of vault address + poolId\n\tfunction getTokenId(address vault, uint96 poolId) public pure returns (uint256) {\n\t\treturn uint256(bytes32(bytes20(vault)) | bytes32(uint256(poolId)));\n\t}\n\n\tfunction getTokenInfo(uint256 tokenId) public pure returns (address vault, uint256 poolId) {\n\t\tpoolId = uint96(tokenId);\n\t\tvault = address(bytes20(bytes32(tokenId) ^ bytes32(uint256(poolId))));\n\t}\n\n\t// TODO: what are the ideal method params\n\tfunction getPool(uint256 tokenId) external view override returns (Pool memory pool) {\n\t\treturn pools[tokenId];\n\t}\n\n\t// TODO do we need this and what are the ideal method params\n\tfunction decimals(uint256 tokenId) external view override returns (uint8) {\n\t\treturn pools[tokenId].decimals;\n\t}\n\n\t// OVERRIDES\n\tfunction supportsInterface(bytes4 interfaceId)\n\t\tpublic\n\t\tpure\n\t\toverride(AccessControl, ERC1155)\n\t\treturns (bool)\n\t{\n\t\treturn interfaceId == type(IERC165).interfaceId;\n\t}\n\n\tfunction _beforeTokenTransfer(\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256[] memory ids,\n\t\tuint256[] memory amounts,\n\t\tbytes memory data\n\t) internal override {\n\t\tsuper._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n\t\t// when minting tokens for the first time\n\t\t// we lock the MIN_LIQUIDITY amount to\n\t\t// prevent rounding error manipulation\n\t\tfor (uint256 i; i < ids.length; i++) {\n\t\t\tuint256 id = ids[i];\n\t\t\tif (from == address(0) && to != address(1) && totalSupply(id) == 0) {\n\t\t\t\t_mint(address(1), id, MIN_LIQUIDITY, \"\");\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "src/bank/IBank.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nstruct Pool {\n\taddress vault;\n\tuint96 id; // slot 0\n\tuint16 managementFee;\n\tuint8 decimals;\n\tbool exists; // slot 1\n}\n\ninterface IBank {\n\t////////// EVENTS //////////\n\n\t/// @param id      vault poolId\n\t/// @param account address of the owner\n\t/// @param vault   vault address\n\t/// @param shares  amount of shares minted\n\tevent Deposit(\n\t\tuint96 indexed id,\n\t\taddress indexed vault,\n\t\taddress indexed account,\n\t\tuint256 shares\n\t);\n\n\t/// @param id      vault poolId\n\t/// @param vault   vault address\n\t/// @param account address of the owner\n\t/// @param shares  amount of shares burned\n\tevent Withdraw(\n\t\tuint96 indexed id,\n\t\taddress indexed vault,\n\t\taddress indexed account,\n\t\tuint256 shares\n\t);\n\n\t/// @param id      vault poolId\n\t/// @param vault   vault address\n\t/// @param shares  amount of shares minted\n\tevent TakeFees(uint96 indexed id, address indexed vault, uint256 shares);\n\n\t///\n\t/// @param id      vault poolId\n\t/// @param vault   vault address\n\t/// @param tokenId of the pool\n\tevent AddPool(uint96 id, address indexed vault, uint256 indexed tokenId);\n\n\t/// @param treasury new treasury address\n\tevent SetTreasury(address treasury);\n\n\tfunction totalShares(address vault, uint96 id) external view returns (uint256);\n\n\tfunction decimals(uint256 tokenId) external view returns (uint8);\n\n\tfunction getPool(uint256 tokenId) external view returns (Pool memory pool);\n\n\tfunction getTokenId(address vault, uint96 id) external pure returns (uint256 tokenId);\n\n\tfunction getTokenInfo(uint256 tokenId) external pure returns (address vault, uint256 poolId);\n\n\tfunction deposit(\n\t\tuint96 id,\n\t\taddress account,\n\t\tuint256 poolTokens,\n\t\tuint256 totalTokens\n\t) external returns (uint256);\n\n\tfunction withdraw(\n\t\tuint96 id,\n\t\taddress account,\n\t\tuint256 shares,\n\t\tuint256 totalTokens\n\t) external returns (uint256);\n\n\tfunction takeFees(\n\t\tuint96 id,\n\t\taddress recipient,\n\t\tuint256 profit,\n\t\tuint256 totalTokens\n\t) external returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n */\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    /**\n     * @dev Total amount of tokens in with a given id.\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    /**\n     * @dev Indicates whether any token exist with a given id, or not.\n     */\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n"
    },
    "src/adapters/MultichainAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\n// import { IXAdapter } from \"../interfaces/adapters/IXAdapter.sol\";\nimport { CallProxy } from \"../interfaces/adapters/IMultichainAdapter.sol\";\nimport { Auth } from \"../common/Auth.sol\";\nimport { XAdapter } from \"./XAdapter.sol\";\n\ncontract MultichainAdapter is XAdapter, Auth {\n\taddress public anyCall;\n\tmapping(uint256 => address) public adapters;\n\n\tstruct message {\n\t\tuint256 deposits;\n\t\tuint256 withdrawals;\n\t\tuint256 redeemed;\n\t}\n\n\tconstructor(\n\t\taddress _anyCall,\n\t\taddress _owner,\n\t\taddress _guardian,\n\t\taddress _manager\n\t) Auth(_owner, _guardian, _manager) {\n\t\tanyCall = _anyCall;\n\t}\n\n\tfunction sendMessage(\n\t\tuint256 _amount,\n\t\taddress _dstVautAddress,\n\t\taddress _srcVautAddress,\n\t\tuint256 _dstChainId,\n\t\tuint16 _messageType,\n\t\tuint256 _srcChainId\n\t) external override onlyRole(MANAGER) {\n\t\tbytes memory payload = abi.encode(\n\t\t\t_amount,\n\t\t\t_srcVautAddress,\n\t\t\t_dstVautAddress,\n\t\t\t_messageType,\n\t\t\t_srcChainId\n\t\t);\n\t\tCallProxy(anyCall).anyCall(adapters[_dstChainId], payload, address(0), _dstChainId, 2);\n\t}\n\n\tfunction setAdapter(uint256 _chainId, address _adapter) external onlyRole(MANAGER) {\n\t\tadapters[_chainId] = _adapter;\n\t}\n\n\tfunction anyExecute(bytes memory _data) external returns (bool success, bytes memory result) {\n\t\t// decode payload sent from source chain\n\t\t(\n\t\t\tuint256 _amount,\n\t\t\taddress _srcVaultAddress,\n\t\t\taddress _dstVaultAddress,\n\t\t\tuint16 messageType,\n\t\t\tuint256 _srcChainId\n\t\t) = abi.decode(_data, (uint256, address, address, uint16, uint256));\n\n\t\temit MessageReceived(_srcVaultAddress, _amount, _dstVaultAddress, messageType, _srcChainId);\n\n\t\tsuccess = true;\n\t\tresult = \"\";\n\t}\n\n\t/* EVENTS */\n\tevent MessageReceived(\n\t\taddress destAddress,\n\t\tuint256 amount,\n\t\taddress srcAddress,\n\t\tuint16 messageType,\n\t\tuint256 srcChainId\n\t);\n}\n"
    },
    "src/interfaces/adapters/IMultichainAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\ninterface CallProxy {\n\tfunction anyCall(\n\t\taddress _to,\n\t\tbytes calldata _data,\n\t\taddress _fallback,\n\t\tuint256 _toChainID,\n\t\tuint256 _flags\n\t) external;\n}\n"
    },
    "src/adapters/XAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\nabstract contract XAdapter {\n\tstruct Message {\n\t\tuint256 value;\n\t\tuint256 timestamp;\n\t}\n\n\tmapping(uint16 => mapping(address => Message)) internal messageBoard;\n\n\tfunction sendMessage(\n\t\tuint256 amount,\n\t\taddress dstVautAddress,\n\t\taddress srcVaultAddress,\n\t\tuint256 destChainId,\n\t\tuint16 messageType,\n\t\tuint256 srcChainId\n\t) external virtual;\n\n\tfunction readMessage(\n\t\taddress senderVaultAddress,\n\t\tuint16 senderChainId,\n\t\tuint256 timestamp\n\t) external view returns (uint256) {\n\t\tMessage memory message = messageBoard[senderChainId][senderVaultAddress];\n\n\t\tif (message.timestamp < timestamp) revert MessageExpired();\n\n\t\treturn (message.value);\n\t}\n\n\terror MessageExpired();\n}\n"
    },
    "src/adapters/LayerZeroAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\nimport { ILayerZeroReceiver } from \"../interfaces/adapters/ILayerZeroReceiver.sol\";\nimport { ILayerZeroEndpoint } from \"../interfaces/adapters/ILayerZeroEndpoint.sol\";\nimport { ILayerZeroUserApplicationConfig } from \"../interfaces/adapters/ILayerZeroUserApplicationConfig.sol\";\nimport { XAdapter } from \"./XAdapter.sol\";\nimport { Auth } from \"../common/Auth.sol\";\n\ncontract LayerZeroAdapter is ILayerZeroReceiver, ILayerZeroUserApplicationConfig, XAdapter, Auth {\n\tILayerZeroEndpoint public endpoint;\n\n\tstruct lzConfig {\n\t\taddress adapter;\n\t\tuint16 lzChainId;\n\t}\n\n\tstruct message {\n\t\tuint256 deposits;\n\t\tuint256 withdrawals;\n\t\tuint256 redeemed;\n\t}\n\n\tmapping(uint256 => mapping(address => message)) messages;\n\n\tmapping(uint256 => lzConfig) chains;\n\n\tconstructor(\n\t\taddress _layerZeroEndpoint,\n\t\taddress _owner,\n\t\taddress _guardian,\n\t\taddress _manager\n\t) Auth(_owner, _guardian, _manager) {\n\t\tendpoint = ILayerZeroEndpoint(_layerZeroEndpoint);\n\t}\n\n\tfunction sendMessage(\n\t\tuint256 _amount,\n\t\taddress _dstVautAddress,\n\t\taddress _srcVautAddress,\n\t\tuint256 _dstChainId,\n\t\tuint16 _messageType,\n\t\tuint256 _srcChainId\n\t) external override onlyRole(MANAGER) {\n\t\t_srcChainId;\n\t\tif (address(this).balance == 0) revert NoBalance();\n\n\t\tbytes memory payload = abi.encode(_amount, _srcVautAddress, _dstVautAddress, _messageType);\n\n\t\t// encode adapterParams to specify more gas for the destination\n\t\tuint16 version = 1;\n\t\tuint256 gasForDestinationLzReceive = 350000;\n\t\tbytes memory adapterParams = abi.encodePacked(version, gasForDestinationLzReceive);\n\t\t(uint256 messageFee, ) = endpoint.estimateFees(\n\t\t\tuint16(chains[_dstChainId].lzChainId),\n\t\t\taddress(this),\n\t\t\tpayload,\n\t\t\tfalse,\n\t\t\tadapterParams\n\t\t);\n\t\tif (address(this).balance < messageFee) revert InsufficientBalanceToSendMessage();\n\n\t\t// send LayerZero message\n\t\tendpoint.send{ value: messageFee }( // {value: messageFee} will be paid out of this contract!\n\t\t\tuint16(chains[_dstChainId].lzChainId), // destination chainId\n\t\t\tabi.encodePacked(chains[_dstChainId].adapter), // destination address of Adapter on dst chain\n\t\t\tpayload, // abi.encode()'ed bytes\n\t\t\tpayable(this), // (msg.sender will be this contract) refund address (LayerZero will refund any extra gas back to caller of send()\n\t\t\taddress(0x0), // 'zroPaymentAddress' unused for this mock/example\n\t\t\tadapterParams // 'adapterParams' unused for this mock/example\n\t\t);\n\t}\n\n\tfunction lzReceive(\n\t\tuint16 _srcChainId,\n\t\tbytes memory _fromAddress,\n\t\tuint64, /*_nonce*/\n\t\tbytes memory _payload\n\t) external override {\n\t\t// lzReceive can only be called by the LayerZero endpoint\n\t\tif (msg.sender != address(endpoint)) revert Unauthorized();\n\n\t\t// use assembly to extract the address from the bytes memory parameter\n\t\taddress fromAddress;\n\t\tassembly {\n\t\t\tfromAddress := mload(add(_fromAddress, 20))\n\t\t}\n\n\t\t// decode payload sent from source chain\n\t\t(\n\t\t\tuint256 _amount,\n\t\t\taddress _srcVaultAddress,\n\t\t\taddress _dstVaultAddress,\n\t\t\tuint16 messageType\n\t\t) = abi.decode(_payload, (uint256, address, address, uint16));\n\n\t\t// TODO: Implement storage logic for differente message types.\n\t\t// deposit has messageType === 1\n\t\t// redeemRequest has messageType === 2\n\t\t// redeem has messageType === 3\n\n\t\temit MessageReceived(\n\t\t\t_srcChainId,\n\t\t\tfromAddress,\n\t\t\t_srcVaultAddress,\n\t\t\t_amount,\n\t\t\t_dstVaultAddress,\n\t\t\tmessageType\n\t\t);\n\t}\n\n\tfunction setChain(\n\t\tuint256 _chainId,\n\t\taddress _adapter,\n\t\tuint16 _lzChainId\n\t) external onlyRole(MANAGER) {\n\t\tchains[_chainId].adapter = _adapter;\n\t\tchains[_chainId].lzChainId = _lzChainId;\n\t}\n\n\tfunction setConfig(\n\t\tuint16,\n\t\tuint16 _dstChainId,\n\t\tuint256 _configType,\n\t\tbytes memory _config\n\t) external override {\n\t\tendpoint.setConfig(\n\t\t\tchains[_dstChainId].lzChainId,\n\t\t\tendpoint.getSendVersion(address(this)),\n\t\t\t_configType,\n\t\t\t_config\n\t\t);\n\t}\n\n\tfunction getConfig(\n\t\tuint16,\n\t\tuint16 _chainId,\n\t\taddress,\n\t\tuint256 _configType\n\t) external view returns (bytes memory) {\n\t\treturn\n\t\t\tendpoint.getConfig(\n\t\t\t\tendpoint.getSendVersion(address(this)),\n\t\t\t\t_chainId,\n\t\t\t\taddress(this),\n\t\t\t\t_configType\n\t\t\t);\n\t}\n\n\tfunction setSendVersion(uint16 version) external override {\n\t\tendpoint.setSendVersion(version);\n\t}\n\n\tfunction setReceiveVersion(uint16 version) external override {\n\t\tendpoint.setReceiveVersion(version);\n\t}\n\n\tfunction getSendVersion() external view returns (uint16) {\n\t\treturn endpoint.getSendVersion(address(this));\n\t}\n\n\tfunction getReceiveVersion() external view returns (uint16) {\n\t\treturn endpoint.getReceiveVersion(address(this));\n\t}\n\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n\t\t// do nth\n\t}\n\n\t// allow this contract to receive ether\n\tfallback() external payable {}\n\n\treceive() external payable {}\n\n\t/* EVENTS */\n\tevent MessageReceived(\n\t\tuint16 _srcChainId,\n\t\taddress fromAddress,\n\t\taddress destAddress,\n\t\tuint256 amount,\n\t\taddress srcAddress,\n\t\tuint16 messageType\n\t);\n\n\t/* ERRORS */\n\terror Unauthorized();\n\terror NoBalance();\n\terror InsufficientBalanceToSendMessage();\n}\n"
    },
    "src/interfaces/adapters/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n\t// @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n\t// @param _srcChainId - the source endpoint identifier\n\t// @param _srcAddress - the source sending contract address from the source chain\n\t// @param _nonce - the ordered message nonce\n\t// @param _payload - the signed payload is the UA bytes has encoded to be sent\n\tfunction lzReceive(\n\t\tuint16 _srcChainId,\n\t\tbytes calldata _srcAddress,\n\t\tuint64 _nonce,\n\t\tbytes calldata _payload\n\t) external;\n}\n"
    },
    "src/interfaces/adapters/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport { ILayerZeroUserApplicationConfig } from \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n\t// @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n\t// @param _dstChainId - the destination chain identifier\n\t// @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n\t// @param _payload - a custom bytes payload to send to the destination contract\n\t// @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n\t// @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n\t// @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n\tfunction send(\n\t\tuint16 _dstChainId,\n\t\tbytes calldata _destination,\n\t\tbytes calldata _payload,\n\t\taddress payable _refundAddress,\n\t\taddress _zroPaymentAddress,\n\t\tbytes calldata _adapterParams\n\t) external payable;\n\n\t// @notice used by the messaging library to publish verified payload\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source contract (as bytes) at the source chain\n\t// @param _dstAddress - the address on destination chain\n\t// @param _nonce - the unbound message ordering nonce\n\t// @param _gasLimit - the gas limit for external contract execution\n\t// @param _payload - verified payload to send to the destination contract\n\tfunction receivePayload(\n\t\tuint16 _srcChainId,\n\t\tbytes calldata _srcAddress,\n\t\taddress _dstAddress,\n\t\tuint64 _nonce,\n\t\tuint256 _gasLimit,\n\t\tbytes calldata _payload\n\t) external;\n\n\t// @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\tfunction getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress)\n\t\texternal\n\t\tview\n\t\treturns (uint64);\n\n\t// @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n\t// @param _srcAddress - the source chain contract address\n\tfunction getOutboundNonce(uint16 _dstChainId, address _srcAddress)\n\t\texternal\n\t\tview\n\t\treturns (uint64);\n\n\t// @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n\t// @param _dstChainId - the destination chain identifier\n\t// @param _userApplication - the user app address on this EVM chain\n\t// @param _payload - the custom message to send over LayerZero\n\t// @param _payInZRO - if false, user app pays the protocol fee in native token\n\t// @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n\tfunction estimateFees(\n\t\tuint16 _dstChainId,\n\t\taddress _userApplication,\n\t\tbytes calldata _payload,\n\t\tbool _payInZRO,\n\t\tbytes calldata _adapterParam\n\t) external view returns (uint256 nativeFee, uint256 zroFee);\n\n\t// @notice get this Endpoint's immutable source identifier\n\tfunction getChainId() external view returns (uint16);\n\n\t// @notice the interface to retry failed message on this Endpoint destination\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\t// @param _payload - the payload to be retried\n\tfunction retryPayload(\n\t\tuint16 _srcChainId,\n\t\tbytes calldata _srcAddress,\n\t\tbytes calldata _payload\n\t) external;\n\n\t// @notice query if any STORED payload (message blocking) at the endpoint.\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\tfunction hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress)\n\t\texternal\n\t\tview\n\t\treturns (bool);\n\n\t// @notice query if the _libraryAddress is valid for sending msgs.\n\t// @param _userApplication - the user app address on this EVM chain\n\tfunction getSendLibraryAddress(address _userApplication) external view returns (address);\n\n\t// @notice query if the _libraryAddress is valid for receiving msgs.\n\t// @param _userApplication - the user app address on this EVM chain\n\tfunction getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n\t// @notice query if the non-reentrancy guard for send() is on\n\t// @return true if the guard is on. false otherwise\n\tfunction isSendingPayload() external view returns (bool);\n\n\t// @notice query if the non-reentrancy guard for receive() is on\n\t// @return true if the guard is on. false otherwise\n\tfunction isReceivingPayload() external view returns (bool);\n\n\t// @notice get the configuration of the LayerZero messaging library of the specified version\n\t// @param _version - messaging library version\n\t// @param _chainId - the chainId for the pending config change\n\t// @param _userApplication - the contract address of the user application\n\t// @param _configType - type of configuration. every messaging library has its own convention.\n\tfunction getConfig(\n\t\tuint16 _version,\n\t\tuint16 _chainId,\n\t\taddress _userApplication,\n\t\tuint256 _configType\n\t) external view returns (bytes memory);\n\n\t// @notice get the send() LayerZero messaging library version\n\t// @param _userApplication - the contract address of the user application\n\tfunction getSendVersion(address _userApplication) external view returns (uint16);\n\n\t// @notice get the lzReceive() LayerZero messaging library version\n\t// @param _userApplication - the contract address of the user application\n\tfunction getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "src/interfaces/adapters/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n\t// @notice set the configuration of the LayerZero messaging library of the specified version\n\t// @param _version - messaging library version\n\t// @param _chainId - the chainId for the pending config change\n\t// @param _configType - type of configuration. every messaging library has its own convention.\n\t// @param _config - configuration in the bytes. can encode arbitrary content.\n\tfunction setConfig(\n\t\tuint16 _version,\n\t\tuint16 _chainId,\n\t\tuint256 _configType,\n\t\tbytes calldata _config\n\t) external;\n\n\t// @notice set the send() LayerZero messaging library version to _version\n\t// @param _version - new messaging library version\n\tfunction setSendVersion(uint16 _version) external;\n\n\t// @notice set the lzReceive() LayerZero messaging library version to _version\n\t// @param _version - new messaging library version\n\tfunction setReceiveVersion(uint16 _version) external;\n\n\t// @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n\t// @param _srcChainId - the chainId of the source chain\n\t// @param _srcAddress - the contract address of the source contract at the source chain\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "src/USDCMock/USDCMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract USDCMock is ERC20 {\n\tconstructor(uint256 initialSupply) ERC20(\"USDC\", \"USDC\") {\n\t\t_mint(msg.sender, initialSupply);\n\t}\n}"
    },
    "src/interfaces/uniswap/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStakingRewards is IERC20 {\n\tfunction stakingToken() external view returns (address);\n\n\tfunction lastTimeRewardApplicable() external view returns (uint256);\n\n\tfunction rewardPerToken() external view returns (uint256);\n\n\tfunction earned(address account) external view returns (uint256);\n\n\tfunction getRewardForDuration() external view returns (uint256);\n\n\tfunction stakeWithPermit(\n\t\tuint256 amount,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\tfunction stake(uint256 amount) external;\n\n\tfunction withdraw(uint256 amount) external;\n\n\tfunction getReward() external;\n\n\tfunction exit() external;\n}\n\n// some farms use sushi interface\ninterface IMasterChef {\n\t// depositing 0 amount will withdraw the rewards (harvest)\n\tfunction deposit(uint256 _pid, uint256 _amount) external;\n\n\tfunction withdraw(uint256 _pid, uint256 _amount) external;\n\n\tfunction userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n\n\tfunction emergencyWithdraw(uint256 _pid) external;\n\n\tfunction pendingTokens(uint256 _pid, address _user)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256,\n\t\t\taddress,\n\t\t\tstring memory,\n\t\t\tuint256\n\t\t);\n}\n\ninterface IMiniChefV2 {\n\tstruct UserInfo {\n\t\tuint256 amount;\n\t\tint256 rewardDebt;\n\t}\n\n\tstruct PoolInfo {\n\t\tuint128 accSushiPerShare;\n\t\tuint64 lastRewardTime;\n\t\tuint64 allocPoint;\n\t}\n\n\tfunction poolLength() external view returns (uint256);\n\n\tfunction updatePool(uint256 pid) external returns (IMiniChefV2.PoolInfo memory);\n\n\tfunction userInfo(uint256 _pid, address _user) external view returns (uint256, int256);\n\n\tfunction deposit(\n\t\tuint256 pid,\n\t\tuint256 amount,\n\t\taddress to\n\t) external;\n\n\tfunction withdraw(\n\t\tuint256 pid,\n\t\tuint256 amount,\n\t\taddress to\n\t) external;\n\n\tfunction harvest(uint256 pid, address to) external;\n\n\tfunction withdrawAndHarvest(\n\t\tuint256 pid,\n\t\tuint256 amount,\n\t\taddress to\n\t) external;\n\n\tfunction emergencyWithdraw(uint256 pid, address to) external;\n}\n"
    },
    "src/SectorTimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/TimelockController.sol)\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract SectorTimelock is AccessControl {\n\tbytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n\tbytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n\tbytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n\tuint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n\tmapping(bytes32 => uint256) private _timestamps;\n\tuint256 private _minDelay;\n\n\t/**\n\t * @dev Emitted when a call is scheduled as part of operation `id`.\n\t */\n\tevent CallScheduled(\n\t\tbytes32 indexed id,\n\t\tuint256 indexed index,\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes data,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt,\n\t\tuint256 delay\n\t);\n\n\t/**\n\t * @dev Emitted when a call is performed as part of operation `id`.\n\t */\n\tevent CallExecuted(\n\t\tbytes32 indexed id,\n\t\tuint256 indexed index,\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes data\n\t);\n\n\t/**\n\t * @dev Emitted when operation `id` is cancelled.\n\t */\n\tevent Cancelled(bytes32 indexed id);\n\n\t/**\n\t * @dev Emitted when the minimum delay for future operations is modified.\n\t */\n\tevent MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n\t/**\n\t * @dev Initializes the contract with a given `minDelay`.\n\t */\n\tconstructor(\n\t\tuint256 minDelay,\n\t\taddress[] memory proposers,\n\t\taddress[] memory executors\n\t) {\n\t\t_setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n\t\t_setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n\t\t_setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n\t\t// deployer + self administration\n\t\t_setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n\t\t_setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n\t\t// register proposers\n\t\tfor (uint256 i = 0; i < proposers.length; ++i) {\n\t\t\t_setupRole(PROPOSER_ROLE, proposers[i]);\n\t\t}\n\n\t\t// register executors\n\t\tfor (uint256 i = 0; i < executors.length; ++i) {\n\t\t\t_setupRole(EXECUTOR_ROLE, executors[i]);\n\t\t}\n\n\t\t_minDelay = minDelay;\n\t\temit MinDelayChange(0, minDelay);\n\t}\n\n\t/**\n\t * @dev Modifier to make a function callable only by a certain role. In\n\t * addition to checking the sender's role, `address(0)` 's role is also\n\t * considered. Granting a role to `address(0)` is equivalent to enabling\n\t * this role for everyone.\n\t */\n\tmodifier onlyRoleOrOpenRole(bytes32 role) {\n\t\tif (!hasRole(role, address(0))) {\n\t\t\t_checkRole(role, _msgSender());\n\t\t}\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Contract might receive/hold ETH as part of the maintenance process.\n\t */\n\treceive() external payable {}\n\n\t/**\n\t * @dev Returns whether an id correspond to a registered operation. This\n\t * includes both Pending, Ready and Done operations.\n\t */\n\tfunction isOperation(bytes32 id) public view virtual returns (bool pending) {\n\t\treturn getTimestamp(id) > 0;\n\t}\n\n\t/**\n\t * @dev Returns whether an operation is pending or not.\n\t */\n\tfunction isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n\t\treturn getTimestamp(id) > _DONE_TIMESTAMP;\n\t}\n\n\t/**\n\t * @dev Returns whether an operation is ready or not.\n\t */\n\tfunction isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n\t\tuint256 timestamp = getTimestamp(id);\n\t\treturn timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n\t}\n\n\t/**\n\t * @dev Returns whether an operation is done or not.\n\t */\n\tfunction isOperationDone(bytes32 id) public view virtual returns (bool done) {\n\t\treturn getTimestamp(id) == _DONE_TIMESTAMP;\n\t}\n\n\t/**\n\t * @dev Returns the timestamp at with an operation becomes ready (0 for\n\t * unset operations, 1 for done operations).\n\t */\n\tfunction getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n\t\treturn _timestamps[id];\n\t}\n\n\t/**\n\t * @dev Returns the minimum delay for an operation to become valid.\n\t *\n\t * This value can be changed by executing an operation that calls `updateDelay`.\n\t */\n\tfunction getMinDelay() public view virtual returns (uint256 duration) {\n\t\treturn _minDelay;\n\t}\n\n\t/**\n\t * @dev Returns the identifier of an operation containing a single\n\t * transaction.\n\t */\n\tfunction hashOperation(\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt\n\t) public pure virtual returns (bytes32 hash) {\n\t\treturn keccak256(abi.encode(target, value, data, predecessor, salt));\n\t}\n\n\t/**\n\t * @dev Returns the identifier of an operation containing a batch of\n\t * transactions.\n\t */\n\tfunction hashOperationBatch(\n\t\taddress[] calldata targets,\n\t\tuint256[] calldata values,\n\t\tbytes[] calldata datas,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt\n\t) public pure virtual returns (bytes32 hash) {\n\t\treturn keccak256(abi.encode(targets, values, datas, predecessor, salt));\n\t}\n\n\t/**\n\t * @dev Schedule an operation containing a single transaction.\n\t *\n\t * Emits a {CallScheduled} event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have the 'proposer' role.\n\t */\n\tfunction schedule(\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt,\n\t\tuint256 delay\n\t) public virtual onlyRole(PROPOSER_ROLE) {\n\t\tbytes32 id = hashOperation(target, value, data, predecessor, salt);\n\t\t_schedule(id, delay);\n\t\temit CallScheduled(id, 0, target, value, data, predecessor, salt, delay);\n\t}\n\n\t/**\n\t * @dev Schedule an operation containing a batch of transactions.\n\t *\n\t * Emits one {CallScheduled} event per transaction in the batch.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have the 'proposer' role.\n\t */\n\tfunction scheduleBatch(\n\t\taddress[] calldata targets,\n\t\tuint256[] calldata values,\n\t\tbytes[] calldata datas,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt,\n\t\tuint256 delay\n\t) public virtual onlyRole(PROPOSER_ROLE) {\n\t\trequire(targets.length == values.length, \"TimelockController: length mismatch\");\n\t\trequire(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n\t\tbytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n\t\t_schedule(id, delay);\n\t\tfor (uint256 i = 0; i < targets.length; ++i) {\n\t\t\temit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, salt, delay);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Schedule an operation that is to becomes valid after a given delay.\n\t */\n\tfunction _schedule(bytes32 id, uint256 delay) private {\n\t\trequire(!isOperation(id), \"TimelockController: operation already scheduled\");\n\t\trequire(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n\t\t_timestamps[id] = block.timestamp + delay;\n\t}\n\n\t/**\n\t * @dev Cancel an operation.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have the 'proposer' role.\n\t */\n\tfunction cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n\t\trequire(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n\t\tdelete _timestamps[id];\n\n\t\temit Cancelled(id);\n\t}\n\n\t/**\n\t * @dev Execute an (ready) operation containing a single transaction.\n\t *\n\t * Emits a {CallExecuted} event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have the 'executor' role.\n\t */\n\t// This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n\t// thus any modifications to the operation during reentrancy should be caught.\n\t// slither-disable-next-line reentrancy-eth\n\tfunction execute(\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt\n\t) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n\t\tbytes32 id = hashOperation(target, value, data, predecessor, salt);\n\t\t_beforeCall(id, predecessor);\n\t\t_call(id, 0, target, value, data);\n\t\t_afterCall(id);\n\t}\n\n\t/**\n\t * @dev Execute an (ready) operation containing a batch of transactions.\n\t *\n\t * Emits one {CallExecuted} event per transaction in the batch.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have the 'executor' role.\n\t */\n\tfunction executeBatch(\n\t\taddress[] calldata targets,\n\t\tuint256[] calldata values,\n\t\tbytes[] calldata datas,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt\n\t) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n\t\trequire(targets.length == values.length, \"TimelockController: length mismatch\");\n\t\trequire(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n\t\tbytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n\t\t_beforeCall(id, predecessor);\n\t\tfor (uint256 i = 0; i < targets.length; ++i) {\n\t\t\t_call(id, i, targets[i], values[i], datas[i]);\n\t\t}\n\t\t_afterCall(id);\n\t}\n\n\t/**\n\t * @dev Checks before execution of an operation's calls.\n\t */\n\tfunction _beforeCall(bytes32 id, bytes32 predecessor) private view {\n\t\trequire(isOperationReady(id), \"TimelockController: operation is not ready\");\n\t\trequire(\n\t\t\tpredecessor == bytes32(0) || isOperationDone(predecessor),\n\t\t\t\"TimelockController: missing dependency\"\n\t\t);\n\t}\n\n\t/**\n\t * @dev Checks after execution of an operation's calls.\n\t */\n\tfunction _afterCall(bytes32 id) private {\n\t\trequire(isOperationReady(id), \"TimelockController: operation is not ready\");\n\t\t_timestamps[id] = _DONE_TIMESTAMP;\n\t}\n\n\t/**\n\t * @dev Execute an operation's call.\n\t *\n\t * Emits a {CallExecuted} event.\n\t */\n\tfunction _call(\n\t\tbytes32 id,\n\t\tuint256 index,\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) private {\n\t\t(bool success, ) = target.call{ value: value }(data);\n\t\trequire(success, \"TimelockController: underlying transaction reverted\");\n\n\t\temit CallExecuted(id, index, target, value, data);\n\t}\n\n\t/**\n\t * @dev Changes the minimum timelock duration for future operations.\n\t *\n\t * Emits a {MinDelayChange} event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n\t * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n\t */\n\tfunction updateDelay(uint256 newDelay) external virtual {\n\t\trequire(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n\t\trequire(newDelay < 30 days, \"TimelockController: delay too large\");\n\t\temit MinDelayChange(_minDelay, newDelay);\n\t\t_minDelay = newDelay;\n\t}\n}\n"
    },
    "src/interfaces/imx/IIMXFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\ninterface IIMXFactory {\n\tevent LendingPoolInitialized(\n\t\taddress indexed uniswapV2Pair,\n\t\taddress indexed token0,\n\t\taddress indexed token1,\n\t\taddress collateral,\n\t\taddress borrowable0,\n\t\taddress borrowable1,\n\t\tuint256 lendingPoolId\n\t);\n\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\tevent NewAdmin(address oldAdmin, address newAdmin);\n\tevent NewReservesPendingAdmin(address oldReservesPendingAdmin, address newReservesPendingAdmin);\n\tevent NewReservesAdmin(address oldReservesAdmin, address newReservesAdmin);\n\tevent NewReservesManager(address oldReservesManager, address newReservesManager);\n\n\tfunction admin() external view returns (address);\n\n\tfunction pendingAdmin() external view returns (address);\n\n\tfunction reservesAdmin() external view returns (address);\n\n\tfunction reservesPendingAdmin() external view returns (address);\n\n\tfunction reservesManager() external view returns (address);\n\n\tfunction getLendingPool(address uniswapV2Pair)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tbool initialized,\n\t\t\tuint24 lendingPoolId,\n\t\t\taddress collateral,\n\t\t\taddress borrowable0,\n\t\t\taddress borrowable1\n\t\t);\n\n\tfunction allLendingPools(uint256) external view returns (address uniswapV2Pair);\n\n\tfunction allLendingPoolsLength() external view returns (uint256);\n\n\tfunction bDeployer() external view returns (address);\n\n\tfunction cDeployer() external view returns (address);\n\n\tfunction tarotPriceOracle() external view returns (address);\n\n\tfunction createCollateral(address uniswapV2Pair) external returns (address collateral);\n\n\tfunction createBorrowable0(address uniswapV2Pair) external returns (address borrowable0);\n\n\tfunction createBorrowable1(address uniswapV2Pair) external returns (address borrowable1);\n\n\tfunction initializeLendingPool(address uniswapV2Pair) external;\n\n\tfunction _setPendingAdmin(address newPendingAdmin) external;\n\n\tfunction _acceptAdmin() external;\n\n\tfunction _setReservesPendingAdmin(address newPendingAdmin) external;\n\n\tfunction _acceptReservesAdmin() external;\n\n\tfunction _setReservesManager(address newReservesManager) external;\n}\n"
    },
    "src/interfaces/uniswap/ISimpleUniswapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface ISimpleUniswapOracle {\n\tevent PriceUpdate(\n\t\taddress indexed pair,\n\t\tuint256 priceCumulative,\n\t\tuint32 blockTimestamp,\n\t\tbool lastIsA\n\t);\n\n\tfunction MIN_T() external pure returns (uint32);\n\n\tfunction getBlockTimestamp() external view returns (uint32);\n\n\tfunction getPair(address uniswapV2Pair)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 priceCumulativeA,\n\t\t\tuint256 priceCumulativeB,\n\t\t\tuint32 updateA,\n\t\t\tuint32 updateB,\n\t\t\tbool lastIsA,\n\t\t\tbool initialized\n\t\t);\n\n\tfunction initialize(address uniswapV2Pair) external;\n\n\tfunction getResult(address uniswapV2Pair) external returns (uint224 price, uint32 T);\n}\n"
    },
    "src/strategies/perpetual/PerpStrategy.sol": {
      "content": "// // SPDX-License-Identifier: GPL-3.0-or-later\n// pragma solidity 0.8.16;\n// pragma experimental ABIEncoderV2;\n\n// import { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n// import { ERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n// import { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// // import { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n// import { IVault } from \"@perp/curie-contract/contracts/interface/IVault.sol\";\n// import { IClearingHouse } from \"@perp/curie-contract/contracts/interface/IClearingHouse.sol\";\n// import { IMarketRegistry } from \"@perp/curie-contract/contracts/interface/IMarketRegistry.sol\";\n// import { IAccountBalance } from \"@perp/curie-contract/contracts/interface/IAccountBalance.sol\";\n// import { IBaseToken } from \"@perp/curie-contract/contracts/interface/IBaseToken.sol\";\n// import { IClearingHouseConfig } from \"@perp/curie-contract/contracts/interface/IClearingHouseConfig.sol\";\n// import { IIndexPrice } from \"@perp/curie-contract/contracts/interface/IIndexPrice.sol\";\n// import { IOrderBook } from \"@perp/curie-contract/contracts/interface/IOrderBook.sol\";\n// import { IUniswapV3Pool } from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n// import { TickMath } from \"@uniswap/v3-core/contracts/libraries/TickMath.sol\";\n// import { FixedPointMathLib } from \"../../libraries/FixedPointMathLib.sol\";\n\n// // import { FullMath } from \"@uniswap/v3-core/contracts/libraries/FullMath.sol\";\n\n// // as a fungible vault, shares should be calculated based on the actual account value\n// // but we can't do this onchain due to the restriction of uniswap v3\n// // instead, PERP use index price based account value as reference\n// // this may makes shares not 100% accurate when index price != market price, and may have potential flaw\n// // in order to mitigate this\n// // we suggest to add more restriction to user who deposit/redeem in the same block\n// // a few potential solutions:\n// //   1. add a cool down period between deposit & withdraw\n// //   2. 2 step withdraw\n// //   3. remove liquidity and close entire position before calculating shares ( 100% accurate but cost extra fees )\n// contract FungibleVault is ReentrancyGuard, ERC20 {\n// \t// using SafeMath for uint256;\n// \tusing FixedPointMathLib for uint256;\n\n// \t// PERP\n// \taddress public vault;\n// \taddress public clearingHouse;\n// \taddress public clearingHouseConfig;\n// \taddress public marketRegistry;\n// \taddress public baseToken;\n\n// \t// Uniswap\n// \taddress public uniswapPool;\n// \tint24 internal _minTick;\n// \tint24 internal _maxTick;\n\n// \t// TODO impl EIP4626\n// \taddress public asset;\n\n// \tconstructor(\n// \t\taddress vaultArg,\n// \t\taddress marketRegistryArg,\n// \t\taddress baseTokenArg\n// \t) ERC20(\"FungibleVault\", \"VAT\") {\n// \t\trequire(IBaseToken(baseTokenArg).isOpen(), \"market is closed\");\n// \t\tclearingHouse = IVault(vaultArg).getClearingHouse();\n// \t\trequire(clearingHouse != address(0), \"ClearingHouse not found\");\n\n// \t\tvault = vaultArg;\n// \t\tbaseToken = baseTokenArg;\n// \t\tmarketRegistry = marketRegistryArg;\n// \t\tclearingHouseConfig = IClearingHouse(clearingHouse).getClearingHouseConfig();\n// \t\trequire(clearingHouseConfig != address(0), \"ClearingHouseConfig not found\");\n\n// \t\t// full range = mix tick ~ max tick\n// \t\tuniswapPool = IMarketRegistry(marketRegistryArg).getPool(baseTokenArg);\n// \t\tint24 tickSpacing = IUniswapV3Pool(uniswapPool).tickSpacing();\n// \t\t_minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;\n// \t\t_maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;\n\n// \t\t// overwrite decimals, make it same as asset\n// \t\tasset = IVault(vaultArg).getSettlementToken();\n// \t\trequire(asset != address(0), \"Vault's settlement token not found\");\n// \t\tuint8 assetDecimals = ERC20(asset).decimals();\n// \t\trequire(assetDecimals > 0, \"asset decimals is 0\");\n// \t\t_setupDecimals(assetDecimals);\n// \t}\n\n// \tfunction deposit(uint256 amount, address receiver) external nonReentrant returns (uint256) {\n// \t\trequire(amount > 0, \"deposit 0\");\n// \t\trequire(receiver != address(0), \"receiver is 0\");\n\n// \t\t// TODO rebalance to ?x leverage\n\n// \t\t// deposit to perp\n// \t\tSafeERC20.safeTransferFrom(IERC20(asset), msg.sender, address(this), amount);\n// \t\tIVault(vault).deposit(address(asset), amount);\n\n// \t\t// opens a full range order\n// \t\t// convert amount to 18 decimals\n// \t\tuint256 amount_18 = _convertTokenDecimals(amount, decimals(), 18);\n// \t\t// quote (usd) = amount / 2\n// \t\tuint256 quote = amount_18 / 2;\n// \t\t// base (position) = (amount - quote) / base TWAP\n// \t\tuint32 twapInterval = IClearingHouseConfig(clearingHouseConfig).getTwapInterval();\n// \t\tuint256 baseTwap = IIndexPrice(baseToken).getIndexPrice(twapInterval);\n// \t\tuint256 base = (amount_18 - quote).mulDivDown(1e18, baseTwap);\n\n// \t\tIClearingHouse.AddLiquidityResponse memory response = IClearingHouse(clearingHouse)\n// \t\t\t.addLiquidity(\n// \t\t\t\tIClearingHouse.AddLiquidityParams({\n// \t\t\t\t\tbaseToken: baseToken,\n// \t\t\t\t\tbase: base,\n// \t\t\t\t\tquote: quote,\n// \t\t\t\t\tlowerTick: _minTick,\n// \t\t\t\t\tupperTick: _maxTick,\n// \t\t\t\t\tminBase: 0, // TODO add min for slippage\n// \t\t\t\t\tminQuote: 0,\n// \t\t\t\t\tuseTakerBalance: false, // this is not activated yet\n// \t\t\t\t\tdeadline: block.timestamp\n// \t\t\t\t})\n// \t\t\t);\n// \t\trequire(response.liquidity > 0, \"0 liquidity added\");\n\n// \t\t// calculate shares and mint it\n// \t\tuint256 shares;\n// \t\tif (totalSupply() == 0) {\n// \t\t\tshares = amount;\n// \t\t} else {\n// \t\t\t// share = amount / account value after liquidity is added\n// \t\t\tshares = amount.mulDivDown(10**decimals(), _safeGetAccountValue());\n// \t\t}\n// \t\t_mint(receiver, shares);\n\n// \t\treturn shares;\n// \t}\n\n// \tfunction redeem(\n// \t\tuint256 shares,\n// \t\taddress receiver,\n// \t\taddress owner\n// \t) external nonReentrant returns (uint256) {\n// \t\t// ratio = shares / totalSupply\n// \t\tuint256 digits = 10**decimals();\n// \t\tuint256 ratio = shares.mulDivDown(digits, totalSupply());\n// \t\trequire(allowance(owner, msg.sender) >= shares, \"redeem amount exceeds allowance\");\n// \t\t_burn(owner, shares);\n\n// \t\t// remove range order based on the ratio\n// \t\t// (should always has 1 order and 0 taker position)\n// \t\tIOrderBook orderBook = IOrderBook(IClearingHouse(clearingHouse).getOrderBook());\n// \t\tuint128 liquidity = orderBook\n// \t\t\t.getOpenOrder(address(this), baseToken, _minTick, _maxTick)\n// \t\t\t.liquidity;\n// \t\tuint256 liquidityOwnedByUser_256 = uint256(liquidity).mulDivDown(ratio, digits);\n// \t\tuint128 liquidityOwnedByUser_128 = uint128(liquidityOwnedByUser_256);\n// \t\trequire(\n// \t\t\tliquidityOwnedByUser_128 == liquidityOwnedByUser_256,\n// \t\t\t\"value doesn't fit in 128 bits\"\n// \t\t);\n// \t\tIClearingHouse(clearingHouse).removeLiquidity(\n// \t\t\tIClearingHouse.RemoveLiquidityParams({\n// \t\t\t\tbaseToken: baseToken,\n// \t\t\t\tlowerTick: _minTick,\n// \t\t\t\tupperTick: _maxTick,\n// \t\t\t\tliquidity: liquidityOwnedByUser_128,\n// \t\t\t\tminBase: 0,\n// \t\t\t\tminQuote: 0,\n// \t\t\t\tdeadline: block.timestamp\n// \t\t\t})\n// \t\t);\n\n// \t\t// close position\n// \t\tIClearingHouse(clearingHouse).closePosition(\n// \t\t\tIClearingHouse.ClosePositionParams({\n// \t\t\t\tbaseToken: baseToken,\n// \t\t\t\tsqrtPriceLimitX96: 0, // no partial close\n// \t\t\t\toppositeAmountBound: 0, // TODO add min for slippage\n// \t\t\t\tdeadline: block.timestamp,\n// \t\t\t\treferralCode: 0\n// \t\t\t})\n// \t\t);\n// \t\t// if the position size is too large, taker position will be closed partially\n// \t\t// TODO make withdraw 2 steps, auction or let keeper close it several times\n// \t\taddress accountBalance = IClearingHouse(clearingHouse).getAccountBalance();\n// \t\trequire(\n// \t\t\tIAccountBalance(accountBalance).getTakerPositionSize(address(this), baseToken) == 0,\n// \t\t\t\"position size is too large\"\n// \t\t);\n\n// \t\t// return asset\n// \t\tuint256 accountValueOwnedByUser = _safeGetAccountValue().mulDivDown(ratio, digits);\n// \t\tIVault(vault).withdraw(asset, accountValueOwnedByUser);\n// \t\tSafeERC20.safeTransfer(IERC20(asset), receiver, accountValueOwnedByUser);\n// \t\treturn accountValueOwnedByUser;\n// \t}\n\n// \tfunction _safeGetAccountValue() internal view returns (uint256) {\n// \t\t// account value is based on index price\n// \t\tint256 accountValue = IVault(vault).getAccountValue(address(this));\n// \t\trequire(accountValue > 0, \"bankrupt\");\n// \t\treturn uint256(accountValue);\n// \t}\n\n// \tfunction _convertTokenDecimals(\n// \t\tuint256 amount,\n// \t\tuint8 fromDecimals,\n// \t\tuint8 toDecimals\n// \t) internal pure returns (uint256) {\n// \t\tif (fromDecimals == toDecimals) {\n// \t\t\treturn amount;\n// \t\t}\n// \t\treturn\n// \t\t\tfromDecimals > toDecimals\n// \t\t\t\t? amount / (10**(fromDecimals - toDecimals))\n// \t\t\t\t: amount * (10**(toDecimals - fromDecimals));\n// \t}\n// }\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}