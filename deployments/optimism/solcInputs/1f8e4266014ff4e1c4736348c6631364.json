{
  "language": "Solidity",
  "sources": {
    "src/common/Accounting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { FixedPointMathLib } from \"../libraries/FixedPointMathLib.sol\";\nimport { IERC4626Accounting } from \"../interfaces/ERC4626/IERC4626Accounting.sol\";\nimport \"hardhat/console.sol\";\n\nabstract contract Accounting is IERC4626Accounting {\n\tusing FixedPointMathLib for uint256;\n\n\tfunction totalAssets() public view virtual returns (uint256);\n\n\tfunction totalSupply() public view virtual returns (uint256);\n\n\tfunction toSharesAfterDeposit(uint256 assets) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\t\tuint256 _totalAssets = totalAssets() - assets;\n\t\tif (_totalAssets == 0) return assets;\n\t\treturn supply == 0 ? assets : assets.mulDivDown(supply, _totalAssets);\n\t}\n\n\tfunction convertToShares(uint256 assets) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n\t}\n\n\tfunction convertToAssets(uint256 shares) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n\t}\n\n\tfunction previewDeposit(uint256 assets) public view virtual returns (uint256) {\n\t\treturn convertToShares(assets);\n\t}\n\n\tfunction previewMint(uint256 shares) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n\t}\n\n\tfunction previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n\t\treturn supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n\t}\n\n\tfunction previewRedeem(uint256 shares) public view virtual returns (uint256) {\n\t\treturn convertToAssets(shares);\n\t}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "src/libraries/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n\t/*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n\tuint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n\tfunction mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n\t\treturn mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n\t}\n\n\tfunction mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n\t\treturn mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n\t}\n\n\tfunction divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n\t\treturn mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n\t}\n\n\tfunction divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n\t\treturn mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction mulDivDown(\n\t\tuint256 x,\n\t\tuint256 y,\n\t\tuint256 denominator\n\t) internal pure returns (uint256 z) {\n\t\tassembly {\n\t\t\t// Store x * y in z for now.\n\t\t\tz := mul(x, y)\n\n\t\t\t// Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n\t\t\tif iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n\t\t\t\trevert(0, 0)\n\t\t\t}\n\n\t\t\t// Divide z by the denominator.\n\t\t\tz := div(z, denominator)\n\t\t}\n\t}\n\n\tfunction mulDivUp(\n\t\tuint256 x,\n\t\tuint256 y,\n\t\tuint256 denominator\n\t) internal pure returns (uint256 z) {\n\t\tassembly {\n\t\t\t// Store x * y in z for now.\n\t\t\tz := mul(x, y)\n\n\t\t\t// Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n\t\t\tif iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n\t\t\t\trevert(0, 0)\n\t\t\t}\n\n\t\t\t// First, divide z - 1 by the denominator and add 1.\n\t\t\t// We allow z - 1 to underflow if z is 0, because we multiply the\n\t\t\t// end result by 0 if z is zero, ensuring we return 0 if z is zero.\n\t\t\tz := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n\t\t}\n\t}\n\n\tfunction rpow(\n\t\tuint256 x,\n\t\tuint256 n,\n\t\tuint256 scalar\n\t) internal pure returns (uint256 z) {\n\t\tassembly {\n\t\t\tswitch x\n\t\t\tcase 0 {\n\t\t\t\tswitch n\n\t\t\t\tcase 0 {\n\t\t\t\t\t// 0 ** 0 = 1\n\t\t\t\t\tz := scalar\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\t// 0 ** n = 0\n\t\t\t\t\tz := 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\tswitch mod(n, 2)\n\t\t\t\tcase 0 {\n\t\t\t\t\t// If n is even, store scalar in z for now.\n\t\t\t\t\tz := scalar\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\t// If n is odd, store x in z for now.\n\t\t\t\t\tz := x\n\t\t\t\t}\n\n\t\t\t\t// Shifting right by 1 is like dividing by 2.\n\t\t\t\tlet half := shr(1, scalar)\n\n\t\t\t\tfor {\n\t\t\t\t\t// Shift n right by 1 before looping to halve it.\n\t\t\t\t\tn := shr(1, n)\n\t\t\t\t} n {\n\t\t\t\t\t// Shift n right by 1 each iteration to halve it.\n\t\t\t\t\tn := shr(1, n)\n\t\t\t\t} {\n\t\t\t\t\t// Revert immediately if x ** 2 would overflow.\n\t\t\t\t\t// Equivalent to iszero(eq(div(xx, x), x)) here.\n\t\t\t\t\tif shr(128, x) {\n\t\t\t\t\t\trevert(0, 0)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store x squared.\n\t\t\t\t\tlet xx := mul(x, x)\n\n\t\t\t\t\t// Round to the nearest number.\n\t\t\t\t\tlet xxRound := add(xx, half)\n\n\t\t\t\t\t// Revert if xx + half overflowed.\n\t\t\t\t\tif lt(xxRound, xx) {\n\t\t\t\t\t\trevert(0, 0)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set x to scaled xxRound.\n\t\t\t\t\tx := div(xxRound, scalar)\n\n\t\t\t\t\t// If n is even:\n\t\t\t\t\tif mod(n, 2) {\n\t\t\t\t\t\t// Compute z * x.\n\t\t\t\t\t\tlet zx := mul(z, x)\n\n\t\t\t\t\t\t// If z * x overflowed:\n\t\t\t\t\t\tif iszero(eq(div(zx, x), z)) {\n\t\t\t\t\t\t\t// Revert if x is non-zero.\n\t\t\t\t\t\t\tif iszero(iszero(x)) {\n\t\t\t\t\t\t\t\trevert(0, 0)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Round to the nearest number.\n\t\t\t\t\t\tlet zxRound := add(zx, half)\n\n\t\t\t\t\t\t// Revert if zx + half overflowed.\n\t\t\t\t\t\tif lt(zxRound, zx) {\n\t\t\t\t\t\t\trevert(0, 0)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Return properly scaled zxRound.\n\t\t\t\t\t\tz := div(zxRound, scalar)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction sqrt(uint256 x) internal pure returns (uint256 z) {\n\t\tassembly {\n\t\t\t// Start off with z at 1.\n\t\t\tz := 1\n\n\t\t\t// Used below to help find a nearby power of 2.\n\t\t\tlet y := x\n\n\t\t\t// Find the lowest power of 2 that is at least sqrt(x).\n\t\t\tif iszero(lt(y, 0x100000000000000000000000000000000)) {\n\t\t\t\ty := shr(128, y) // Like dividing by 2 ** 128.\n\t\t\t\tz := shl(64, z) // Like multiplying by 2 ** 64.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x10000000000000000)) {\n\t\t\t\ty := shr(64, y) // Like dividing by 2 ** 64.\n\t\t\t\tz := shl(32, z) // Like multiplying by 2 ** 32.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x100000000)) {\n\t\t\t\ty := shr(32, y) // Like dividing by 2 ** 32.\n\t\t\t\tz := shl(16, z) // Like multiplying by 2 ** 16.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x10000)) {\n\t\t\t\ty := shr(16, y) // Like dividing by 2 ** 16.\n\t\t\t\tz := shl(8, z) // Like multiplying by 2 ** 8.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x100)) {\n\t\t\t\ty := shr(8, y) // Like dividing by 2 ** 8.\n\t\t\t\tz := shl(4, z) // Like multiplying by 2 ** 4.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x10)) {\n\t\t\t\ty := shr(4, y) // Like dividing by 2 ** 4.\n\t\t\t\tz := shl(2, z) // Like multiplying by 2 ** 2.\n\t\t\t}\n\t\t\tif iszero(lt(y, 0x8)) {\n\t\t\t\t// Equivalent to 2 ** z.\n\t\t\t\tz := shl(1, z)\n\t\t\t}\n\n\t\t\t// Shifting right by 1 is like dividing by 2.\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\t\t\tz := shr(1, add(z, div(x, z)))\n\n\t\t\t// Compute a rounded down version of z.\n\t\t\tlet zRoundDown := div(x, z)\n\n\t\t\t// If zRoundDown is smaller, use it.\n\t\t\tif lt(zRoundDown, z) {\n\t\t\t\tz := zRoundDown\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "src/interfaces/ERC4626/IERC4626Accounting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\ninterface IERC4626Accounting {\n\tfunction totalAssets() external view returns (uint256);\n\n\tfunction convertToShares(uint256 assets) external view returns (uint256);\n\n\tfunction convertToAssets(uint256 shares) external view returns (uint256);\n\n\tfunction previewDeposit(uint256 assets) external view returns (uint256);\n\n\tfunction previewMint(uint256 shares) external view returns (uint256);\n\n\tfunction previewWithdraw(uint256 assets) external view returns (uint256);\n\n\tfunction previewRedeem(uint256 shares) external view returns (uint256);\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "src/vaults/scy/SCYBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ISuperComposableYield, ISCYStrategy } from \"../../interfaces/scy/ISuperComposableYield.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20MetadataUpgradeable as IERC20Metadata } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport { Accounting } from \"../../common/Accounting.sol\";\nimport { ERC20Permit, EIP712 } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\nimport \"hardhat/console.sol\";\n\nabstract contract SCYBase is\n\tISuperComposableYield,\n\tReentrancyGuard,\n\tAccounting,\n\tERC20,\n\tERC20Permit\n{\n\tusing SafeERC20 for IERC20;\n\n\taddress internal constant NATIVE = address(0);\n\tuint256 internal constant ONE = 1e18;\n\tuint256 public constant MIN_LIQUIDITY = 1e3;\n\t// override if false\n\tbool public sendERC20ToStrategy = true;\n\n\t// solhint-disable no-empty-blocks\n\treceive() external payable {}\n\n\tconstructor(string memory _name, string memory _symbol)\n\t\tERC20(_name, _symbol)\n\t\tERC20Permit(_name)\n\t{}\n\n\t/*///////////////////////////////////////////////////////////////\n                    DEPOSIT/REDEEM USING BASE TOKENS\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @dev See {ISuperComposableYield-deposit}\n\t */\n\tfunction deposit(\n\t\taddress receiver,\n\t\taddress tokenIn,\n\t\tuint256 amountTokenToPull,\n\t\tuint256 minSharesOut\n\t) external payable nonReentrant returns (uint256 amountSharesOut) {\n\t\trequire(isValidBaseToken(tokenIn), \"SCY: Invalid tokenIn\");\n\n\t\tif (tokenIn == NATIVE && amountTokenToPull != 0) revert CantPullEth();\n\t\telse if (amountTokenToPull != 0) _transferIn(tokenIn, msg.sender, amountTokenToPull);\n\n\t\t// this depends on strategy\n\t\t// this supports depositing directly into strategy to save gas\n\t\tuint256 amountIn = getFloatingAmount(tokenIn);\n\t\tif (amountIn == 0) revert ZeroAmount();\n\n\t\tamountSharesOut = _deposit(receiver, tokenIn, amountIn);\n\t\tif (amountSharesOut < minSharesOut) revert InsufficientOut(amountSharesOut, minSharesOut);\n\n\t\t// lock minimum liquidity if totalSupply is 0\n\t\tif (totalSupply() == 0) {\n\t\t\tif (MIN_LIQUIDITY > amountSharesOut) revert MinLiquidity();\n\t\t\tamountSharesOut -= MIN_LIQUIDITY;\n\t\t\t_mint(address(1), MIN_LIQUIDITY);\n\t\t}\n\n\t\t_mint(receiver, amountSharesOut);\n\t\temit Deposit(msg.sender, receiver, tokenIn, amountIn, amountSharesOut);\n\t}\n\n\t/**\n\t * @dev See {ISuperComposableYield-redeem}\n\t */\n\tfunction redeem(\n\t\taddress receiver,\n\t\tuint256 amountSharesToRedeem,\n\t\taddress tokenOut,\n\t\tuint256 minTokenOut\n\t) external nonReentrant returns (uint256 amountTokenOut) {\n\t\trequire(isValidBaseToken(tokenOut), \"SCY: invalid tokenOut\");\n\n\t\t// NOTE this is different from reference implementation in that\n\t\t// we don't support sending shares to contracts\n\n\t\t// this is to handle a case where the strategy sends funds directly to user\n\t\tuint256 amountToTransfer;\n\t\t(amountTokenOut, amountToTransfer) = _redeem(receiver, tokenOut, amountSharesToRedeem);\n\t\trequire(amountTokenOut >= minTokenOut, \"insufficient out\");\n\n\t\t_burn(msg.sender, amountSharesToRedeem);\n\t\tif (amountToTransfer > 0) _transferOut(tokenOut, receiver, amountToTransfer);\n\n\t\temit Redeem(msg.sender, receiver, tokenOut, amountSharesToRedeem, amountTokenOut);\n\t}\n\n\t/**\n\t * @notice mint shares based on the deposited base tokens\n\t * @param tokenIn base token address used to mint shares\n\t * @param amountDeposited amount of base tokens deposited\n\t * @return amountSharesOut amount of shares minted\n\t */\n\tfunction _deposit(\n\t\taddress receiver,\n\t\taddress tokenIn,\n\t\tuint256 amountDeposited\n\t) internal virtual returns (uint256 amountSharesOut);\n\n\t/**\n\t * @notice redeems base tokens based on amount of shares to be burned\n\t * @param tokenOut address of the base token to be redeemed\n\t * @param amountSharesToRedeem amount of shares to be burned\n\t * @return amountTokenOut amount of base tokens redeemed\n\t */\n\tfunction _redeem(\n\t\taddress receiver,\n\t\taddress tokenOut,\n\t\tuint256 amountSharesToRedeem\n\t) internal virtual returns (uint256 amountTokenOut, uint256 tokensToTransfer);\n\n\t/*///////////////////////////////////////////////////////////////\n                               EXCHANGE-RATE\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @dev See {ISuperComposableYield-exchangeRateCurrent}\n\t */\n\tfunction exchangeRateCurrent() external virtual override returns (uint256 res);\n\n\t/**\n\t * @dev See {ISuperComposableYield-exchangeRateStored}\n\t */\n\tfunction exchangeRateStored() external view virtual override returns (uint256 res);\n\n\t// VIRTUALS\n\tfunction getFloatingAmount(address token) public view virtual returns (uint256);\n\n\t/**\n\t * @notice See {ISuperComposableYield-getBaseTokens}\n\t */\n\tfunction getBaseTokens() external view virtual override returns (address[] memory res);\n\n\t/**\n\t * @dev See {ISuperComposableYield-isValidBaseToken}\n\t */\n\tfunction isValidBaseToken(address token) public view virtual override returns (bool);\n\n\tfunction _transferIn(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual;\n\n\tfunction _transferOut(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual;\n\n\tfunction _selfBalance(address token) internal view virtual returns (uint256);\n\n\tfunction _depositNative() internal virtual;\n\n\t// OVERRIDES\n\tfunction totalSupply() public view override(Accounting, ERC20) returns (uint256) {\n\t\treturn ERC20.totalSupply();\n\t}\n\n\terror CantPullEth();\n\terror MinLiquidity();\n\terror ZeroAmount();\n\terror InsufficientOut(uint256 amountOut, uint256 minOut);\n}\n"
    },
    "src/interfaces/scy/ISuperComposableYield.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.8.16;\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ISCYStrategy } from \"./ISCYStrategy.sol\";\n\ninterface ISuperComposableYield is ISCYStrategy {\n\t/// @dev Emitted whenever the exchangeRate is updated\n\tevent ExchangeRateUpdated(uint256 oldExchangeRate, uint256 newExchangeRate);\n\n\t/// @dev Emitted when any base tokens is deposited to mint shares\n\tevent Deposit(\n\t\taddress indexed caller,\n\t\taddress indexed receiver,\n\t\taddress indexed tokenIn,\n\t\tuint256 amountDeposited,\n\t\tuint256 amountScyOut\n\t);\n\n\t/// @dev Emitted when any shares are redeemed for base tokens\n\tevent Redeem(\n\t\taddress indexed caller,\n\t\taddress indexed receiver,\n\t\taddress indexed tokenOut,\n\t\tuint256 amountScyToRedeem,\n\t\tuint256 amountTokenOut\n\t);\n\n\t/// @dev check assetInfo for more information\n\tenum AssetType {\n\t\tTOKEN,\n\t\tLIQUIDITY\n\t}\n\n\t/**\n\t * @notice mints an amount of shares by depositing a base token.\n\t * @param receiver shares recipient address\n\t * @param tokenIn address of the base tokens to mint shares\n\t * @param amountTokenToPull amount of base tokens to be transferred from (`msg.sender`)\n\t * @param minSharesOut reverts if amount of shares minted is lower than this\n\t * @return amountSharesOut amount of shares minted\n\t * @dev\n\t *\n\t * This contract receives base tokens using these two (possibly both) methods:\n\t * - The tokens have been transferred directly to this contract prior to calling deposit().\n\t * - Exactly `amountTokenToPull` are transferred to this contract using `transferFrom()` upon calling deposit().\n\t *\n\t * The amount of shares minted will be based on the combined amount of base tokens deposited\n\t * using the given two methods.\n\t *\n\t * Emits a {Deposit} event\n\t *\n\t * Requirements:\n\t * - (`baseTokenIn`) must be a valid base token.\n\t * - There must be an ongoing approval from (`msg.sender`) for this contract with\n\t * at least `amountTokenToPull` base tokens.\n\t */\n\tfunction deposit(\n\t\taddress receiver,\n\t\taddress tokenIn,\n\t\tuint256 amountTokenToPull,\n\t\tuint256 minSharesOut\n\t) external payable returns (uint256 amountSharesOut);\n\n\t/**\n\t * @notice redeems an amount of base tokens by burning some shares\n\t * @param receiver recipient address\n\t * @param amountSharesToPull amount of shares to be transferred from (`msg.sender`)\n\t * @param tokenOut address of the base token to be redeemed\n\t * @param minTokenOut reverts if amount of base token redeemed is lower than this\n\t * @return amountTokenOut amount of base tokens redeemed\n\t * @dev\n\t *\n\t * This contract receives shares using these two (possibly both) methods:\n\t * - The shares have been transferred directly to this contract prior to calling redeem().\n\t * - Exactly `amountSharesToPull` are transferred to this contract using `transferFrom()` upon calling redeem().\n\t *\n\t * The amount of base tokens redeemed based on the combined amount of shares deposited\n\t * using the given two methods\n\t *\n\t * Emits a {Redeem} event\n\t *\n\t * Requirements:\n\t * - (`tokenOut`) must be a valid base token.\n\t * - There must be an ongoing approval from (`msg.sender`) for this contract with\n\t * at least `amountSharesToPull` shares.\n\t */\n\tfunction redeem(\n\t\taddress receiver,\n\t\tuint256 amountSharesToPull,\n\t\taddress tokenOut,\n\t\tuint256 minTokenOut\n\t) external returns (uint256 amountTokenOut);\n\n\t/**\n     * @notice exchangeRateCurrent * scyBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of scy\n     he can mint must be X * exchangeRateCurrent / 1e18\n     * @dev SCYUtils's assetToScy & scyToAsset should be used instead of raw multiplication\n     & division\n     *\n     * May emit a {NewExchangeRate} event\n     */\n\tfunction exchangeRateCurrent() external returns (uint256 res);\n\n\t/**\n\t * @notice returns the previously updated and stored shares exchange rate\n\t * @dev the returned value may be outdated if exchangeRateCurrent() was not called for a\n\t * extended period of time\n\t */\n\tfunction exchangeRateStored() external view returns (uint256 res);\n\n\t/**\n\t * @notice returns the address of the underlying yield token\n\t */\n\tfunction yieldToken() external view returns (address);\n\n\t/**\n\t * @notice returns a list of all the base tokens that can be deposited to mint shares\n\t */\n\tfunction getBaseTokens() external view returns (address[] memory res);\n\n\t/**\n\t * @notice checks whether a token is a valid base token\n\t * @notice returns a boolean indicating whether this is a valid token\n\t */\n\tfunction isValidBaseToken(address token) external view returns (bool);\n\n\t/**\n    * @notice This function contains information to interpret what the asset is\n    * @notice decimals is the decimals to format asset balances\n    * @notice if asset is an ERC20 token, assetType = 0, assetAddress is the address of the token\n    * @notice if asset is liquidity of an AMM (like sqrt(k) in UniswapV2 forks), assetType = 1,\n    assetAddress is the address of the LP token\n    * @notice assetDecimals is the decimals of the asset\n    */\n\tfunction assetInfo()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tAssetType assetType,\n\t\t\taddress assetAddress,\n\t\t\tuint8 assetDecimals\n\t\t);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "src/interfaces/scy/ISCYStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISCYStrategy {\n\tfunction deposit(\n\t\taddress receiver,\n\t\taddress tokenIn,\n\t\tuint256 amountTokenToPull,\n\t\tuint256 minSharesOut\n\t) external payable returns (uint256 amountSharesOut);\n\n\tfunction redeem(\n\t\taddress receiver,\n\t\tuint256 amountSharesToPull,\n\t\taddress tokenOut,\n\t\tuint256 minTokenOut\n\t) external returns (uint256 amountTokenOut);\n\n\tfunction getAndUpdateTvl() external returns (uint256 tvl);\n\n\tfunction getTvl() external view returns (uint256 tvl);\n\n\tfunction MIN_LIQUIDITY() external view returns (uint256);\n\n\tfunction underlying() external view returns (IERC20);\n\n\tfunction sendERC20ToStrategy() external view returns (bool);\n\n\tfunction strategy() external view returns (address payable);\n\n\tfunction underlyingBalance(address) external view returns (uint256);\n\n\tfunction underlyingToShares(uint256 amnt) external view returns (uint256);\n\n\tfunction sharesToUnderlying(uint256 shares) external view returns (uint256);\n\n\tfunction getUpdatedUnderlyingBalance(address) external returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "src/vaults/scy/SCYVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { SCYBase, IERC20, IERC20Metadata, SafeERC20 } from \"./SCYBase.sol\";\nimport { IMX } from \"../../strategies/imx/IMX.sol\";\nimport { Auth } from \"../../common/Auth.sol\";\nimport { Fees } from \"../../common/Fees.sol\";\nimport { SafeETH } from \"../../libraries/SafeETH.sol\";\nimport { SCYStrategy, Strategy } from \"./SCYStrategy.sol\";\nimport { FixedPointMathLib } from \"../../libraries/FixedPointMathLib.sol\";\nimport { IWETH } from \"../../interfaces/uniswap/IWETH.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"hardhat/console.sol\";\n\nabstract contract SCYVault is SCYStrategy, SCYBase, Fees {\n\tusing SafeERC20 for IERC20;\n\tusing FixedPointMathLib for uint256;\n\n\tevent Harvest(\n\t\taddress indexed treasury,\n\t\tuint256 underlyingProfit,\n\t\tuint256 performanceFee,\n\t\tuint256 managementFee,\n\t\tuint256 sharesFees,\n\t\tuint256 tvl\n\t);\n\n\tuint256 public lastHarvestTimestamp;\n\tuint256 public lastHarvestInterval; // time interval of last harvest\n\tuint256 public maxLockedProfit;\n\n\taddress payable public strategy;\n\n\t// immutables\n\taddress public immutable yieldToken;\n\tuint256 public immutable strategyId; // strategy-specific id ex: for MasterChef or 1155\n\tIERC20 public immutable underlying;\n\n\tuint256 public maxTvl; // pack all params and balances\n\tuint256 public vaultTvl; // strategy balance in underlying\n\tuint256 public uBalance; // underlying balance held by vault\n\n\tevent MaxTvlUpdated(uint256 maxTvl);\n\tevent StrategyUpdated(address strategy);\n\n\tmodifier isInitialized() {\n\t\tif (strategy == address(0)) revert NotInitialized();\n\t\t_;\n\t}\n\n\tconstructor(Strategy memory _strategy) SCYBase(_strategy.name, _strategy.symbol) {\n\t\t// strategy init\n\t\tyieldToken = _strategy.yieldToken;\n\t\tstrategy = payable(_strategy.addr);\n\t\tstrategyId = _strategy.strategyId;\n\t\tunderlying = _strategy.underlying;\n\t\tmaxTvl = _strategy.maxTvl;\n\n\t\tlastHarvestTimestamp = block.timestamp;\n\t}\n\n\t/*///////////////////////////////////////////////////////////////\n                    CONFIG\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction getMaxTvl() public view returns (uint256) {\n\t\treturn min(maxTvl, _stratMaxTvl());\n\t}\n\n\tfunction setMaxTvl(uint256 _maxTvl) public onlyRole(GUARDIAN) {\n\t\tmaxTvl = _maxTvl;\n\t\temit MaxTvlUpdated(min(maxTvl, _stratMaxTvl()));\n\t}\n\n\tfunction initStrategy(address _strategy) public onlyRole(GUARDIAN) {\n\t\tif (strategy != address(0)) revert NoReInit();\n\t\tstrategy = payable(_strategy);\n\t\t_stratValidate();\n\t\temit StrategyUpdated(_strategy);\n\t}\n\n\tfunction updateStrategy(address _strategy) public onlyOwner {\n\t\tuint256 tvl = _stratGetAndUpdateTvl();\n\t\tif (tvl > 0) revert InvalidStrategyUpdate();\n\t\tstrategy = payable(_strategy);\n\t\t_stratValidate();\n\t\temit StrategyUpdated(_strategy);\n\t}\n\n\tfunction _depositNative() internal override {\n\t\tuint256 balance = address(this).balance;\n\t\tIWETH(address(underlying)).deposit{ value: balance }();\n\t\tif (sendERC20ToStrategy) IERC20(underlying).safeTransfer(strategy, balance);\n\t}\n\n\tfunction _deposit(\n\t\taddress,\n\t\taddress token,\n\t\tuint256 amount\n\t) internal override isInitialized returns (uint256 sharesOut) {\n\t\t// if we have any float in the contract we cannot do deposit accounting\n\t\tif (uBalance > 0) revert DepositsPaused();\n\t\tif (token == NATIVE) _depositNative();\n\t\tif (!sendERC20ToStrategy) underlying.safeTransfer(strategy, amount);\n\t\tuint256 yieldTokenAdded = _stratDeposit(amount);\n\t\tsharesOut = toSharesAfterDeposit(yieldTokenAdded);\n\t\tvaultTvl += amount;\n\t}\n\n\tfunction _redeem(\n\t\taddress receiver,\n\t\taddress token,\n\t\tuint256 sharesToRedeem\n\t) internal override returns (uint256 amountTokenOut, uint256 amountToTransfer) {\n\t\tuint256 _totalSupply = totalSupply();\n\n\t\t// adjust share amount for lockedProfit\n\t\t// we still burn the full sharesToRedeem, but fewer assets are returned\n\t\t// this is required in order to prevent harvest front-running\n\t\tsharesToRedeem = (sharesToRedeem * (_totalSupply - lockedProfit())) / _totalSupply;\n\t\tuint256 yeildTokenRedeem = convertToAssets(sharesToRedeem);\n\n\t\t// vault may hold float of underlying, in this case, add a share of reserves to withdrawal\n\t\t// TODO why not use underlying.balanceOf?\n\t\tuint256 reserves = uBalance;\n\t\tuint256 shareOfReserves = (reserves * sharesToRedeem) / _totalSupply;\n\n\t\t// Update strategy underlying reserves balance\n\t\tif (shareOfReserves > 0) uBalance -= shareOfReserves;\n\n\t\treceiver = token == NATIVE ? address(this) : receiver;\n\n\t\t// if we also need to send the user share of reserves, we allways withdraw to vault first\n\t\t// if we don't we can have strategy withdraw directly to user if possible\n\t\tif (shareOfReserves > 0) {\n\t\t\t(amountTokenOut, amountToTransfer) = _stratRedeem(receiver, yeildTokenRedeem);\n\t\t\tamountTokenOut += shareOfReserves;\n\t\t\tamountToTransfer += shareOfReserves;\n\t\t} else (amountTokenOut, amountToTransfer) = _stratRedeem(receiver, yeildTokenRedeem);\n\t\tvaultTvl -= amountTokenOut;\n\n\t\t// it requested token is native, convert to native\n\t\tif (token == NATIVE) IWETH(address(underlying)).withdraw(amountToTransfer);\n\t}\n\n\t/// @notice harvest strategy\n\tfunction harvest(uint256 expectedTvl, uint256 maxDelta) external onlyRole(MANAGER) {\n\t\tuint256 tvl = _stratGetAndUpdateTvl() + underlying.balanceOf(address(this));\n\t\t_checkSlippage(expectedTvl, tvl, maxDelta);\n\t\tuint256 prevTvl = vaultTvl;\n\t\tuint256 timestamp = block.timestamp;\n\t\tuint256 profit = tvl > prevTvl ? tvl - prevTvl : 0;\n\n\t\t// PROCESS VAULT FEES\n\t\tuint256 _performanceFee = profit == 0 ? 0 : (profit * performanceFee) / 1e18;\n\t\tuint256 _managementFee = managementFee == 0\n\t\t\t? 0\n\t\t\t: (managementFee * tvl * (timestamp - lastHarvestTimestamp)) / 1e18 / 365 days;\n\n\t\tuint256 totalFees = _performanceFee + _managementFee;\n\t\tuint256 feeShares;\n\t\tif (totalFees > 0) {\n\t\t\t// we know that totalSupply != 0 and tvl > totalFees\n\t\t\t// this results in more accurate accounting considering dilution\n\t\t\tfeeShares = totalFees.mulDivDown(totalSupply(), tvl - totalFees);\n\t\t\t_mint(treasury, feeShares);\n\t\t}\n\n\t\temit Harvest(treasury, profit, _performanceFee, _managementFee, feeShares, tvl);\n\n\t\tvaultTvl = tvl;\n\n\t\t// TODO computing lockedProfit for all profits is a bit heavy-handed\n\t\t// in reality it should only apply to the immediate profits from startegy's harvest\n\t\t// we can do this if we issue the strategy harvest call from inside this method\n\n\t\t// keep previous locked profits + add current profits\n\t\tuint256 newLockedProfit = totalFees > profit\n\t\t\t? 0\n\t\t\t: (profit - totalFees).mulDivDown(totalSupply(), tvl);\n\t\tmaxLockedProfit = lockedProfit() + newLockedProfit;\n\n\t\t// we use 3/4 of the interval for locked profits\n\t\tlastHarvestInterval = ((timestamp - lastHarvestTimestamp) * 3) / 4;\n\t\tlastHarvestTimestamp = timestamp;\n\t}\n\n\t/// @notice Calculates the current amount of locked profit.\n\t/// @return The current amount of locked profit.\n\tfunction lockedProfit() public view returns (uint256) {\n\t\t// Get the last harvest and harvest delay.\n\t\tuint256 previousHarvest = lastHarvestTimestamp;\n\t\tuint256 harvestInterval = lastHarvestInterval;\n\n\t\tunchecked {\n\t\t\t// If the harvest delay has passed, there is no locked profit.\n\t\t\t// Cannot overflow on human timescales since harvestInterval is capped.\n\t\t\tif (block.timestamp >= previousHarvest + harvestInterval) return 0;\n\n\t\t\t// Get the maximum amount we could return.\n\t\t\tuint256 maximumLockedProfit = maxLockedProfit;\n\n\t\t\t// Compute how much profit remains locked based on the last harvest and harvest delay.\n\t\t\t// It's impossible for the previous harvest to be in the future, so this will never underflow.\n\t\t\treturn\n\t\t\t\tmaximumLockedProfit -\n\t\t\t\t(maximumLockedProfit * (block.timestamp - previousHarvest)) /\n\t\t\t\tharvestInterval;\n\t\t}\n\t}\n\n\tfunction _checkSlippage(\n\t\tuint256 expectedValue,\n\t\tuint256 actualValue,\n\t\tuint256 maxDelta\n\t) internal pure {\n\t\tuint256 delta = expectedValue > actualValue\n\t\t\t? expectedValue - actualValue\n\t\t\t: actualValue - expectedValue;\n\t\tif (delta > maxDelta) revert SlippageExceeded();\n\t}\n\n\t/// @notice slippage is computed in shares\n\tfunction depositIntoStrategy(uint256 underlyingAmount, uint256 minAmountOut)\n\t\tpublic\n\t\tonlyRole(GUARDIAN)\n\t{\n\t\tif (underlyingAmount > uBalance) revert NotEnoughUnderlying();\n\t\tuBalance -= underlyingAmount;\n\t\tunderlying.safeTransfer(strategy, underlyingAmount);\n\t\tuint256 yAdded = _stratDeposit(underlyingAmount);\n\t\tuint256 virtualSharesOut = toSharesAfterDeposit(yAdded);\n\t\tif (virtualSharesOut < minAmountOut) revert SlippageExceeded();\n\t\temit DepositIntoStrategy(msg.sender, underlyingAmount);\n\t}\n\n\t/// @notice slippage is computed in underlying\n\tfunction withdrawFromStrategy(uint256 shares, uint256 minAmountOut) public onlyRole(GUARDIAN) {\n\t\tuint256 yieldTokenAmnt = convertToAssets(shares);\n\t\t(uint256 underlyingWithdrawn, ) = _stratRedeem(address(this), yieldTokenAmnt);\n\t\tif (underlyingWithdrawn < minAmountOut) revert SlippageExceeded();\n\t\tuBalance += underlyingWithdrawn;\n\t\temit WithdrawFromStrategy(msg.sender, underlyingWithdrawn);\n\t}\n\n\tfunction closePosition(uint256 minAmountOut, uint256 slippageParam) public onlyRole(GUARDIAN) {\n\t\tuint256 underlyingWithdrawn = _stratClosePosition(slippageParam);\n\t\tif (underlyingWithdrawn < minAmountOut) revert SlippageExceeded();\n\t\tuBalance += underlyingWithdrawn;\n\t\temit ClosePosition(msg.sender, underlyingWithdrawn);\n\t}\n\n\t/// @notice this method allows an arbitrary method to be called by the owner in case of emergency\n\t/// owner must be a timelock contract in order to allow users to redeem funds in case they suspect\n\t/// this action to be malicious\n\tfunction emergencyAction(address target, bytes calldata callData) public onlyOwner {\n\t\tAddress.functionCall(target, callData);\n\t\temit EmergencyAction(target, callData);\n\t}\n\n\tfunction getStrategyTvl() public view returns (uint256) {\n\t\treturn _strategyTvl();\n\t}\n\n\t/// no slippage check - slippage can be done on vault level\n\t/// against total expected balance of all strategies\n\tfunction getAndUpdateTvl() public returns (uint256 tvl) {\n\t\tuint256 stratTvl = _stratGetAndUpdateTvl();\n\t\tuint256 balance = underlying.balanceOf(address(this));\n\t\ttvl = balance + stratTvl;\n\t}\n\n\tfunction getTvl() public view returns (uint256 tvl) {\n\t\tuint256 stratTvl = _strategyTvl();\n\t\tuint256 balance = underlying.balanceOf(address(this));\n\t\ttvl = balance + stratTvl;\n\t}\n\n\tfunction totalAssets() public view override returns (uint256) {\n\t\treturn _selfBalance(yieldToken);\n\t}\n\n\tfunction isPaused() public view returns (bool) {\n\t\treturn uBalance > 0;\n\t}\n\n\t// used for estimates only\n\tfunction exchangeRateUnderlying() public view returns (uint256) {\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0) return _stratCollateralToUnderlying();\n\t\tuint256 tvl = underlying.balanceOf(address(this)) + _strategyTvl();\n\t\treturn tvl.mulDivUp(ONE, _totalSupply);\n\t}\n\n\tfunction getUpdatedUnderlyingBalance(address user) external returns (uint256) {\n\t\tuint256 userBalance = balanceOf(user);\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0 || userBalance == 0) return 0;\n\t\tuint256 tvl = underlying.balanceOf(address(this)) + _stratGetAndUpdateTvl();\n\t\treturn (tvl * userBalance) / _totalSupply;\n\t}\n\n\tfunction underlyingBalance(address user) external view returns (uint256) {\n\t\tuint256 userBalance = balanceOf(user);\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0 || userBalance == 0) return 0;\n\t\tuint256 tvl = underlying.balanceOf(address(this)) + _strategyTvl();\n\t\tuint256 adjustedShares = (userBalance * (_totalSupply - lockedProfit())) / _totalSupply;\n\t\treturn (tvl * adjustedShares) / _totalSupply;\n\t}\n\n\tfunction underlyingToShares(uint256 uAmnt) public view returns (uint256) {\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0) return uAmnt.mulDivDown(ONE, _stratCollateralToUnderlying());\n\t\treturn uAmnt.mulDivDown(_totalSupply, getTvl());\n\t}\n\n\tfunction sharesToUnderlying(uint256 shares) public view returns (uint256) {\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0) return (shares * _stratCollateralToUnderlying()) / ONE;\n\t\tuint256 adjustedShares = (shares * (_totalSupply - lockedProfit())) / _totalSupply;\n\t\treturn adjustedShares.mulDivDown(getTvl(), _totalSupply);\n\t}\n\n\t///\n\t///  Yield Token Overrides\n\t///\n\n\tfunction assetInfo()\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tAssetType assetType,\n\t\t\taddress assetAddress,\n\t\t\tuint8 assetDecimals\n\t\t)\n\t{\n\t\taddress yToken = yieldToken;\n\t\treturn (AssetType.LIQUIDITY, yToken, IERC20Metadata(yToken).decimals());\n\t}\n\n\tfunction underlyingDecimals() public view returns (uint8) {\n\t\treturn IERC20Metadata(address(underlying)).decimals();\n\t}\n\n\t/// make sure to override this - actual logic should use floating strategy balances\n\tfunction getFloatingAmount(address token)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256 fltAmnt)\n\t{\n\t\tif (token == address(underlying)) return underlying.balanceOf(strategy);\n\t\tif (token == NATIVE) return address(this).balance;\n\t}\n\n\tfunction decimals() public pure override returns (uint8) {\n\t\treturn 18;\n\t}\n\n\t/**\n\t * @dev See {ISuperComposableYield-exchangeRateCurrent}\n\t */\n\tfunction exchangeRateCurrent() public view virtual override returns (uint256) {\n\t\tuint256 _totalSupply = totalSupply();\n\t\tif (_totalSupply == 0) return ONE;\n\t\treturn (_selfBalance(yieldToken) * ONE) / _totalSupply;\n\t}\n\n\t/**\n\t * @dev See {ISuperComposableYield-exchangeRateStored}\n\t */\n\n\tfunction exchangeRateStored() external view virtual override returns (uint256) {\n\t\treturn exchangeRateCurrent();\n\t}\n\n\tfunction getBaseTokens() external view virtual override returns (address[] memory res) {\n\t\tres[0] = address(underlying);\n\t}\n\n\tfunction isValidBaseToken(address token) public view virtual override returns (bool) {\n\t\treturn token == address(underlying);\n\t}\n\n\t// send funds to strategy\n\tfunction _transferIn(\n\t\taddress token,\n\t\taddress from,\n\t\tuint256 amount\n\t) internal virtual override {\n\t\taddress to = sendERC20ToStrategy ? strategy : address(this);\n\t\tIERC20(token).safeTransferFrom(from, to, amount);\n\t\t// if (token == NATIVE) {\n\t\t// \t// if strategy logic lives in this contract, don't do anything\n\t\t// \tif (strategy != address(this)) return SafeETH.safeTransferETH(to, amount);\n\t\t// } else IERC20(token).safeTransferFrom(from, to, amount);\n\t}\n\n\t// send funds to user\n\tfunction _transferOut(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual override {\n\t\tif (token == NATIVE) {\n\t\t\tSafeETH.safeTransferETH(to, amount);\n\t\t} else {\n\t\t\tIERC20(token).safeTransfer(to, amount);\n\t\t}\n\t}\n\n\t// todo handle internal float balances\n\tfunction _selfBalance(address token) internal view virtual override returns (uint256) {\n\t\treturn (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n\t}\n\n\t/**\n\t * @dev Returns the smallest of two numbers.\n\t */\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tevent WithdrawFromStrategy(address indexed caller, uint256 amount);\n\tevent DepositIntoStrategy(address indexed caller, uint256 amount);\n\tevent ClosePosition(address indexed caller, uint256 amount);\n\tevent EmergencyAction(address target, bytes callData);\n\n\terror InvalidStrategyUpdate();\n\terror NoReInit();\n\terror InvalidStrategy();\n\terror NotInitialized();\n\terror DepositsPaused();\n\terror StrategyExists();\n\terror StrategyDoesntExist();\n\terror NotEnoughUnderlying();\n\terror SlippageExceeded();\n\terror BadStaticCall();\n}\n"
    },
    "src/strategies/imx/IMX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IMXCore } from \"./IMXCore.sol\";\nimport { IMXFarm } from \"./IMXFarm.sol\";\nimport { IMXConfig } from \"../../interfaces/Structs.sol\";\nimport { AuthConfig } from \"../../common/Auth.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract IMX is IMXCore, IMXFarm {\n\tfunction initialize(IMXConfig memory config) public initializer {\n\t\t__Auth_init_(AuthConfig(config.owner, config.guardian, config.manager));\n\n\t\t__IMXFarm_init_(\n\t\t\tconfig.underlying,\n\t\t\tconfig.uniPair,\n\t\t\tconfig.poolToken,\n\t\t\tconfig.farmRouter,\n\t\t\tconfig.farmToken\n\t\t);\n\n\t\t// HedgedLP should allways be intialized last\n\t\t__IMX_init_(config.vault, config.underlying, config.short, config.maxTvl);\n\t}\n\n\tfunction tarotBorrow(\n\t\taddress a,\n\t\taddress b,\n\t\tuint256 c,\n\t\tbytes calldata data\n\t) external {\n\t\timpermaxBorrow(a, b, c, data);\n\t}\n\n\tfunction tarotRedeem(\n\t\taddress a,\n\t\tuint256 redeemAmount,\n\t\tbytes calldata data\n\t) external {\n\t\timpermaxRedeem(a, redeemAmount, data);\n\t}\n}\n"
    },
    "src/common/Auth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nstruct AuthConfig {\n\taddress owner;\n\taddress guardian;\n\taddress manager;\n}\n\ncontract Auth is AccessControl {\n\tevent OwnershipTransferInitiated(address owner, address pendingOwner);\n\tevent OwnershipTransferred(address oldOwner, address newOwner);\n\n\t////////// CONSTANTS //////////\n\n\t/// Update vault params, perform time-sensitive operations, set manager\n\tbytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n\n\t/// Hot-wallet bots that route funds between vaults, rebalance and harvest strategies\n\tbytes32 public constant MANAGER = keccak256(\"MANAGER\");\n\n\t/// Add and remove vaults and strategies and other critical operations behind timelock\n\t/// Default admin role\n\t/// There should only be one owner, so it is not a role\n\taddress public owner;\n\taddress public pendingOwner;\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"ONLY_OWNER\");\n\t\t_;\n\t}\n\n\tconstructor(AuthConfig memory authConfig) {\n\t\t/// Set up the roles\n\t\t// owner can manage all roles\n\t\towner = authConfig.owner;\n\t\temit OwnershipTransferred(address(0), authConfig.owner);\n\n\t\t// TODO do we want cascading roles like this?\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, authConfig.owner);\n\t\t_grantRole(GUARDIAN, owner);\n\t\t_grantRole(GUARDIAN, authConfig.guardian);\n\t\t_grantRole(MANAGER, authConfig.owner);\n\t\t_grantRole(MANAGER, authConfig.guardian);\n\t\t_grantRole(MANAGER, authConfig.manager);\n\n\t\t/// Allow the guardian role to manage manager\n\t\t_setRoleAdmin(MANAGER, GUARDIAN);\n\t}\n\n\t// ----------- Ownership -----------\n\n\t/// @dev Init transfer of ownership of the contract to a new account (`_pendingOwner`).\n\t/// @param _pendingOwner pending owner of contract\n\t/// Can only be called by the current owner.\n\tfunction transferOwnership(address _pendingOwner) external onlyOwner {\n\t\tpendingOwner = _pendingOwner;\n\t\temit OwnershipTransferInitiated(owner, pendingOwner);\n\t}\n\n\t/// @dev Accept transfer of ownership of the contract.\n\t/// Can only be called by the pendingOwner.\n\tfunction acceptOwnership() external {\n\t\trequire(msg.sender == pendingOwner, \"ONLY_PENDING_OWNER\");\n\t\taddress oldOwner = owner;\n\t\towner = pendingOwner;\n\n\t\t// revoke the DEFAULT ADMIN ROLE from prev owner\n\t\t_revokeRole(DEFAULT_ADMIN_ROLE, oldOwner);\n\t\t_revokeRole(GUARDIAN, oldOwner);\n\t\t_revokeRole(MANAGER, oldOwner);\n\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, owner);\n\t\t_grantRole(GUARDIAN, owner);\n\t\t_grantRole(MANAGER, owner);\n\n\t\temit OwnershipTransferred(oldOwner, owner);\n\t}\n}\n"
    },
    "src/common/Fees.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { Auth } from \"./Auth.sol\";\n\n// import \"hardhat/console.sol\";\n\nstruct FeeConfig {\n\taddress treasury;\n\tuint256 performanceFee;\n\tuint256 managementFee;\n}\n\nabstract contract Fees is Auth {\n\tuint256 public constant MAX_MANAGEMENT_FEE = .05e18; // 5%\n\tuint256 public constant MAX_PERFORMANCE_FEE = .25e18; // 25%\n\n\t/// @notice The percentage of profit recognized each harvest to reserve as fees.\n\t/// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\n\tuint256 public performanceFee;\n\n\t/// @notice Annual management fee.\n\t/// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\n\tuint256 public managementFee;\n\n\t/// @notice address where all fees are sent to\n\taddress public treasury;\n\n\tconstructor(FeeConfig memory feeConfig) {\n\t\ttreasury = feeConfig.treasury;\n\t\tperformanceFee = feeConfig.performanceFee;\n\t\tmanagementFee = feeConfig.managementFee;\n\t\temit SetTreasury(feeConfig.treasury);\n\t\temit SetPerformanceFee(feeConfig.performanceFee);\n\t\temit SetManagementFee(feeConfig.managementFee);\n\t}\n\n\t/// @notice Sets a new performanceFee.\n\t/// @param _performanceFee The new performance fee.\n\tfunction setPerformanceFee(uint256 _performanceFee) public onlyOwner {\n\t\tif (_performanceFee > MAX_PERFORMANCE_FEE) revert OverMaxFee();\n\n\t\tperformanceFee = _performanceFee;\n\t\temit SetPerformanceFee(performanceFee);\n\t}\n\n\t/// @notice Sets a new performanceFee.\n\t/// @param _managementFee The new performance fee.\n\tfunction setManagementFee(uint256 _managementFee) public onlyOwner {\n\t\tif (_managementFee > MAX_MANAGEMENT_FEE) revert OverMaxFee();\n\n\t\tmanagementFee = _managementFee;\n\t\temit SetManagementFee(_managementFee);\n\t}\n\n\t/// @notice Updates treasury.\n\t/// @param _treasury New treasury address.\n\tfunction setTreasury(address _treasury) public onlyOwner {\n\t\ttreasury = _treasury;\n\t\temit SetTreasury(_treasury);\n\t}\n\n\t/// @notice Emitted when performance fee is updated.\n\t/// @param performanceFee The new perforamance fee.\n\tevent SetPerformanceFee(uint256 performanceFee);\n\n\t/// @notice Emitted when management fee is updated.\n\t/// @param managementFee The new management fee.\n\tevent SetManagementFee(uint256 managementFee);\n\n\tevent SetTreasury(address indexed treasury);\n\n\terror OverMaxFee();\n}\n"
    },
    "src/libraries/SafeETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nlibrary SafeETH {\n\tfunction safeTransferETH(address to, uint256 amount) internal {\n\t\tbool callStatus;\n\n\t\tassembly {\n\t\t\t// Transfer the ETH and store if it succeeded or not.\n\t\t\tcallStatus := call(gas(), to, amount, 0, 0, 0, 0)\n\t\t}\n\n\t\trequire(callStatus, \"ETH_TRANSFER_FAILED\");\n\t}\n}\n"
    },
    "src/vaults/scy/SCYStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { IERC20 } from \"./SCYBase.sol\";\n\nstruct Strategy {\n\tstring symbol;\n\tstring name;\n\taddress addr;\n\tuint256 strategyId; // this is strategy specific token if 1155\n\taddress yieldToken;\n\tIERC20 underlying;\n\tuint128 maxTvl; // pack all params and balances\n\tuint128 balance; // strategy balance in underlying\n\tuint128 uBalance; // underlying balance\n\tuint128 yBalance; // yield token balance\n}\n\nabstract contract SCYStrategy {\n\tfunction _stratDeposit(uint256 amount) internal virtual returns (uint256);\n\n\tfunction _stratRedeem(address to, uint256 amount)\n\t\tinternal\n\t\tvirtual\n\t\treturns (uint256 amntOut, uint256 amntToTransfer);\n\n\tfunction _stratClosePosition(uint256 slippageParam) internal virtual returns (uint256);\n\n\tfunction _stratGetAndUpdateTvl() internal virtual returns (uint256);\n\n\tfunction _strategyTvl() internal view virtual returns (uint256);\n\n\tfunction _stratMaxTvl() internal view virtual returns (uint256);\n\n\tfunction _stratCollateralToUnderlying() internal view virtual returns (uint256);\n\n\tfunction _stratValidate() internal virtual;\n\n\terror NotImplemented();\n}\n"
    },
    "src/interfaces/uniswap/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IWETH {\n\tfunction deposit() external payable;\n\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\tfunction withdraw(uint256) external;\n\n\tfunction balanceOf(address) external returns (uint256);\n}\n"
    },
    "src/strategies/imx/IMXCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20Upgradeable as SafeERC20, IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20MetadataUpgradeable as IERC20Metadata } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { IBaseU, HarvestSwapParms } from \"../mixins/upgradable/IBaseU.sol\";\nimport { IIMXFarmU } from \"../mixins/upgradable/IIMXFarmU.sol\";\nimport { UniUtils, IUniswapV2Pair } from \"../../libraries/UniUtils.sol\";\nimport { FixedPointMathLib } from \"../../libraries/FixedPointMathLib.sol\";\n\nimport { IMXAuthU } from \"./IMXAuthU.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract IMXCore is\n\tInitializable,\n\tReentrancyGuardUpgradeable,\n\tIMXAuthU,\n\tIBaseU,\n\tIIMXFarmU\n{\n\tusing FixedPointMathLib for uint256;\n\tusing UniUtils for IUniswapV2Pair;\n\tusing SafeERC20 for IERC20;\n\n\tevent Deposit(address sender, uint256 amount);\n\tevent Redeem(address sender, uint256 amount);\n\n\t// event RebalanceLoan(address indexed sender, uint256 startLoanHealth, uint256 updatedLoanHealth);\n\tevent SetRebalanceThreshold(uint256 rebalanceThreshold);\n\tevent SetMaxTvl(uint256 maxTvl);\n\t// this determines our default leverage position\n\tevent SetSafetyMarginSqrt(uint256 safetyMarginSqrt);\n\n\tevent Harvest(uint256 harvested); // this is actual the tvl before harvest\n\tevent Rebalance(uint256 shortPrice, uint256 tvlBeforeRebalance, uint256 positionOffset);\n\tevent SetMaxPriceOffset(uint256 maxPriceOffset);\n\n\tuint256 constant MINIMUM_LIQUIDITY = 1000;\n\tuint256 constant BPS_ADJUST = 10000;\n\n\tIERC20 private _underlying;\n\tIERC20 private _short;\n\n\tuint256 private _maxTvl;\n\tuint16 public rebalanceThreshold = 400; // 4% of lp\n\t// price move before liquidation\n\tuint256 private _safetyMarginSqrt = 1.140175425e18; // sqrt of 130%\n\tuint256 public maxPriceOffset = .2e18;\n\n\tmodifier checkPrice(uint256 expectedPrice, uint256 maxDelta) {\n\t\t// parameter validation\n\t\t// to prevent manipulation by manager\n\t\tif (!hasRole(GUARDIAN, msg.sender)) {\n\t\t\tuint256 oraclePrice = _shortToUnderlyingOracle(1e18);\n\t\t\tuint256 oracleDelta = oraclePrice > expectedPrice\n\t\t\t\t? oraclePrice - expectedPrice\n\t\t\t\t: expectedPrice - oraclePrice;\n\t\t\tif ((1e18 * (oracleDelta + maxDelta)) / expectedPrice > maxPriceOffset)\n\t\t\t\trevert OverMaxPriceOffset();\n\t\t}\n\n\t\tuint256 currentPrice = _shortToUnderlying(1e18);\n\t\tuint256 delta = expectedPrice > currentPrice\n\t\t\t? expectedPrice - currentPrice\n\t\t\t: currentPrice - expectedPrice;\n\t\tif (delta > maxDelta) revert SlippageExceeded();\n\t\t_;\n\t}\n\n\tfunction __IMX_init_(\n\t\taddress vault_,\n\t\taddress underlying_,\n\t\taddress short_,\n\t\tuint256 maxTvl_\n\t) internal onlyInitializing {\n\t\tvault = vault_;\n\t\t_underlying = IERC20(underlying_);\n\t\t_short = IERC20(short_);\n\n\t\t// _underlying.safeApprove(vault, type(uint256).max);\n\n\t\t// init default params\n\t\t// deployer is not owner so we set these manually\n\t\t_maxTvl = maxTvl_;\n\t\temit SetMaxTvl(maxTvl_);\n\n\t\t// TODO param?\n\t\trebalanceThreshold = 400;\n\t\temit SetRebalanceThreshold(400);\n\n\t\tmaxPriceOffset = .2e18;\n\t\temit SetMaxPriceOffset(maxPriceOffset);\n\n\t\t_safetyMarginSqrt = 1.140175425e18;\n\t\temit SetSafetyMarginSqrt(_safetyMarginSqrt);\n\t}\n\n\t// guardian can adjust max price offset if needed\n\tfunction setMaxPriceOffset(uint256 _maxPriceOffset) public onlyRole(GUARDIAN) {\n\t\tmaxPriceOffset = _maxPriceOffset;\n\t\temit SetMaxPriceOffset(_maxPriceOffset);\n\t}\n\n\tfunction safetyMarginSqrt() public view override returns (uint256) {\n\t\treturn _safetyMarginSqrt;\n\t}\n\n\tfunction decimals() public view returns (uint8) {\n\t\treturn IERC20Metadata(address(_underlying)).decimals();\n\t}\n\n\t// OWNER CONFIG\n\n\tfunction setRebalanceThreshold(uint16 rebalanceThreshold_) public onlyOwner {\n\t\trequire(rebalanceThreshold_ >= 100, \"HLP: BAD_INPUT\");\n\t\trebalanceThreshold = rebalanceThreshold_;\n\t\temit SetRebalanceThreshold(rebalanceThreshold_);\n\t}\n\n\tfunction setSafetyMarginSqrt(uint256 safetyMarginSqrt_) public onlyOwner {\n\t\t_safetyMarginSqrt = safetyMarginSqrt_;\n\t\temit SetSafetyMarginSqrt(_safetyMarginSqrt);\n\t}\n\n\tfunction setMaxTvl(uint256 maxTvl_) public onlyRole(GUARDIAN) {\n\t\t_maxTvl = maxTvl_;\n\t\temit SetMaxTvl(maxTvl_);\n\t}\n\n\t// PUBLIC METHODS\n\n\tfunction short() public view override returns (IERC20) {\n\t\treturn _short;\n\t}\n\n\tfunction underlying() public view override returns (IERC20) {\n\t\treturn _underlying;\n\t}\n\n\t// deposit underlying and recieve lp tokens\n\tfunction deposit(uint256 underlyingAmnt) external onlyVault nonReentrant returns (uint256) {\n\t\tif (underlyingAmnt == 0) return 0; // cannot deposit 0\n\t\t// deposit is already included in tvl\n\t\tuint256 tvl = getAndUpdateTVL();\n\t\trequire(tvl <= getMaxTvl(), \"STRAT: OVER_MAX_TVL\");\n\t\tuint256 startBalance = collateralToken().balanceOf(address(this));\n\t\t_increasePosition(underlyingAmnt);\n\t\tuint256 endBalance = collateralToken().balanceOf(address(this));\n\t\treturn endBalance - startBalance;\n\t}\n\n\t// redeem lp for underlying\n\tfunction redeem(uint256 removeCollateral, address recipient)\n\t\tpublic\n\t\tonlyVault\n\t\treturns (uint256 amountTokenOut)\n\t{\n\t\t// this is the full amount of LP tokens totalSupply of shares is entitled to\n\t\t_decreasePosition(removeCollateral);\n\n\t\t// TODO make sure we never have any extra underlying dust sitting around\n\t\t// all 'extra' underlying should allways be transferred back to the vault\n\n\t\tunchecked {\n\t\t\tamountTokenOut = _underlying.balanceOf(address(this));\n\t\t}\n\t\t_underlying.safeTransfer(recipient, amountTokenOut);\n\t\temit Redeem(msg.sender, amountTokenOut);\n\t}\n\n\t/// @notice decreases position based to desired LP amount\n\t/// @dev ** does not rebalance remaining portfolio\n\t/// @param removeCollateral amount of callateral token to remove\n\tfunction _decreasePosition(uint256 removeCollateral) internal {\n\t\t(uint256 uBorrowBalance, uint256 sBorrowBalance) = _updateAndGetBorrowBalances();\n\n\t\tuint256 balance = collateralToken().balanceOf(address(this));\n\t\tuint256 lp = _getLiquidity(balance);\n\n\t\t// remove lp & repay underlying loan\n\t\t// round up to avoid under-repaying\n\t\tuint256 removeLp = lp.mulDivUp(removeCollateral, balance);\n\t\tuint256 uRepay = uBorrowBalance.mulDivUp(removeCollateral, balance);\n\t\tuint256 sRepay = sBorrowBalance.mulDivUp(removeCollateral, balance);\n\n\t\t_removeIMXLiquidity(removeLp, uRepay, sRepay);\n\t}\n\n\t// increases the position based on current desired balance\n\t// ** does not rebalance remaining portfolio\n\tfunction _increasePosition(uint256 amntUnderlying) internal {\n\t\tif (amntUnderlying < MINIMUM_LIQUIDITY) return; // avoid imprecision\n\t\t(uint256 uLp, ) = _getLPBalances();\n\t\t(uint256 uBorrowBalance, uint256 sBorrowBalance) = _getBorrowBalances();\n\n\t\tuint256 tvl = getAndUpdateTVL() - amntUnderlying;\n\n\t\tuint256 uBorrow;\n\t\tuint256 sBorrow;\n\t\tuint256 aUddLp;\n\t\tuint256 sAddLp;\n\n\t\tif (tvl == 0) {\n\t\t\tuBorrow = (_optimalUBorrow() * amntUnderlying) / 1e18;\n\t\t\taUddLp = amntUnderlying + uBorrow;\n\t\t\tsBorrow = _underlyingToShort(aUddLp);\n\t\t\tsAddLp = sBorrow;\n\t\t} else {\n\t\t\t// if tvl > 0 we need to keep the exact proportions of current position\n\t\t\t// to ensure we have correct accounting independent of price moves\n\t\t\tuBorrow = (uBorrowBalance * amntUnderlying) / tvl;\n\t\t\taUddLp = (uLp * amntUnderlying) / tvl;\n\t\t\tsBorrow = (sBorrowBalance * amntUnderlying) / tvl;\n\t\t\tsAddLp = _underlyingToShort(aUddLp);\n\t\t}\n\n\t\t_addIMXLiquidity(aUddLp, sAddLp, uBorrow, sBorrow);\n\t}\n\n\t// use the return of the function to estimate pending harvest via staticCall\n\tfunction harvest(HarvestSwapParms calldata harvestParams)\n\t\texternal\n\t\tonlyRole(MANAGER)\n\t\tnonReentrant\n\t\treturns (uint256 farmHarvest)\n\t{\n\t\t(uint256 startTvl, , , , , ) = getTVL();\n\t\tfarmHarvest = _harvestFarm(harvestParams);\n\n\t\t// compound our lp position\n\t\t_increasePosition(_underlying.balanceOf(address(this)));\n\t\temit Harvest(startTvl);\n\t}\n\n\t// There is not a situation where we would need this\n\t// function rebalanceLoan() public {\n\t// \tuint256 tvl = getOracleTvl();\n\t// \tuint256 tvl1 = getTotalTVL();\n\n\t// \tuint256 uBorrow = (tvl * _optimalUBorrow()) / 1e18;\n\t// \t(uint256 uBorrowBalance, ) = _getBorrowBalances();\n\n\t// \tif (uBorrowBalance <= uBorrow) return;\n\t// \tuint256 uRepay = uBorrowBalance - uBorrow;\n\t// \t(uint256 uLp, ) = _getLPBalances();\n\n\t// \tuint256 lp = _getLiquidity();\n\n\t// \t// remove lp & repay underlying loan\n\t// \tuint256 removeLp = (lp * uRepay) / uLp;\n\t// \tuint256 sRepay = type(uint256).max;\n\t// \t_removeIMXLiquidity(removeLp, uRepay, sRepay);\n\t// }\n\n\tfunction rebalance(uint256 expectedPrice, uint256 maxDelta)\n\t\texternal\n\t\tonlyRole(MANAGER)\n\t\tcheckPrice(expectedPrice, maxDelta)\n\t\tnonReentrant\n\t{\n\t\t// call this first to ensure we use an updated borrowBalance when computing offset\n\t\tuint256 tvl = getAndUpdateTVL();\n\t\tuint256 positionOffset = getPositionOffset();\n\n\t\t// don't rebalance unless we exceeded the threshold\n\t\tif (positionOffset <= rebalanceThreshold) revert RebalanceThreshold();\n\n\t\tif (tvl == 0) return;\n\t\tuint256 targetUBorrow = (tvl * _optimalUBorrow()) / 1e18;\n\t\tuint256 targetUnderlyingLP = tvl + targetUBorrow;\n\n\t\t(uint256 underlyingLp, uint256 shortLP) = _getLPBalances();\n\t\tuint256 targetShortLp = _underlyingToShort(targetUnderlyingLP);\n\t\t(uint256 uBorrowBalance, uint256 sBorrowBalance) = _updateAndGetBorrowBalances();\n\n\t\t// TODO account for uBalance\n\t\t// uint256 uBalance = underlying().balanceOf(address(this));\n\n\t\tif (underlyingLp > targetUnderlyingLP) {\n\t\t\t// TODO: we may need to borrow underlying\n\n\t\t\tuint256 uRepay = uBorrowBalance > targetUBorrow ? uBorrowBalance - targetUBorrow : 0;\n\t\t\tuint256 sRepay = sBorrowBalance > targetShortLp ? sBorrowBalance - targetShortLp : 0;\n\n\t\t\t// TODO check this\n\t\t\tuint256 lp = _getLiquidity();\n\t\t\tuint256 removeLp = lp - (lp * targetUnderlyingLP) / underlyingLp;\n\t\t\t_removeIMXLiquidity(removeLp, uRepay, sRepay);\n\t\t} else if (targetUnderlyingLP > underlyingLp) {\n\t\t\tuint256 uBorrow = targetUBorrow > uBorrowBalance ? targetUBorrow - uBorrowBalance : 0;\n\t\t\tuint256 sBorrow = targetShortLp > sBorrowBalance ? targetShortLp - sBorrowBalance : 0;\n\n\t\t\t// extra underlying balance will get re-paid automatically\n\t\t\t_addIMXLiquidity(\n\t\t\t\ttargetUnderlyingLP - underlyingLp,\n\t\t\t\ttargetShortLp - shortLP,\n\t\t\t\tuBorrow,\n\t\t\t\tsBorrow\n\t\t\t);\n\t\t}\n\t\temit Rebalance(_shortToUnderlying(1e18), positionOffset, tvl);\n\t}\n\n\t// vault handles slippage\n\tfunction closePosition() public onlyVault returns (uint256 balance) {\n\t\t(uint256 uRepay, uint256 sRepay) = _updateAndGetBorrowBalances();\n\t\tuint256 removeLp = _getLiquidity();\n\t\t_removeIMXLiquidity(removeLp, uRepay, sRepay);\n\t\t// transfer funds to vault\n\t\tbalance = _underlying.balanceOf(address(this));\n\t\t_underlying.safeTransfer(vault, balance);\n\t}\n\n\t// TVL\n\n\tfunction getMaxTvl() public view returns (uint256) {\n\t\t(, uint256 sBorrow) = _getBorrowBalances();\n\t\tuint256 availableToBorrow = sBorrowable().totalSupply() - sBorrowable().totalBorrows();\n\t\treturn\n\t\t\tmin(\n\t\t\t\t_maxTvl,\n\t\t\t\t// adjust the availableToBorrow to account for leverage\n\t\t\t\t_shortToUnderlying(\n\t\t\t\t\tsBorrow + (availableToBorrow * 1e18) / (_optimalUBorrow() + 1e18)\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\t// TODO should we compute pending farm & lending rewards here?\n\tfunction getAndUpdateTVL() public returns (uint256 tvl) {\n\t\t(uint256 uBorrow, uint256 shortPosition) = _updateAndGetBorrowBalances();\n\t\tuint256 borrowBalance = _shortToUnderlying(shortPosition) + uBorrow;\n\t\tuint256 shortP = _short.balanceOf(address(this));\n\t\tuint256 shortBalance = shortP == 0\n\t\t\t? 0\n\t\t\t: _shortToUnderlying(_short.balanceOf(address(this)));\n\t\t(uint256 underlyingLp, ) = _getLPBalances();\n\t\tuint256 underlyingBalance = _underlying.balanceOf(address(this));\n\t\ttvl = underlyingLp * 2 - borrowBalance + underlyingBalance + shortBalance;\n\t}\n\n\tfunction getTotalTVL() public view returns (uint256 tvl) {\n\t\t(tvl, , , , , ) = getTVL();\n\t}\n\n\t/// THere is no situation where we would need this\n\t// function getOracleTvl() public returns (uint256 tvl) {\n\t// \t(uint256 underlyingBorrow, uint256 borrowPosition) = _updateAndGetBorrowBalances();\n\t// \tuint256 borrowBalance = _shortToUnderlyingOracle(borrowPosition) + underlyingBorrow;\n\n\t// \tuint256 shortPosition = _short.balanceOf(address(this));\n\t// \tuint256 shortBalance = shortPosition == 0 ? 0 : _shortToUnderlyingOracle(shortPosition);\n\n\t// \t(uint256 underlyingLp, uint256 shortLp) = _getLPBalances();\n\t// \tuint256 lpBalance = underlyingLp + _shortToUnderlyingOracle(shortLp);\n\t// \tuint256 underlyingBalance = _underlying.balanceOf(address(this));\n\n\t// \ttvl = lpBalance - borrowBalance + underlyingBalance + shortBalance;\n\t// }\n\n\tfunction getTVL()\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tuint256 tvl,\n\t\t\tuint256,\n\t\t\tuint256 borrowPosition,\n\t\t\tuint256 borrowBalance,\n\t\t\tuint256 lpBalance,\n\t\t\tuint256 underlyingBalance\n\t\t)\n\t{\n\t\tuint256 underlyingBorrow;\n\t\t(underlyingBorrow, borrowPosition) = _getBorrowBalances();\n\t\tborrowBalance = _shortToUnderlying(borrowPosition) + underlyingBorrow;\n\n\t\tuint256 shortPosition = _short.balanceOf(address(this));\n\t\tuint256 shortBalance = shortPosition == 0 ? 0 : _shortToUnderlying(shortPosition);\n\n\t\t(uint256 underlyingLp, uint256 shortLp) = _getLPBalances();\n\t\tlpBalance = underlyingLp + _shortToUnderlying(shortLp);\n\t\tunderlyingBalance = _underlying.balanceOf(address(this));\n\n\t\ttvl = lpBalance - borrowBalance + underlyingBalance + shortBalance;\n\t}\n\n\tfunction getPositionOffset() public view returns (uint256 positionOffset) {\n\t\t(, uint256 shortLp) = _getLPBalances();\n\t\t(, uint256 borrowBalance) = _getBorrowBalances();\n\t\tuint256 shortBalance = shortLp + _short.balanceOf(address(this));\n\t\tif (shortBalance == borrowBalance) return 0;\n\t\t// if short lp > 0 and borrowBalance is 0 we are off by inf, returning 100% should be enough\n\t\tif (borrowBalance == 0) return 10000;\n\t\t// this is the % by which our position has moved from beeing balanced\n\n\t\tpositionOffset = shortBalance > borrowBalance\n\t\t\t? ((shortBalance - borrowBalance) * BPS_ADJUST) / borrowBalance\n\t\t\t: ((borrowBalance - shortBalance) * BPS_ADJUST) / borrowBalance;\n\t}\n\n\t// UTILS\n\tfunction getExpectedPrice() external view returns (uint256) {\n\t\treturn _shortToUnderlying(1e18);\n\t}\n\n\tfunction getLPBalances() public view returns (uint256 underlyingLp, uint256 shortLp) {\n\t\treturn _getLPBalances();\n\t}\n\n\tfunction getLiquidity() external view returns (uint256) {\n\t\treturn _getLiquidity();\n\t}\n\n\t// used to estimate price of collateral token in underlying\n\tfunction collateralToUnderlying() external view returns (uint256) {\n\t\t(uint256 uR, uint256 sR, ) = pair().getReserves();\n\t\t(uR, sR) = address(_underlying) == pair().token0() ? (uR, sR) : (sR, uR);\n\t\tuint256 lp = pair().totalSupply();\n\t\t// for deposit of 1 underlying we get 1+_optimalUBorrow worth of lp -> collateral token\n\t\treturn (1e18 * (uR * _getLiquidity(1e18))) / lp / (1e18 + _optimalUBorrow());\n\t}\n\n\t/**\n\t * @dev Returns the smallest of two numbers.\n\t */\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a < b ? a : b;\n\t}\n\n\terror RebalanceThreshold();\n\terror LowLoanHealth();\n\terror SlippageExceeded();\n\terror OverMaxPriceOffset();\n}\n"
    },
    "src/strategies/imx/IMXFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ICollateral, IPoolToken, IBorrowable, ImpermaxChef } from \"../../interfaces/imx/IImpermax.sol\";\nimport { HarvestSwapParms, IIMXFarmU, IERC20, SafeERC20, IUniswapV2Pair, IUniswapV2Router01 } from \"../mixins/upgradable/IIMXFarmU.sol\";\nimport { UniUtils } from \"../../libraries/UniUtils.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { CallType, CalleeData, AddLiquidityAndMintCalldata, BorrowBCalldata, RemoveLiqAndRepayCalldata } from \"../../interfaces/Structs.sol\";\n\nimport \"hardhat/console.sol\";\n\nabstract contract IMXFarm is Initializable, IIMXFarmU {\n\tusing SafeERC20 for IERC20;\n\tusing UniUtils for IUniswapV2Pair;\n\t// using FixedPointMathLib for uint256;\n\n\tIUniswapV2Pair public _pair;\n\tICollateral private _collateralToken;\n\tIBorrowable private _uBorrowable;\n\tIBorrowable private _sBorrowable;\n\tIPoolToken private stakedToken;\n\tImpermaxChef private _impermaxChef;\n\n\tIERC20 private _farmToken;\n\tIUniswapV2Router01 private _farmRouter;\n\n\tbool public flip;\n\n\tfunction __IMXFarm_init_(\n\t\taddress underlying_,\n\t\taddress pair_,\n\t\taddress collateralToken_,\n\t\taddress farmRouter_,\n\t\taddress farmToken_\n\t) internal onlyInitializing {\n\t\t_pair = IUniswapV2Pair(pair_);\n\t\t_collateralToken = ICollateral(collateralToken_);\n\t\t_uBorrowable = IBorrowable(_collateralToken.borrowable0());\n\t\t_sBorrowable = IBorrowable(_collateralToken.borrowable1());\n\n\t\tif (underlying_ != _uBorrowable.underlying()) {\n\t\t\tflip = true;\n\t\t\t(_uBorrowable, _sBorrowable) = (_sBorrowable, _uBorrowable);\n\t\t}\n\t\tstakedToken = IPoolToken(_collateralToken.underlying());\n\t\t_impermaxChef = ImpermaxChef(_uBorrowable.borrowTracker());\n\t\t_farmToken = IERC20(farmToken_);\n\t\t_farmRouter = IUniswapV2Router01(farmRouter_);\n\n\t\t// necessary farm approvals\n\t\t_farmToken.safeApprove(address(farmRouter_), type(uint256).max);\n\t}\n\n\tfunction impermaxChef() public view override returns (ImpermaxChef) {\n\t\treturn _impermaxChef;\n\t}\n\n\tfunction collateralToken() public view override returns (ICollateral) {\n\t\treturn _collateralToken;\n\t}\n\n\tfunction sBorrowable() public view override returns (IBorrowable) {\n\t\treturn _sBorrowable;\n\t}\n\n\tfunction uBorrowable() public view override returns (IBorrowable) {\n\t\treturn _uBorrowable;\n\t}\n\n\tfunction farmRouter() public view override returns (IUniswapV2Router01) {\n\t\treturn _farmRouter;\n\t}\n\n\tfunction pair() public view override returns (IUniswapV2Pair) {\n\t\treturn _pair;\n\t}\n\n\tfunction _addIMXLiquidity(\n\t\tuint256 underlyingAmnt,\n\t\tuint256 shortAmnt,\n\t\tuint256 uBorrow,\n\t\tuint256 sBorrow\n\t) internal virtual override {\n\t\t_sBorrowable.borrowApprove(address(_sBorrowable), sBorrow);\n\n\t\t// mint collateral\n\t\tbytes memory addLPData = abi.encode(\n\t\t\tCalleeData({\n\t\t\t\tcallType: CallType.ADD_LIQUIDITY_AND_MINT,\n\t\t\t\tdata: abi.encode(\n\t\t\t\t\tAddLiquidityAndMintCalldata({ uAmnt: underlyingAmnt, sAmnt: shortAmnt })\n\t\t\t\t)\n\t\t\t})\n\t\t);\n\n\t\t// borrow short data\n\t\tbytes memory borrowSData = abi.encode(\n\t\t\tCalleeData({\n\t\t\t\tcallType: CallType.BORROWB,\n\t\t\t\tdata: abi.encode(BorrowBCalldata({ borrowAmount: uBorrow, data: addLPData }))\n\t\t\t})\n\t\t);\n\n\t\t// flashloan borrow then add lp\n\t\t_sBorrowable.borrow(address(this), address(this), sBorrow, borrowSData);\n\t}\n\n\tfunction impermaxBorrow(\n\t\taddress,\n\t\taddress,\n\t\tuint256,\n\t\tbytes calldata data\n\t) public {\n\t\t// ensure that msg.sender is correct\n\t\trequire(\n\t\t\tmsg.sender == address(_sBorrowable) || msg.sender == address(_uBorrowable),\n\t\t\t\"IMXFarm: NOT_BORROWABLE\"\n\t\t);\n\t\tCalleeData memory calleeData = abi.decode(data, (CalleeData));\n\n\t\tif (calleeData.callType == CallType.ADD_LIQUIDITY_AND_MINT) {\n\t\t\tAddLiquidityAndMintCalldata memory d = abi.decode(\n\t\t\t\tcalleeData.data,\n\t\t\t\t(AddLiquidityAndMintCalldata)\n\t\t\t);\n\t\t\t_addLp(d.uAmnt, d.sAmnt);\n\t\t} else if (calleeData.callType == CallType.BORROWB) {\n\t\t\tBorrowBCalldata memory d = abi.decode(calleeData.data, (BorrowBCalldata));\n\t\t\t_uBorrowable.borrow(address(this), address(this), d.borrowAmount, d.data);\n\t\t}\n\t}\n\n\tfunction _addLp(uint256 uAmnt, uint256 sAmnt) internal {\n\t\t{\n\t\t\tuint256 sBalance = short().balanceOf(address(this));\n\t\t\tuint256 uBalance = underlying().balanceOf(address(this));\n\n\t\t\t// TODO use swap fee to get exact amount out\n\t\t\t// if we have extra short tokens, trade them for underlying\n\t\t\tif (sBalance > sAmnt) {\n\t\t\t\t// TODO edge case - not enough underlying?\n\t\t\t\tuBalance += pair()._swapExactTokensForTokens(\n\t\t\t\t\tsBalance - sAmnt,\n\t\t\t\t\taddress(short()),\n\t\t\t\t\taddress(underlying())\n\t\t\t\t);\n\t\t\t} else if (sAmnt > sBalance) {\n\t\t\t\tuBalance -= pair()._swapTokensForExactTokens(\n\t\t\t\t\tsAmnt - sBalance,\n\t\t\t\t\taddress(underlying()),\n\t\t\t\t\taddress(short())\n\t\t\t\t);\n\t\t\t}\n\t\t\t// we know that now our short balance is exact sBalance = sAmnt\n\t\t\t// if we don't have enough underlying, we need to decrase sAmnt slighlty\n\t\t\tif (uBalance < uAmnt) {\n\t\t\t\tuAmnt = uBalance;\n\t\t\t\tsAmnt = _underlyingToShort(uAmnt);\n\t\t\t} else if (uBalance > uAmnt) {\n\t\t\t\t// if we have extra underlying return to borrowable\n\t\t\t\t// TODO check that this gets accounted for\n\t\t\t\tunderlying().safeTransfer(address(_uBorrowable), uBalance - uAmnt);\n\t\t\t}\n\t\t}\n\n\t\tunderlying().safeTransfer(address(_pair), uAmnt);\n\t\tshort().safeTransfer(address(_pair), sAmnt);\n\n\t\tuint256 liquidity = _pair.mint(address(this));\n\n\t\t// first we create staked token, then collateral token\n\t\tIERC20(address(_pair)).safeTransfer(address(stakedToken), liquidity);\n\t\tstakedToken.mint(address(_collateralToken));\n\t\t_collateralToken.mint(address(this));\n\t}\n\n\tfunction _removeIMXLiquidity(\n\t\tuint256 removeLpAmnt,\n\t\tuint256 repayUnderlying,\n\t\tuint256 repayShort\n\t) internal override {\n\t\tuint256 redeemAmount = (removeLpAmnt * 1e18) / stakedToken.exchangeRate() + 1;\n\n\t\tbytes memory data = abi.encode(\n\t\t\tRemoveLiqAndRepayCalldata({\n\t\t\t\tremoveLpAmnt: removeLpAmnt,\n\t\t\t\trepayUnderlying: repayUnderlying,\n\t\t\t\trepayShort: repayShort\n\t\t\t})\n\t\t);\n\n\t\t_collateralToken.flashRedeem(address(this), redeemAmount, data);\n\t}\n\n\tfunction impermaxRedeem(\n\t\taddress,\n\t\tuint256 redeemAmount,\n\t\tbytes calldata data\n\t) public {\n\t\trequire(msg.sender == address(_collateralToken), \"IMXFarm: NOT_COLLATERAL\");\n\n\t\tRemoveLiqAndRepayCalldata memory d = abi.decode(data, (RemoveLiqAndRepayCalldata));\n\n\t\t// redeem withdrawn staked coins\n\t\tIERC20(address(stakedToken)).transfer(address(stakedToken), redeemAmount);\n\t\tstakedToken.redeem(address(this));\n\n\t\t// remove collateral\n\t\t(, uint256 shortAmnt) = _removeLiquidity(d.removeLpAmnt);\n\n\t\t// trade extra tokens\n\n\t\t// if we have extra short tokens, trade them for underlying\n\t\tif (shortAmnt > d.repayShort) {\n\t\t\t// TODO edge case - not enough underlying?\n\t\t\tpair()._swapExactTokensForTokens(\n\t\t\t\tshortAmnt - d.repayShort,\n\t\t\t\taddress(short()),\n\t\t\t\taddress(underlying())\n\t\t\t);\n\t\t\tshortAmnt = d.repayShort;\n\t\t}\n\t\t// if we know the exact amount of short we must repay, then ensure we have that amount\n\t\telse if (d.repayShort > shortAmnt && d.repayShort != type(uint256).max) {\n\t\t\tpair()._swapTokensForExactTokens(\n\t\t\t\td.repayShort - shortAmnt,\n\t\t\t\taddress(underlying()),\n\t\t\t\taddress(short())\n\t\t\t);\n\t\t\tshortAmnt = d.repayShort;\n\t\t}\n\n\t\tuint256 uBalance = underlying().balanceOf(address(this));\n\n\t\t// repay short loan\n\t\tshort().safeTransfer(address(_sBorrowable), shortAmnt);\n\t\t_sBorrowable.borrow(address(this), address(0), 0, new bytes(0));\n\n\t\t// repay underlying loan\n\t\tunderlying().safeTransfer(\n\t\t\taddress(_uBorrowable),\n\t\t\td.repayUnderlying > uBalance ? uBalance : d.repayUnderlying\n\t\t);\n\t\t_uBorrowable.borrow(address(this), address(0), 0, new bytes(0));\n\n\t\tuint256 cAmount = (redeemAmount * 1e18) / _collateralToken.exchangeRate() + 1;\n\n\t\t// uint256 colBal = _collateralToken.balanceOf(address(this));\n\t\t// TODO add tests to make ensure cAmount < colBal\n\n\t\t// return collateral token\n\t\tIERC20(address(_collateralToken)).transfer(\n\t\t\taddress(_collateralToken),\n\t\t\t// colBal < cAmount ? colBal : cAmount\n\t\t\tcAmount\n\t\t);\n\t}\n\n\tfunction pendingHarvest() external view override returns (uint256 harvested) {\n\t\tif (address(_impermaxChef) == address(0)) return 0;\n\t\tharvested =\n\t\t\t_impermaxChef.pendingReward(address(_sBorrowable), address(this)) +\n\t\t\t_impermaxChef.pendingReward(address(_uBorrowable), address(this));\n\t}\n\n\tfunction harvestIsEnabled() public view returns (bool) {\n\t\treturn address(_impermaxChef) != address(0);\n\t}\n\n\tfunction _harvestFarm(HarvestSwapParms calldata harvestParams)\n\t\tinternal\n\t\toverride\n\t\treturns (uint256 harvested)\n\t{\n\t\t// rewards are not enabled\n\t\tif (address(_impermaxChef) == address(0)) return 0;\n\t\taddress[] memory borrowables = new address[](2);\n\t\tborrowables[0] = address(_sBorrowable);\n\t\tborrowables[1] = address(_uBorrowable);\n\n\t\tconsole.log(\"chef\", address(_impermaxChef));\n\t\t_impermaxChef.massHarvest(borrowables, address(this));\n\n\t\tharvested = _farmToken.balanceOf(address(this));\n\t\tconsole.log(\"harvested\", harvested);\n\t\tif (harvested == 0) return harvested;\n\n\t\t_swap(_farmRouter, harvestParams, address(_farmToken), harvested);\n\t\temit HarvestedToken(address(_farmToken), harvested);\n\t}\n\n\tfunction _getLiquidity() internal view override returns (uint256) {\n\t\treturn _getLiquidity(_collateralToken.balanceOf(address(this)));\n\t}\n\n\tfunction _getLiquidity(uint256 balance) internal view override returns (uint256) {\n\t\tif (balance == 0) return 0;\n\t\treturn\n\t\t\t(stakedToken.exchangeRate() * (_collateralToken.exchangeRate() * (balance - 1))) /\n\t\t\t1e18 /\n\t\t\t1e18;\n\t}\n\n\tfunction _getBorrowBalances() internal view override returns (uint256, uint256) {\n\t\treturn (\n\t\t\t_uBorrowable.borrowBalance(address(this)),\n\t\t\t_sBorrowable.borrowBalance(address(this))\n\t\t);\n\t}\n\n\tfunction accrueInterest() public override {\n\t\t_sBorrowable.accrueInterest();\n\t\t_uBorrowable.accrueInterest();\n\t}\n\n\tfunction _updateAndGetBorrowBalances() internal override returns (uint256, uint256) {\n\t\taccrueInterest();\n\t\treturn _getBorrowBalances();\n\t}\n\n\t// borrow amount of underlying for every 1e18 of deposit\n\tfunction _optimalUBorrow() internal view override returns (uint256 uBorrow) {\n\t\tuint256 l = _collateralToken.liquidationIncentive();\n\t\t// this is the adjusted safety margin - how far we stay from liquidation\n\t\tuint256 s = (_collateralToken.safetyMarginSqrt() * safetyMarginSqrt()) / 1e18;\n\t\tuBorrow = (1e18 * (2e18 - (l * s) / 1e18)) / ((l * 1e18) / s + (l * s) / 1e18 - 2e18);\n\t}\n\n\tfunction loanHealth() public view override returns (uint256) {\n\t\tuint256 balance = IERC20(address(_collateralToken)).balanceOf(address(this));\n\t\tif (balance == 0) return 100e18;\n\t\tuint256 liq = (balance * _collateralToken.exchangeRate()) / 1e18;\n\t\t(uint256 available, uint256 shortfall) = _collateralToken.accountLiquidity(address(this));\n\t\treturn shortfall == 0 ? (1e18 * (liq + available)) / liq : (1e18 * (liq - shortfall)) / liq;\n\t}\n\n\tfunction _shortToUnderlyingOracle(uint256 amount) internal view override returns (uint256) {\n\t\t(uint256 price0, uint256 price1) = collateralToken().getPrices();\n\t\treturn flip ? (amount * price0) / price1 : (amount * price1) / price0;\n\t}\n\n\t// TODO RM - can do this in JS or in tests\n\t// function getIMXLiquidity() external view returns (uint256 leverage) {\n\t// \tuint256 collateral = (_collateralToken.exchangeRate() *\n\t// \t\t_collateralToken.balanceOf(address(this))) / 1e18;\n\n\t// \tuint256 amount0 = _uBorrowable.borrowBalance(address(this));\n\t// \tuint256 amount1 = _sBorrowable.borrowBalance(address(this));\n\n\t// \t(uint256 price0, uint256 price1) = _collateralToken.getPrices();\n\n\t// \tuint256 value0 = (amount0 * price0) / 1e18;\n\t// \tuint256 value1 = (amount1 * price1) / 1e18;\n\t// \tif (flip) (value0, value1) = (value1, value0);\n\n\t// \tleverage = (collateral * 1e18) / (collateral - value0 - value1 + 1);\n\t// \tconsole.log(\"leverage\", (collateral * 1e18) / (collateral - value0 - value1 + 1));\n\t// }\n}\n"
    },
    "src/interfaces/Structs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nenum CallType {\n\tADD_LIQUIDITY_AND_MINT,\n\tBORROWB,\n\tREMOVE_LIQ_AND_REPAY\n}\n\nenum NativeToken {\n\tNone,\n\tUnderlying,\n\tShort\n}\n\nstruct CalleeData {\n\tCallType callType;\n\tbytes data;\n}\nstruct AddLiquidityAndMintCalldata {\n\tuint256 uAmnt;\n\tuint256 sAmnt;\n}\nstruct BorrowBCalldata {\n\tuint256 borrowAmount;\n\tbytes data;\n}\nstruct RemoveLiqAndRepayCalldata {\n\tuint256 removeLpAmnt;\n\tuint256 repayUnderlying;\n\tuint256 repayShort;\n\t// uint256 amountAMin;\n\t// uint256 amountBMin;\n}\n\nstruct HarvestSwapParms {\n\taddress[] path; //path that the token takes\n\tuint256 min; // min price of in token * 1e18 (computed externally based on spot * slippage + fees)\n\tuint256 deadline;\n}\n\nstruct IMXConfig {\n\taddress vault;\n\taddress underlying;\n\taddress short;\n\taddress uniPair;\n\taddress poolToken;\n\taddress farmToken;\n\taddress farmRouter;\n\tuint256 maxTvl;\n\taddress owner;\n\taddress manager;\n\taddress guardian;\n}\n\nstruct HLPConfig {\n\tstring symbol;\n\tstring name;\n\taddress underlying;\n\taddress short;\n\taddress cTokenLend;\n\taddress cTokenBorrow;\n\taddress uniPair;\n\taddress uniFarm;\n\taddress farmToken;\n\tuint256 farmId;\n\taddress farmRouter;\n\taddress comptroller;\n\taddress lendRewardRouter;\n\taddress lendRewardToken;\n\taddress vault;\n\tuint256 maxTvl;\n\tNativeToken nativeToken;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "src/strategies/mixins/upgradable/IBaseU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport { HarvestSwapParms } from \"../../../interfaces/Structs.sol\";\n\nabstract contract IBaseU {\n\tfunction short() public view virtual returns (IERC20);\n\n\tfunction underlying() public view virtual returns (IERC20);\n}\n"
    },
    "src/strategies/mixins/upgradable/IIMXFarmU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport { IBorrowable, ICollateral, ImpermaxChef } from \"../../../interfaces/imx/IImpermax.sol\";\n\nimport { IBaseU, HarvestSwapParms } from \"./IBaseU.sol\";\nimport { IUniLpU, IUniswapV2Pair, SafeERC20, IERC20 } from \"./IUniLpU.sol\";\nimport { IFarmableU, IUniswapV2Router01 } from \"./IFarmableU.sol\";\n\nabstract contract IIMXFarmU is IBaseU, IFarmableU, IUniLpU {\n\tfunction loanHealth() public view virtual returns (uint256);\n\n\tfunction sBorrowable() public view virtual returns (IBorrowable);\n\n\tfunction uBorrowable() public view virtual returns (IBorrowable);\n\n\tfunction collateralToken() public view virtual returns (ICollateral);\n\n\tfunction impermaxChef() public view virtual returns (ImpermaxChef);\n\n\tfunction pendingHarvest() external view virtual returns (uint256 harvested);\n\n\tfunction farmRouter() public view virtual returns (IUniswapV2Router01);\n\n\tfunction _getBorrowBalances()\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (uint256 underlyingAmnt, uint256 shortAmnt);\n\n\tfunction _updateAndGetBorrowBalances()\n\t\tinternal\n\t\tvirtual\n\t\treturns (uint256 underlyingAmnt, uint256 shortAmnt);\n\n\tfunction _optimalUBorrow() internal view virtual returns (uint256 uBorrow);\n\n\tfunction _harvestFarm(HarvestSwapParms calldata swapParams) internal virtual returns (uint256);\n\n\tfunction safetyMarginSqrt() public view virtual returns (uint256);\n\n\tfunction accrueInterest() public virtual;\n\n\tfunction _addIMXLiquidity(\n\t\tuint256 underlyingAmnt,\n\t\tuint256 shortAmnt,\n\t\tuint256 uBorrow,\n\t\tuint256 sBorrow\n\t) internal virtual;\n\n\tfunction _removeIMXLiquidity(\n\t\tuint256 removeLp,\n\t\tuint256 repayUnderlying,\n\t\tuint256 repayShort\n\t) internal virtual;\n\n\tfunction _shortToUnderlyingOracle(uint256 amount) internal view virtual returns (uint256);\n}\n"
    },
    "src/libraries/UniUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\nimport \"../interfaces/uniswap/IUniswapV2Pair.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Router01.sol\";\nimport \"../interfaces/uniswap/IUniswapV2Factory.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nlibrary UniUtils {\n\tusing SafeERC20 for IERC20;\n\n\tfunction _getPairTokens(IUniswapV2Pair pair) internal view returns (address, address) {\n\t\treturn (pair.token0(), pair.token1());\n\t}\n\n\tfunction _getPairReserves(\n\t\tIUniswapV2Pair pair,\n\t\taddress tokenA,\n\t\taddress tokenB\n\t) internal view returns (uint256 reserveA, uint256 reserveB) {\n\t\t(address token0, ) = _sortTokens(tokenA, tokenB);\n\t\t(uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\t\t(reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n\t}\n\n\t// given some amount of an asset and lp reserves, returns an equivalent amount of the other asset\n\tfunction _quote(\n\t\tuint256 amountA,\n\t\tuint256 reserveA,\n\t\tuint256 reserveB\n\t) internal pure returns (uint256 amountB) {\n\t\trequire(amountA > 0, \"UniUtils: INSUFFICIENT_AMOUNT\");\n\t\trequire(reserveA > 0 && reserveB > 0, \"UniUtils: INSUFFICIENT_LIQUIDITY\");\n\t\tamountB = (amountA * reserveB) / reserveA;\n\t}\n\n\tfunction _sortTokens(address tokenA, address tokenB)\n\t\tinternal\n\t\tpure\n\t\treturns (address token0, address token1)\n\t{\n\t\trequire(tokenA != tokenB, \"UniUtils: IDENTICAL_ADDRESSES\");\n\t\t(token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n\t\trequire(token0 != address(0), \"UniUtils: ZERO_ADDRESS\");\n\t}\n\n\tfunction _getAmountOut(\n\t\tIUniswapV2Pair pair,\n\t\tuint256 amountIn,\n\t\taddress inToken,\n\t\taddress outToken\n\t) internal view returns (uint256 amountOut) {\n\t\trequire(amountIn > 0, \"UniUtils: INSUFFICIENT_INPUT_AMOUNT\");\n\t\t(uint256 reserveIn, uint256 reserveOut) = _getPairReserves(pair, inToken, outToken);\n\t\tuint256 amountInWithFee = amountIn * 997;\n\t\tuint256 numerator = amountInWithFee * reserveOut;\n\t\tuint256 denominator = reserveIn * 1000 + amountInWithFee;\n\t\tamountOut = numerator / denominator;\n\t}\n\n\tfunction _getAmountIn(\n\t\tIUniswapV2Pair pair,\n\t\tuint256 amountOut,\n\t\taddress inToken,\n\t\taddress outToken\n\t) internal view returns (uint256 amountIn) {\n\t\trequire(amountOut > 0, \"UniUtils: INSUFFICIENT_OUTPUT_AMOUNT\");\n\t\t(uint256 reserveIn, uint256 reserveOut) = _getPairReserves(pair, inToken, outToken);\n\t\tuint256 numerator = reserveIn * amountOut * 1000;\n\t\tuint256 denominator = (reserveOut - amountOut) * 997;\n\t\tamountIn = (numerator / denominator) + 1;\n\t}\n\n\tfunction _swapExactTokensForTokens(\n\t\tIUniswapV2Pair pair,\n\t\tuint256 amountIn,\n\t\taddress inToken,\n\t\taddress outToken\n\t) internal returns (uint256) {\n\t\tuint256 amountOut = _getAmountOut(pair, amountIn, inToken, outToken);\n\t\tif (amountOut == 0) return 0;\n\t\t(address token0, ) = _sortTokens(outToken, inToken);\n\t\t(uint256 amount0Out, uint256 amount1Out) = inToken == token0\n\t\t\t? (uint256(0), amountOut)\n\t\t\t: (amountOut, uint256(0));\n\n\t\tIERC20(inToken).safeTransfer(address(pair), amountIn);\n\t\tpair.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\t\treturn amountOut;\n\t}\n\n\tfunction _swapTokensForExactTokens(\n\t\tIUniswapV2Pair pair,\n\t\tuint256 amountOut,\n\t\taddress inToken,\n\t\taddress outToken\n\t) internal returns (uint256) {\n\t\tuint256 amountIn = _getAmountIn(pair, amountOut, inToken, outToken);\n\t\t(address token0, ) = _sortTokens(outToken, inToken);\n\t\t(uint256 amount0Out, uint256 amount1Out) = inToken == token0\n\t\t\t? (uint256(0), amountOut)\n\t\t\t: (amountOut, uint256(0));\n\n\t\tIERC20(inToken).safeTransfer(address(pair), amountIn);\n\t\tpair.swap(amount0Out, amount1Out, address(this), new bytes(0));\n\t\treturn amountIn;\n\t}\n}\n"
    },
    "src/strategies/imx/IMXAuthU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20Upgradeable as SafeERC20, IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { SafeETH } from \"../../libraries/SafeETH.sol\";\n\nimport { AuthU } from \"../../common/AuthU.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract IMXAuthU is AuthU {\n\tusing SafeERC20 for IERC20;\n\n\taddress public vault;\n\n\tmodifier onlyVault() {\n\t\trequire(msg.sender == vault, \"Strat: ONLY_VAULT\");\n\t\t_;\n\t}\n\n\tevent EmergencyWithdraw(address indexed recipient, IERC20[] tokens);\n\n\t// emergency only - send stuck tokens to the owner\n\t// TODO make arbitrary calls from owner?\n\tfunction emergencyWithdraw(address recipient, IERC20[] calldata tokens)\n\t\texternal\n\t\tonlyRole(GUARDIAN)\n\t{\n\t\tfor (uint256 i = 0; i < tokens.length; i++) {\n\t\t\tIERC20 token = tokens[i];\n\t\t\tuint256 balance = token.balanceOf(address(this));\n\t\t\tif (balance != 0) token.safeTransfer(recipient, balance);\n\t\t}\n\t\tif (address(this).balance > 0) SafeETH.safeTransferETH(recipient, address(this).balance);\n\t\temit EmergencyWithdraw(recipient, tokens);\n\t}\n\n\tuint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/interfaces/imx/IImpermax.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\ninterface IMXRouter2 {\n\tfunction mint(\n\t\taddress collateralToken,\n\t\tuint256 amount,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 tokens);\n\n\tfunction borrow(\n\t\taddress borrowable,\n\t\tuint256 amount,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbytes memory permitData\n\t) external;\n\n\tfunction borrowETH(\n\t\taddress borrowable,\n\t\tuint256 amountETH,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbytes memory permitData\n\t) external;\n}\n\ninterface IPoolToken {\n\tfunction totalBalance() external view returns (uint256);\n\n\tfunction mint(address minter) external returns (uint256 mintTokens);\n\n\tfunction underlying() external view returns (address);\n\n\tfunction exchangeRate() external view returns (uint256);\n\n\tfunction redeem(address redeemer) external returns (uint256 redeemAmount);\n}\n\ninterface IBorrowable {\n\tfunction borrow(\n\t\taddress borrower,\n\t\taddress receiver,\n\t\tuint256 borrowAmount,\n\t\tbytes calldata data\n\t) external;\n\n\tfunction borrowApprove(address spender, uint256 value) external returns (bool);\n\n\tfunction accrueInterest() external;\n\n\tfunction borrowBalance(address borrower) external view returns (uint256);\n\n\tfunction underlying() external view returns (address);\n\n\tfunction exchangeRate() external returns (uint256);\n\n\tfunction exchangeRateLast() external view returns (uint256);\n\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction totalBorrows() external view returns (uint256);\n\n\tfunction borrowTracker() external view returns (address);\n}\n\ninterface ICollateral {\n\tfunction safetyMarginSqrt() external view returns (uint256);\n\n\tfunction liquidationIncentive() external view returns (uint256);\n\n\tfunction underlying() external view returns (address);\n\n\tfunction borrowable0() external view returns (address);\n\n\tfunction borrowable1() external view returns (address);\n\n\tfunction accountLiquidity(address account)\n\t\texternal\n\t\tview\n\t\treturns (uint256 liquidity, uint256 shortfall);\n\n\tfunction flashRedeem(\n\t\taddress redeemer,\n\t\tuint256 redeemAmount,\n\t\tbytes calldata data\n\t) external;\n\n\tfunction mint(address minter) external returns (uint256 mintTokens);\n\n\tfunction exchangeRate() external view returns (uint256);\n\n\tfunction getPrices() external view returns (uint256 price0, uint256 price1);\n\n\tfunction balanceOf(address) external view returns (uint256);\n\n\tfunction getTwapPrice112x112() external view returns (uint224 twapPrice112x112);\n\n\tfunction simpleUniswapOracle() external view returns (address);\n\n\tfunction tarotPriceOracle() external view returns (address);\n}\n\ninterface ImpermaxChef {\n\tfunction pendingReward(address borrowable, address _user) external view returns (uint256);\n\n\tfunction harvest(address borrowable, address to) external;\n\n\tfunction massHarvest(address[] calldata borrowables, address to) external;\n}\n"
    },
    "src/strategies/mixins/upgradable/IUniLpU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20Upgradeable as SafeERC20, IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { IUniswapV2Pair } from \"../../../interfaces/uniswap/IUniswapV2Pair.sol\";\nimport { UniUtils } from \"../../../libraries/UniUtils.sol\";\n\nimport { IBaseU, HarvestSwapParms } from \"./IBaseU.sol\";\nimport { ILp } from \"../ILp.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract IUniLpU is IBaseU, ILp {\n\tusing SafeERC20 for IERC20;\n\tusing UniUtils for IUniswapV2Pair;\n\n\tfunction pair() public view virtual returns (IUniswapV2Pair);\n\n\tfunction _quote(\n\t\tuint256 amount,\n\t\taddress token0,\n\t\taddress token1\n\t) internal view virtual override returns (uint256 price) {\n\t\tif (amount == 0) return 0;\n\t\t(uint256 reserve0, uint256 reserve1) = pair()._getPairReserves(token0, token1);\n\t\tprice = UniUtils._quote(amount, reserve0, reserve1);\n\t}\n\n\t// should only be called after oracle or user-input swap price check\n\tfunction _addLiquidity(uint256 amountToken0, uint256 amountToken1)\n\t\tinternal\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256 liquidity)\n\t{\n\t\tunderlying().safeTransfer(address(pair()), amountToken0);\n\t\tshort().safeTransfer(address(pair()), amountToken1);\n\t\tliquidity = pair().mint(address(this));\n\t}\n\n\tfunction _removeLiquidity(uint256 liquidity)\n\t\tinternal\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256, uint256)\n\t{\n\t\tIERC20(address(pair())).safeTransfer(address(pair()), liquidity);\n\t\t(address tokenA, ) = UniUtils._sortTokens(address(underlying()), address(short()));\n\t\t(uint256 amountToken0, uint256 amountToken1) = pair().burn(address(this));\n\t\treturn\n\t\t\ttokenA == address(underlying())\n\t\t\t\t? (amountToken0, amountToken1)\n\t\t\t\t: (amountToken1, amountToken0);\n\t}\n\n\t// fetches and sorts the reserves for a uniswap pair\n\tfunction getUnderlyingShortReserves() public view returns (uint256 reserveA, uint256 reserveB) {\n\t\t(reserveA, reserveB) = pair()._getPairReserves(address(underlying()), address(short()));\n\t}\n\n\tfunction _getLPBalances()\n\t\tinternal\n\t\tview\n\t\toverride\n\t\treturns (uint256 underlyingBalance, uint256 shortBalance)\n\t{\n\t\tuint256 totalLp = _getLiquidity();\n\t\t(uint256 totalUnderlyingBalance, uint256 totalShortBalance) = getUnderlyingShortReserves();\n\t\tuint256 total = pair().totalSupply();\n\t\tunderlyingBalance = (totalUnderlyingBalance * totalLp) / total;\n\t\tshortBalance = (totalShortBalance * totalLp) / total;\n\t}\n\n\t// this is the current uniswap price\n\tfunction _shortToUnderlying(uint256 amount) internal view virtual returns (uint256) {\n\t\treturn amount == 0 ? 0 : _quote(amount, address(short()), address(underlying()));\n\t}\n\n\t// this is the current uniswap price\n\tfunction _underlyingToShort(uint256 amount) internal view virtual returns (uint256) {\n\t\treturn amount == 0 ? 0 : _quote(amount, address(underlying()), address(short()));\n\t}\n}\n"
    },
    "src/strategies/mixins/upgradable/IFarmableU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IUniswapV2Router01 } from \"../../../interfaces/uniswap/IUniswapV2Router01.sol\";\nimport { IBaseU, HarvestSwapParms } from \"./IBaseU.sol\";\n\nabstract contract IFarmableU is IBaseU {\n\tevent HarvestedToken(address indexed token, uint256 amount);\n\n\tfunction _swap(\n\t\tIUniswapV2Router01 router,\n\t\tHarvestSwapParms calldata swapParams,\n\t\taddress fromToken,\n\t\tuint256 amount\n\t) internal {\n\t\treturn _swapTo(router, swapParams, fromToken, amount, address(this));\n\t}\n\n\tfunction _swapTo(\n\t\tIUniswapV2Router01 router,\n\t\tHarvestSwapParms calldata swapParams,\n\t\taddress fromToken,\n\t\tuint256 amount,\n\t\taddress to\n\t) internal {\n\t\taddress out = swapParams.path[swapParams.path.length - 1];\n\t\t// ensure malicious harvester is not trading with wrong tokens\n\t\t// TODO should we add more validation to prevent malicious path?\n\t\trequire(\n\t\t\t((swapParams.path[0] == address(fromToken) && (out == address(short()))) ||\n\t\t\t\tout == address(underlying())),\n\t\t\t\"IFarmable: BAD_PATH\"\n\t\t);\n\t\trouter.swapExactTokensForTokens(\n\t\t\tamount,\n\t\t\tswapParams.min,\n\t\t\tswapParams.path, // optimal route determined externally\n\t\t\tto,\n\t\t\tswapParams.deadline\n\t\t);\n\t}\n}\n"
    },
    "src/interfaces/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IUniswapV2Pair {\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\tfunction name() external pure returns (string memory);\n\n\tfunction symbol() external pure returns (string memory);\n\n\tfunction decimals() external pure returns (uint8);\n\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction balanceOf(address owner) external view returns (uint256);\n\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\tfunction approve(address spender, uint256 value) external returns (bool);\n\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) external returns (bool);\n\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\n\tfunction nonces(address owner) external view returns (uint256);\n\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\tevent Mint(address indexed sender, uint256 amount0, uint256 amount1);\n\tevent Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n\tevent Swap(\n\t\taddress indexed sender,\n\t\tuint256 amount0In,\n\t\tuint256 amount1In,\n\t\tuint256 amount0Out,\n\t\tuint256 amount1Out,\n\t\taddress indexed to\n\t);\n\tevent Sync(uint112 reserve0, uint112 reserve1);\n\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n\tfunction factory() external view returns (address);\n\n\tfunction token0() external view returns (address);\n\n\tfunction token1() external view returns (address);\n\n\tfunction getReserves()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint112 reserve0,\n\t\t\tuint112 reserve1,\n\t\t\tuint32 blockTimestampLast\n\t\t);\n\n\tfunction price0CumulativeLast() external view returns (uint256);\n\n\tfunction price1CumulativeLast() external view returns (uint256);\n\n\tfunction kLast() external view returns (uint256);\n\n\tfunction mint(address to) external returns (uint256 liquidity);\n\n\tfunction burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n\tfunction swap(\n\t\tuint256 amount0Out,\n\t\tuint256 amount1Out,\n\t\taddress to,\n\t\tbytes calldata data\n\t) external;\n\n\tfunction skim(address to) external;\n\n\tfunction sync() external;\n\n\tfunction initialize(address, address) external;\n}\n"
    },
    "src/strategies/mixins/ILp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nabstract contract ILp {\n\tfunction _quote(\n\t\tuint256 amount,\n\t\taddress token0,\n\t\taddress token1\n\t) internal view virtual returns (uint256 price);\n\n\tfunction _getLiquidity() internal view virtual returns (uint256);\n\n\tfunction _getLiquidity(uint256) internal view virtual returns (uint256);\n\n\tfunction _addLiquidity(uint256 amountToken0, uint256 amountToken1)\n\t\tinternal\n\t\tvirtual\n\t\treturns (uint256 liquidity);\n\n\tfunction _removeLiquidity(uint256 liquidity) internal virtual returns (uint256, uint256);\n\n\tfunction _getLPBalances()\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (uint256 underlyingBalance, uint256 shortBalance);\n}\n"
    },
    "src/interfaces/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IUniswapV2Router01 {\n\tfunction factory() external pure returns (address);\n\n\tfunction WETH() external pure returns (address);\n\n\tfunction addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 amountADesired,\n\t\tuint256 amountBDesired,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t)\n\t\texternal\n\t\treturns (\n\t\t\tuint256 amountA,\n\t\t\tuint256 amountB,\n\t\t\tuint256 liquidity\n\t\t);\n\n\tfunction addLiquidityETH(\n\t\taddress token,\n\t\tuint256 amountTokenDesired,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t)\n\t\texternal\n\t\tpayable\n\t\treturns (\n\t\t\tuint256 amountToken,\n\t\t\tuint256 amountETH,\n\t\t\tuint256 liquidity\n\t\t);\n\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidity,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountA, uint256 amountB);\n\n\tfunction removeLiquidityETH(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256 amountToken, uint256 amountETH);\n\n\tfunction removeLiquidityWithPermit(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 liquidity,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint256 amountA, uint256 amountB);\n\n\tfunction removeLiquidityETHWithPermit(\n\t\taddress token,\n\t\tuint256 liquidity,\n\t\tuint256 amountTokenMin,\n\t\tuint256 amountETHMin,\n\t\taddress to,\n\t\tuint256 deadline,\n\t\tbool approveMax,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external returns (uint256 amountToken, uint256 amountETH);\n\n\tfunction swapExactTokensForTokens(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapTokensForExactTokens(\n\t\tuint256 amountOut,\n\t\tuint256 amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapExactETHForTokens(\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable returns (uint256[] memory amounts);\n\n\tfunction swapTokensForExactETH(\n\t\tuint256 amountOut,\n\t\tuint256 amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapExactTokensForETH(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external returns (uint256[] memory amounts);\n\n\tfunction swapETHForExactTokens(\n\t\tuint256 amountOut,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint256 deadline\n\t) external payable returns (uint256[] memory amounts);\n\n\tfunction quote(\n\t\tuint256 amountA,\n\t\tuint256 reserveA,\n\t\tuint256 reserveB\n\t) external pure returns (uint256 amountB);\n\n\tfunction getAmountOut(\n\t\tuint256 amountIn,\n\t\tuint256 reserveIn,\n\t\tuint256 reserveOut\n\t) external pure returns (uint256 amountOut);\n\n\tfunction getAmountIn(\n\t\tuint256 amountOut,\n\t\tuint256 reserveIn,\n\t\tuint256 reserveOut\n\t) external pure returns (uint256 amountIn);\n\n\tfunction getAmountsOut(uint256 amountIn, address[] calldata path)\n\t\texternal\n\t\tview\n\t\treturns (uint256[] memory amounts);\n\n\tfunction getAmountsIn(uint256 amountOut, address[] calldata path)\n\t\texternal\n\t\tview\n\t\treturns (uint256[] memory amounts);\n}\n"
    },
    "src/interfaces/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IUniswapV2Factory {\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n\tfunction feeTo() external view returns (address);\n\n\tfunction feeToSetter() external view returns (address);\n\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n\n\tfunction allPairs(uint256) external view returns (address pair);\n\n\tfunction allPairsLength() external view returns (uint256);\n\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n\n\tfunction setFeeTo(address) external;\n\n\tfunction setFeeToSetter(address) external;\n}\n"
    },
    "src/common/AuthU.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { AuthConfig } from \"./Auth.sol\";\n\ncontract AuthU is AccessControlUpgradeable {\n\tevent OwnershipTransferInitiated(address owner, address pendingOwner);\n\tevent OwnershipTransferred(address oldOwner, address newOwner);\n\n\t////////// CONSTANTS //////////\n\n\t/// Update vault params, perform time-sensitive operations, set manager\n\tbytes32 public constant GUARDIAN = keccak256(\"GUARDIAN\");\n\n\t/// Hot-wallet bots that route funds between vaults, rebalance and harvest strategies\n\tbytes32 public constant MANAGER = keccak256(\"MANAGER\");\n\n\t/// Add and remove vaults and strategies and other critical operations behind timelock\n\t/// Default admin role\n\t/// There should only be one owner, so it is not a role\n\taddress public owner;\n\taddress public pendingOwner;\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"ONLY_OWNER\");\n\t\t_;\n\t}\n\n\t/// security no undefined constructor\n\tconstructor() {}\n\n\tfunction __Auth_init_(AuthConfig memory authConfig) public onlyInitializing {\n\t\t/// Set up the roles\n\t\t// owner can manage all roles\n\t\towner = authConfig.owner;\n\t\temit OwnershipTransferred(address(0), authConfig.owner);\n\n\t\t// TODO do we want cascading roles like this?\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, authConfig.owner);\n\t\t_grantRole(GUARDIAN, owner);\n\t\t_grantRole(GUARDIAN, authConfig.guardian);\n\t\t_grantRole(MANAGER, authConfig.owner);\n\t\t_grantRole(MANAGER, authConfig.guardian);\n\t\t_grantRole(MANAGER, authConfig.manager);\n\n\t\t/// Allow the guardian role to manage manager\n\t\t_setRoleAdmin(MANAGER, GUARDIAN);\n\t}\n\n\t// ----------- Ownership -----------\n\n\t/// @dev Init transfer of ownership of the contract to a new account (`_pendingOwner`).\n\t/// @param _pendingOwner pending owner of contract\n\t/// Can only be called by the current owner.\n\tfunction transferOwnership(address _pendingOwner) external onlyOwner {\n\t\tpendingOwner = _pendingOwner;\n\t\temit OwnershipTransferInitiated(owner, pendingOwner);\n\t}\n\n\t/// @dev Accept transfer of ownership of the contract.\n\t/// Can only be called by the pendingOwner.\n\tfunction acceptOwnership() external {\n\t\trequire(msg.sender == pendingOwner, \"ONLY_PENDING_OWNER\");\n\t\taddress oldOwner = owner;\n\t\towner = pendingOwner;\n\n\t\t// revoke the DEFAULT ADMIN ROLE from prev owner\n\t\t_revokeRole(DEFAULT_ADMIN_ROLE, oldOwner);\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, owner);\n\n\t\temit OwnershipTransferred(oldOwner, owner);\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/vaults/IMXVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { SCYStrategy, Strategy } from \"./scy/SCYStrategy.sol\";\nimport { IMX } from \"../strategies/imx/IMX.sol\";\nimport { SCYVault, IERC20 } from \"./scy/SCYVault.sol\";\nimport { AuthConfig, Auth } from \"../common/Auth.sol\";\nimport { FeeConfig, Fees } from \"../common/Fees.sol\";\n\ncontract IMXVault is SCYStrategy, SCYVault {\n\tconstructor(\n\t\tAuthConfig memory authConfig,\n\t\tFeeConfig memory feeConfig,\n\t\tStrategy memory _strategy\n\t) Auth(authConfig) Fees(feeConfig) SCYVault(_strategy) {}\n\n\tfunction _stratValidate() internal view override {\n\t\tif (\n\t\t\taddress(underlying) != address(IMX(strategy).underlying()) ||\n\t\t\tyieldToken != address(IMX(strategy).collateralToken())\n\t\t) revert InvalidStrategy();\n\t}\n\n\tfunction _stratDeposit(uint256 amount) internal override returns (uint256) {\n\t\treturn IMX(strategy).deposit(amount);\n\t}\n\n\tfunction _stratRedeem(address recipient, uint256 yeildTokenAmnt)\n\t\tinternal\n\t\toverride\n\t\treturns (uint256 amountOut, uint256 amntToTransfer)\n\t{\n\t\t// strategy doesn't transfer tokens to user\n\t\t// TODO it should?\n\t\tamountOut = IMX(strategy).redeem(yeildTokenAmnt, recipient);\n\t\tamntToTransfer = 0;\n\t}\n\n\tfunction _stratGetAndUpdateTvl() internal override returns (uint256) {\n\t\treturn IMX(strategy).getAndUpdateTVL();\n\t}\n\n\tfunction _strategyTvl() internal view override returns (uint256) {\n\t\treturn IMX(strategy).getTotalTVL();\n\t}\n\n\tfunction _stratClosePosition(uint256) internal override returns (uint256) {\n\t\treturn IMX(strategy).closePosition();\n\t}\n\n\tfunction _stratMaxTvl() internal view override returns (uint256) {\n\t\treturn IMX(strategy).getMaxTvl();\n\t}\n\n\tfunction _stratCollateralToUnderlying() internal view override returns (uint256) {\n\t\treturn IMX(strategy).collateralToUnderlying();\n\t}\n\n\tfunction _selfBalance(address token) internal view virtual override returns (uint256) {\n\t\tif (token == yieldToken) return IERC20(token).balanceOf(strategy);\n\t\treturn (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n\t}\n}\n"
    },
    "src/vaults/IMXLend.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { SCYStrategy, Strategy } from \"./scy/SCYStrategy.sol\";\nimport { IPoolToken, IBorrowable } from \"../interfaces/imx/IImpermax.sol\";\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SCYVault } from \"./scy/SCYVault.sol\";\nimport { SafeETH } from \"./../libraries/SafeETH.sol\";\nimport { AuthConfig, Auth } from \"../common/Auth.sol\";\nimport { FeeConfig, Fees } from \"../common/Fees.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract IMXLend is SCYStrategy, SCYVault {\n\tusing SafeERC20 for IERC20;\n\n\tconstructor(\n\t\tAuthConfig memory authConfig,\n\t\tFeeConfig memory feeConfig,\n\t\tStrategy memory _strategy\n\t) Auth(authConfig) Fees(feeConfig) SCYVault(_strategy) {}\n\n\tfunction _stratValidate() internal view override {\n\t\tif (\n\t\t\taddress(underlying) != IPoolToken(strategy).underlying() ||\n\t\t\tyieldToken != address(strategy)\n\t\t) revert InvalidStrategy();\n\t}\n\n\tfunction _stratDeposit(uint256) internal override returns (uint256) {\n\t\treturn IPoolToken(strategy).mint(address(this));\n\t}\n\n\tfunction _stratRedeem(address to, uint256 amount)\n\t\tinternal\n\t\toverride\n\t\treturns (uint256 amountOut, uint256 amntToTransfer)\n\t{\n\t\tIERC20(yieldToken).safeTransfer(strategy, amount);\n\t\tamntToTransfer = 0;\n\t\tamountOut = IPoolToken(strategy).redeem(to);\n\t}\n\n\tfunction _stratGetAndUpdateTvl() internal override returns (uint256) {\n\t\t// exchange rate does the accrual\n\t\tuint256 exchangeRate = IBorrowable(strategy).exchangeRate();\n\t\tuint256 balance = IERC20(strategy).balanceOf(address(this));\n\t\tuint256 underlyingBalance = (balance * exchangeRate) / 1e18;\n\t\treturn underlyingBalance;\n\t}\n\n\tfunction _strategyTvl() internal view override returns (uint256) {\n\t\tuint256 balance = IERC20(strategy).balanceOf(address(this));\n\t\tuint256 exchangeRate = IBorrowable(strategy).exchangeRateLast();\n\t\tuint256 underlyingBalance = (balance * exchangeRate) / 1e18;\n\t\treturn underlyingBalance;\n\t}\n\n\tfunction _stratClosePosition(uint256) internal override returns (uint256) {\n\t\tuint256 yeildTokenAmnt = IERC20(strategy).balanceOf(address(this));\n\t\tIERC20(strategy).safeTransfer(strategy, yeildTokenAmnt);\n\t\treturn IPoolToken(strategy).redeem(address(this));\n\t}\n\n\t// TOOD fraction of total deposits\n\tfunction _stratMaxTvl() internal pure override returns (uint256) {\n\t\treturn type(uint256).max;\n\t}\n\n\tfunction _stratCollateralToUnderlying() internal view override returns (uint256) {\n\t\treturn IBorrowable(strategy).exchangeRateLast();\n\t}\n\n\tfunction getFloatingAmount(address token) public view override returns (uint256) {\n\t\tif (token == address(underlying))\n\t\t\treturn underlying.balanceOf(strategy) - IPoolToken(strategy).totalBalance();\n\t\treturn _selfBalance(token);\n\t}\n}\n"
    },
    "src/vaults/SectorVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC4626, FixedPointMathLib, SafeERC20, Fees, FeeConfig, Auth, AuthConfig } from \"./ERC4626/ERC4626.sol\";\nimport { ISCYStrategy } from \"../interfaces/scy/ISCYStrategy.sol\";\nimport { BatchedWithdraw } from \"./ERC4626/BatchedWithdraw.sol\";\nimport { SectorBase } from \"./SectorBase.sol\";\nimport \"../interfaces/MsgStructs.sol\";\n\nimport \"hardhat/console.sol\";\n// TODO native asset deposit + flow\n\nstruct RedeemParams {\n\tISCYStrategy strategy;\n\tuint256 shares;\n\tuint256 minTokenOut;\n}\n\nstruct DepositParams {\n\tISCYStrategy strategy;\n\tuint256 amountIn;\n\tuint256 minSharesOut;\n}\n\ncontract SectorVault is SectorBase {\n\tusing FixedPointMathLib for uint256;\n\tusing SafeERC20 for ERC20;\n\n\t/// if vaults accepts native asset we set asset to address 0;\n\taddress internal constant NATIVE = address(0);\n\n\tmapping(ISCYStrategy => bool) public strategyExists;\n\taddress[] public strategyIndex;\n\taddress[] public bridgeQueue;\n\tMessage[] internal depositQueue;\n\n\tuint256 public totalStrategyHoldings;\n\n\tconstructor(\n\t\tERC20 asset_,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\tAuthConfig memory authConfig,\n\t\tFeeConfig memory feeConfig\n\t) ERC4626(asset_, _name, _symbol) Auth(authConfig) Fees(feeConfig) BatchedWithdraw() {}\n\n\tfunction addStrategy(ISCYStrategy strategy) public onlyOwner {\n\t\tif (strategyExists[strategy]) revert StrategyExists();\n\n\t\t/// make sure underlying matches\n\t\tif (address(strategy.underlying()) != address(asset)) revert WrongUnderlying();\n\n\t\tstrategyExists[strategy] = true;\n\t\tstrategyIndex.push(address(strategy));\n\t\temit AddStrategy(address(strategy));\n\t}\n\n\tfunction removeStrategy(ISCYStrategy strategy) public onlyOwner {\n\t\tif (!strategyExists[strategy]) revert StrategyNotFound();\n\t\tstrategyExists[strategy] = false;\n\t\tuint256 length = strategyIndex.length;\n\t\t// replace current index with last strategy and pop the index array\n\t\tuint256 i;\n\t\tfor (i; i < length; ++i) if (address(strategy) == strategyIndex[i]) break;\n\t\tstrategyIndex[i] = strategyIndex[length - 1];\n\t\tstrategyIndex.pop();\n\t\temit RemoveStrategy(address(strategy));\n\t}\n\n\tfunction totalStrategies() external view returns (uint256) {\n\t\treturn strategyIndex.length;\n\t}\n\n\tfunction getAllStrategies() external view returns (address[] memory) {\n\t\treturn strategyIndex;\n\t}\n\n\t/// We compute expected tvl off-chain first, to ensure this transactions isn't sandwitched\n\tfunction harvest(uint256 expectedTvl, uint256 maxDelta) public onlyRole(MANAGER) {\n\t\tuint256 currentChildHoldings = _getStrategyHoldings();\n\t\tuint256 tvl = currentChildHoldings + floatAmnt;\n\t\t_checkSlippage(expectedTvl, tvl, maxDelta);\n\t\t// harvest event emitted here\n\t\t_harvest(currentChildHoldings);\n\t}\n\n\t/// this can be done in parts in case gas limit is reached\n\tfunction depositIntoStrategies(DepositParams[] calldata params) public onlyRole(MANAGER) {\n\t\tuint256 l = params.length;\n\t\tfor (uint256 i; i < l; ++i) {\n\t\t\tDepositParams memory param = params[i];\n\t\t\tuint256 amountIn = param.amountIn;\n\t\t\tif (amountIn == 0) continue;\n\t\t\tISCYStrategy strategy = param.strategy;\n\t\t\tif (!strategyExists[strategy]) revert StrategyNotFound();\n\t\t\t// update underlying float accouting\n\t\t\tbeforeWithdraw(amountIn, 0);\n\t\t\t/// push funds to avoid approvals\n\t\t\tasset.safeTransfer(strategy.strategy(), amountIn);\n\t\t\tstrategy.deposit(address(this), address(asset), 0, param.minSharesOut);\n\t\t\ttotalChildHoldings += amountIn;\n\t\t\temit DepositIntoStrategy(msg.sender, address(strategy), amountIn);\n\t\t}\n\t}\n\n\t/// this can be done in parts in case gas limit is reached\n\tfunction withdrawFromStrategies(RedeemParams[] calldata params) public onlyRole(MANAGER) {\n\t\tuint256 l = params.length;\n\t\tfor (uint256 i; i < l; ++i) {\n\t\t\tRedeemParams memory param = params[i];\n\t\t\tuint256 shares = param.shares;\n\t\t\tif (shares == 0) continue;\n\t\t\tISCYStrategy strategy = param.strategy;\n\t\t\tif (!strategyExists[strategy]) revert StrategyNotFound();\n\n\t\t\t// no need to push share tokens - contract can burn them\n\t\t\tuint256 amountOut = strategy.redeem(\n\t\t\t\taddress(this),\n\t\t\t\tshares,\n\t\t\t\taddress(asset), // token out is allways asset\n\t\t\t\tparam.minTokenOut\n\t\t\t);\n\t\t\ttotalChildHoldings -= amountOut;\n\t\t\t// update underlying float accounting\n\t\t\tafterDeposit(amountOut, 0);\n\t\t\temit WithdrawFromStrategy(msg.sender, address(strategy), amountOut);\n\t\t}\n\t}\n\n\tfunction emergencyRedeem() public {\n\t\tuint256 _totalSupply = totalSupply();\n\t\tuint256 shares = balanceOf(msg.sender);\n\t\tif (shares == 0) return;\n\t\t_burn(msg.sender, shares);\n\n\t\t// redeem proportional share of vault's underlying float balance\n\t\tuint256 underlyingShare = (floatAmnt * shares) / _totalSupply;\n\t\tbeforeWithdraw(underlyingShare, 0);\n\t\tasset.safeTransfer(msg.sender, underlyingShare);\n\n\t\tuint256 l = strategyIndex.length;\n\n\t\t// redeem proportional share of each strategy\n\t\tfor (uint256 i; i < l; ++i) {\n\t\t\tERC20 stratToken = ERC20(strategyIndex[i]);\n\t\t\tuint256 balance = stratToken.balanceOf(address(this));\n\t\t\tuint256 userShares = (shares * balance) / _totalSupply;\n\t\t\tif (userShares == 0) continue;\n\t\t\tstratToken.safeTransfer(msg.sender, userShares);\n\t\t}\n\t}\n\n\t/// gets accurate strategy holdings denominated in asset\n\tfunction _getStrategyHoldings() internal returns (uint256 tvl) {\n\t\tuint256 l = strategyIndex.length;\n\t\t/// TODO compute realistic limit for strategy array lengh to stay within gas limit\n\t\tfor (uint256 i; i < l; ++i) {\n\t\t\tISCYStrategy strategy = ISCYStrategy(payable(strategyIndex[i]));\n\t\t\ttvl += strategy.getUpdatedUnderlyingBalance(address(this));\n\t\t}\n\t}\n\n\t/// returns expected tvl (used for estimate)\n\tfunction getTvl() public view returns (uint256 tvl) {\n\t\tuint256 l = strategyIndex.length;\n\t\t// there should be no untrusted strategies in this array\n\t\tfor (uint256 i; i < l; ++i) {\n\t\t\tISCYStrategy strategy = ISCYStrategy(payable(strategyIndex[i]));\n\t\t\ttvl += strategy.underlyingBalance(address(this));\n\t\t}\n\t\ttvl += asset.balanceOf(address(this));\n\t}\n\n\tfunction totalAssets() public view virtual override returns (uint256) {\n\t\treturn floatAmnt + totalChildHoldings;\n\t}\n\n\t/// INTERFACE UTILS\n\n\t/// @dev returns accurate value used to estimate current value\n\tfunction estimateUnderlyingBalance(address user) external view returns (uint256) {\n\t\tuint256 shares = balanceOf(user);\n\t\t// value based on last harvest exchange rate\n\t\tuint256 cachedValue = convertToAssets(shares);\n\t\t// valued based on current tvl\n\t\tuint256 currentValue = sharesToUnderlying(shares);\n\t\treturn cachedValue > currentValue ? currentValue : cachedValue;\n\t}\n\n\t/// @dev current exchange rate (different from previewDeposit rate)\n\t/// this should be used for estiamtes of withdrawals\n\tfunction sharesToUnderlying(uint256 shares) public view returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\t\treturn supply == 0 ? shares : shares.mulDivDown(getTvl(), supply);\n\t}\n\n\t/// @dev current exchange rate (different from previewDeposit / previewWithdrawal rate)\n\t/// this should be used estimate of deposit fee\n\tfunction underlyingToShares(uint256 underlyingAmnt) public view returns (uint256) {\n\t\tuint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\t\treturn supply == 0 ? underlyingAmnt : underlyingAmnt.mulDivDown(supply, getTvl());\n\t}\n\n\t/*/////////////////////////////////////////////////////////\n\t\t\t\t\tCrossChain functionality\n\t/////////////////////////////////////////////////////////*/\n\n\tfunction _handleMessage(messageType _type, Message calldata _msg) internal override {\n\t\tif (_type == messageType.DEPOSIT) _receiveDeposit(_msg);\n\t\telse if (_type == messageType.HARVEST) _receiveHarvest(_msg);\n\t\telse if (_type == messageType.WITHDRAW) _receiveWithdraw(_msg);\n\t\telse if (_type == messageType.EMERGENCYWITHDRAW) _receiveEmergencyWithdraw(_msg);\n\t\telse revert NotImplemented();\n\t}\n\n\tfunction _receiveDeposit(Message calldata _msg) internal {\n\t\tdepositQueue.push(_msg);\n\t}\n\n\tfunction _receiveWithdraw(Message calldata _msg) internal {\n\t\tif (withdrawLedger[_msg.sender].value == 0) bridgeQueue.push(_msg.sender);\n\n\t\t/// value here is the fraction of the shares owned by the vault\n\t\t/// since the xVault doesn't know how many shares it holds\n\t\tuint256 xVaultShares = balanceOf(_msg.sender);\n\t\tuint256 shares = (_msg.value * xVaultShares) / 100;\n\t\trequestRedeem(shares, _msg.sender);\n\t}\n\n\tfunction _receiveEmergencyWithdraw(Message calldata _msg) internal {\n\t\tuint256 transferShares = (_msg.value * balanceOf(_msg.sender)) / 100;\n\n\t\t_transfer(_msg.sender, _msg.client, transferShares);\n\t\temit EmergencyWithdraw(_msg.sender, _msg.client, transferShares);\n\t}\n\n\t// TODO should it trigger harvest first?\n\tfunction _receiveHarvest(Message calldata _msg) internal {\n\t\tuint256 xVaultUnderlyingBalance = underlyingBalance(_msg.sender);\n\n\t\tVault memory vault = addrBook[_msg.sender];\n\t\t_sendMessage(\n\t\t\t_msg.sender,\n\t\t\tvault,\n\t\t\tMessage(xVaultUnderlyingBalance, address(this), address(0), chainId),\n\t\t\tmessageType.HARVEST\n\t\t);\n\t}\n\n\tfunction processIncomingXFunds() external override onlyRole(MANAGER) {\n\t\tuint256 length = depositQueue.length;\n\t\tuint256 totalDeposit = 0;\n\t\tfor (uint256 i = length; i > 0; ) {\n\t\t\tMessage memory _msg = depositQueue[i - 1];\n\t\t\tdepositQueue.pop();\n\n\t\t\tuint256 shares = previewDeposit(_msg.value);\n\t\t\t// lock minimum liquidity if totalSupply is 0\n\t\t\t// if i > 0 we can skip this\n\t\t\tif (i == 0 && totalSupply() == 0) {\n\t\t\t\tif (MIN_LIQUIDITY > shares) revert MinLiquidity();\n\t\t\t\tshares -= MIN_LIQUIDITY;\n\t\t\t\t_mint(address(1), MIN_LIQUIDITY);\n\t\t\t}\n\t\t\t_mint(_msg.sender, shares);\n\n\t\t\tunchecked {\n\t\t\t\ttotalDeposit += _msg.value;\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t// Should account for fees paid in tokens for using bridge\n\t\t// Also, if a value hasn't arrived manager will not be able to register any value\n\t\tif (totalDeposit > (asset.balanceOf(address(this)) - floatAmnt - pendingWithdraw))\n\t\t\trevert MissingIncomingXFunds();\n\n\t\t// update floatAmnt with deposited funds\n\t\tafterDeposit(totalDeposit, 0);\n\t\t/// TODO should we add more params here?\n\t\temit RegisterIncomingFunds(totalDeposit);\n\t}\n\n\t// Problem -> bridgeQueue has an order and request array has to follow this order\n\t// Maybe change how withdraws are saved?\n\tfunction processXWithdraw(Request[] calldata requests) external onlyRole(MANAGER) {\n\t\tuint256 length = bridgeQueue.length;\n\n\t\tuint256 total = 0;\n\t\tfor (uint256 i = length - 1; i > 0; ) {\n\t\t\taddress vAddr = bridgeQueue[i];\n\n\t\t\tif (requests[i].vaultAddr != vAddr) revert VaultAddressNotMatch();\n\n\t\t\t// this returns the underlying amount the vault is withdrawing\n\t\t\tuint256 amountOut = _xRedeem(vAddr);\n\t\t\tbridgeQueue.pop();\n\n\t\t\tVault memory vault = addrBook[vAddr];\n\t\t\t_sendMessage(\n\t\t\t\tvAddr,\n\t\t\t\tvault,\n\t\t\t\tMessage(amountOut, address(this), address(0), chainId),\n\t\t\t\tmessageType.WITHDRAW\n\t\t\t);\n\n\t\t\t_sendTokens(\n\t\t\t\tunderlying(),\n\t\t\t\trequests[i].allowanceTarget,\n\t\t\t\trequests[i].registry,\n\t\t\t\tvAddr,\n\t\t\t\tamountOut,\n\t\t\t\taddrBook[vAddr].chainId,\n\t\t\t\trequests[i].txData\n\t\t\t);\n\n\t\t\temit BridgeAsset(chainId, addrBook[vAddr].chainId, amountOut);\n\n\t\t\tunchecked {\n\t\t\t\ttotal += amountOut;\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tbeforeWithdraw(total, 0);\n\t}\n\n\terror VaultAddressNotMatch();\n\tevent AddStrategy(address indexed strategy);\n\tevent RemoveStrategy(address indexed strategy);\n\tevent DepositIntoStrategy(address caller, address strategy, uint256 amount);\n\tevent WithdrawFromStrategy(address caller, address strategy, uint256 amount);\n}\n"
    },
    "src/vaults/ERC4626/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { FixedPointMathLib } from \"../../libraries/FixedPointMathLib.sol\";\nimport { IERC4626 } from \"../../interfaces/ERC4626/IERC4626.sol\";\nimport { Accounting } from \"../../common/Accounting.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Auth, AuthConfig } from \"../../common/Auth.sol\";\nimport { Fees, FeeConfig } from \"../../common/Fees.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is Auth, Accounting, Fees, IERC4626, ERC20 {\n\tusing SafeERC20 for ERC20;\n\tusing FixedPointMathLib for uint256;\n\n\t/*//////////////////////////////////////////////////////////////\n                               CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n\t// locked liquidity to prevent rounding errors\n\tuint256 public constant MIN_LIQUIDITY = 1e3;\n\n\t/*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n\tERC20 immutable asset;\n\n\tconstructor(\n\t\tERC20 _asset,\n\t\tstring memory _name,\n\t\tstring memory _symbol\n\t) ERC20(_name, _symbol) {\n\t\tasset = _asset;\n\t}\n\n\tfunction decimals() public view override returns (uint8) {\n\t\treturn asset.decimals();\n\t}\n\n\tfunction totalAssets() public view virtual override returns (uint256) {\n\t\treturn asset.balanceOf(address(this));\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n\t\t// This check is no longer necessary because we use MIN_LIQUIDITY\n\t\t// Check for rounding error since we round down in previewDeposit.\n\t\t// require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\t\tshares = previewDeposit(assets);\n\n\t\t// Need to transfer before minting or ERC777s could reenter.\n\t\tasset.safeTransferFrom(msg.sender, address(this), assets);\n\n\t\t// lock minimum liquidity if totalSupply is 0\n\t\tif (totalSupply() == 0) {\n\t\t\tif (MIN_LIQUIDITY > shares) revert MinLiquidity();\n\t\t\tshares -= MIN_LIQUIDITY;\n\t\t\t_mint(address(1), MIN_LIQUIDITY);\n\t\t}\n\n\t\t_mint(receiver, shares);\n\n\t\temit Deposit(msg.sender, receiver, assets, shares);\n\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n\t\tassets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n\t\t// Need to transfer before minting or ERC777s could reenter.\n\t\tasset.safeTransferFrom(msg.sender, address(this), assets);\n\n\t\t_mint(receiver, shares);\n\n\t\temit Deposit(msg.sender, receiver, assets, shares);\n\n\t\tafterDeposit(assets, shares);\n\t}\n\n\tfunction withdraw(\n\t\tuint256 assets,\n\t\taddress receiver,\n\t\taddress owner\n\t) public virtual returns (uint256 shares) {\n\t\tshares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n\t\t// if not owner, allowance must be enforced\n\t\tif (msg.sender != owner) _spendAllowance(owner, msg.sender, shares);\n\n\t\tbeforeWithdraw(assets, shares);\n\n\t\t_burn(owner, shares);\n\n\t\temit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n\t\tasset.safeTransfer(receiver, assets);\n\t}\n\n\tfunction redeem(\n\t\tuint256 shares,\n\t\taddress receiver,\n\t\taddress owner\n\t) public virtual returns (uint256 assets) {\n\t\t// if not owner, allowance must be enforced\n\t\tif (msg.sender != owner) _spendAllowance(owner, msg.sender, shares);\n\n\t\t// This check is no longer necessary because we use MIN_LIQUIDITY\n\t\t// Check for rounding error since we round down in previewRedeem.\n\t\t// require((assets = previewRedeem(shares)) != 0, \"ZEROassetS\");\n\t\tassets = previewRedeem(shares);\n\n\t\tbeforeWithdraw(assets, shares);\n\n\t\t_burn(owner, shares);\n\n\t\temit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n\t\tasset.safeTransfer(receiver, assets);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction maxDeposit(address) public view virtual returns (uint256) {\n\t\treturn type(uint256).max;\n\t}\n\n\tfunction maxMint(address) public view virtual returns (uint256) {\n\t\treturn type(uint256).max;\n\t}\n\n\tfunction maxWithdraw(address owner) public view virtual returns (uint256) {\n\t\treturn convertToAssets(balanceOf(owner));\n\t}\n\n\tfunction maxRedeem(address owner) public view virtual returns (uint256) {\n\t\treturn balanceOf(owner);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n\tfunction afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n\n\t// OVERRIDES\n\tfunction totalSupply() public view override(Accounting, ERC20) returns (uint256) {\n\t\treturn ERC20.totalSupply();\n\t}\n\n\terror MinLiquidity();\n}\n"
    },
    "src/vaults/ERC4626/BatchedWithdraw.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC4626 } from \"./ERC4626.sol\";\n\nimport \"hardhat/console.sol\";\n\nstruct WithdrawRecord {\n\tuint256 timestamp;\n\tuint256 shares;\n\tuint256 value; // this the current value (also max withdraw value)\n}\n\nabstract contract BatchedWithdraw is ERC4626 {\n\tusing SafeERC20 for ERC20;\n\n\tevent RequestWithdraw(address indexed caller, address indexed owner, uint256 shares);\n\n\tuint256 public lastHarvestTimestamp;\n\tuint256 public pendingWithdraw; // actual amount may be less\n\n\tmapping(address => WithdrawRecord) public withdrawLedger;\n\n\tconstructor() {\n\t\tlastHarvestTimestamp = block.timestamp;\n\t}\n\n\tfunction requestRedeem(uint256 shares) public {\n\t\treturn requestRedeem(shares, msg.sender);\n\t}\n\n\tfunction requestRedeem(uint256 shares, address owner) public {\n\t\tif (msg.sender != owner) _spendAllowance(owner, msg.sender, shares);\n\t\t_transfer(owner, address(this), shares);\n\t\tWithdrawRecord storage withdrawRecord = withdrawLedger[msg.sender];\n\t\twithdrawRecord.timestamp = block.timestamp;\n\t\twithdrawRecord.shares += shares;\n\t\tuint256 value = convertToAssets(shares);\n\t\twithdrawRecord.value = value;\n\t\tpendingWithdraw += value;\n\t\temit RequestWithdraw(msg.sender, owner, shares);\n\t}\n\n\tfunction withdraw(\n\t\tuint256,\n\t\taddress,\n\t\taddress\n\t) public pure virtual override returns (uint256) {\n\t\trevert NotImplemented();\n\t}\n\n\tfunction redeem(\n\t\tuint256,\n\t\taddress receiver,\n\t\taddress\n\t) public virtual override returns (uint256 amountOut) {\n\t\treturn redeem(receiver);\n\t}\n\n\t/// @dev safest UI method\n\tfunction redeem() public virtual returns (uint256 amountOut) {\n\t\treturn redeem(msg.sender);\n\t}\n\n\tfunction redeem(address receiver) public virtual returns (uint256 amountOut) {\n\t\tuint256 shares;\n\t\t(amountOut, shares) = _redeem(msg.sender);\n\t\tERC20(asset).transfer(receiver, amountOut);\n\t\temit Withdraw(msg.sender, receiver, msg.sender, amountOut, shares);\n\t}\n\n\t/// @dev should only be called by manager on behalf of xVaults\n\tfunction _xRedeem(address xVault) internal virtual returns (uint256 amountOut) {\n\t\tuint256 shares;\n\t\t(amountOut, shares) = _redeem(xVault);\n\t\t_burn(address(this), shares);\n\t\temit Withdraw(xVault, xVault, xVault, amountOut, shares);\n\t}\n\n\tfunction _redeem(address account) internal returns (uint256 amountOut, uint256 shares) {\n\t\tWithdrawRecord storage withdrawRecord = withdrawLedger[account];\n\n\t\tif (withdrawRecord.value == 0) revert ZeroAmount();\n\t\tif (withdrawRecord.timestamp >= lastHarvestTimestamp) revert NotReady();\n\n\t\tshares = withdrawRecord.shares;\n\t\t// value of shares at time of redemption request\n\t\tuint256 redeemValue = withdrawRecord.value;\n\t\tuint256 currentValue = convertToAssets(shares);\n\n\t\t// actual amount out is the smaller of currentValue and redeemValue\n\t\tamountOut = currentValue < redeemValue ? currentValue : redeemValue;\n\n\t\t// update total pending withdraw\n\t\tpendingWithdraw -= redeemValue;\n\n\t\t// important pendingWithdraw should update prior to beforeWithdraw call\n\t\tbeforeWithdraw(amountOut, shares);\n\t\twithdrawRecord.value = 0;\n\t\t_burn(address(this), shares);\n\t}\n\n\tfunction cancelRedeem() public virtual {\n\t\tWithdrawRecord storage withdrawRecord = withdrawLedger[msg.sender];\n\n\t\tuint256 shares = withdrawRecord.shares;\n\t\t// value of shares at time of redemption request\n\t\tuint256 redeemValue = withdrawRecord.value;\n\t\tuint256 currentValue = convertToAssets(shares);\n\n\t\t// update accounting\n\t\twithdrawRecord.value = 0;\n\t\tpendingWithdraw -= redeemValue;\n\n\t\t// if vault lost money, shares stay the same\n\t\tif (currentValue < redeemValue) return _transfer(address(this), msg.sender, shares);\n\n\t\t// // if vault earned money, subtract earnings since withdrawal request\n\t\tuint256 sharesOut = (shares * redeemValue) / currentValue;\n\t\tuint256 sharesToBurn = shares - sharesOut;\n\n\t\t_transfer(address(this), msg.sender, sharesOut);\n\t\t_burn(address(this), sharesToBurn);\n\t}\n\n\t/// @notice UI method to view cancellation penalty\n\tfunction getPenalty() public view returns (uint256) {\n\t\tWithdrawRecord storage withdrawRecord = withdrawLedger[msg.sender];\n\t\tuint256 shares = withdrawRecord.shares;\n\n\t\tuint256 redeemValue = withdrawRecord.value;\n\t\tuint256 currentValue = convertToAssets(shares);\n\n\t\tif (currentValue < redeemValue) return 0;\n\t\treturn (1e18 * (currentValue - redeemValue)) / redeemValue;\n\t}\n\n\t/// UTILS\n\tfunction redeemIsReady(address user) external view returns (bool) {\n\t\tWithdrawRecord storage withdrawRecord = withdrawLedger[user];\n\t\treturn lastHarvestTimestamp > withdrawRecord.timestamp;\n\t}\n\n\tfunction getWithdrawStatus(address user) external view returns (WithdrawRecord memory) {\n\t\treturn withdrawLedger[user];\n\t}\n\n\terror Expired();\n\terror NotImplemented();\n\terror NotReady();\n\terror ZeroAmount();\n}\n"
    },
    "src/vaults/SectorBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC4626, FixedPointMathLib, SafeERC20 } from \"./ERC4626/ERC4626.sol\";\nimport { ISCYStrategy } from \"../interfaces/scy/ISCYStrategy.sol\";\nimport { BatchedWithdraw } from \"./ERC4626/BatchedWithdraw.sol\";\nimport { XChainIntegrator } from \"../common/XChainIntegrator.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/MsgStructs.sol\";\n\nimport \"hardhat/console.sol\";\n\nabstract contract SectorBase is BatchedWithdraw, XChainIntegrator {\n\tusing FixedPointMathLib for uint256;\n\tusing SafeERC20 for ERC20;\n\n\tevent Harvest(\n\t\taddress indexed treasury,\n\t\tuint256 underlyingProfit,\n\t\tuint256 performanceFee,\n\t\tuint256 managementFee,\n\t\tuint256 sharesFees,\n\t\tuint256 tvl\n\t);\n\n\tuint256 public totalChildHoldings;\n\tuint256 public floatAmnt; // amount of underlying tracked in vault\n\n\tfunction _harvest(uint256 currentChildHoldings) internal {\n\t\t// withdrawFromStrategies should be called prior to harvest to ensure this tx doesn't revert\n\t\tif (floatAmnt < pendingWithdraw) revert NotEnoughtFloat();\n\n\t\tuint256 profit = currentChildHoldings > totalChildHoldings\n\t\t\t? currentChildHoldings - totalChildHoldings\n\t\t\t: 0;\n\n\t\tuint256 timestamp = block.timestamp;\n\t\tuint256 tvl = currentChildHoldings + floatAmnt;\n\n\t\t// totalChildHoldings need to be updated before fees computation\n\t\ttotalChildHoldings = currentChildHoldings;\n\n\t\t// PROCESS VAULT FEES\n\t\tuint256 _performanceFee = profit == 0 ? 0 : (profit * performanceFee) / 1e18;\n\t\tuint256 _managementFee = managementFee == 0\n\t\t\t? 0\n\t\t\t: (managementFee * tvl * (timestamp - lastHarvestTimestamp)) / 1e18 / 365 days;\n\n\t\tuint256 totalFees = _performanceFee + _managementFee;\n\t\tuint256 feeShares;\n\n\t\tif (totalFees > 0) {\n\t\t\t// this results in more accurate accounting considering dilution\n\t\t\tfeeShares = totalFees.mulDivDown(totalSupply(), tvl - totalFees);\n\t\t\t_mint(treasury, feeShares);\n\t\t}\n\n\t\temit Harvest(treasury, profit, _performanceFee, _managementFee, feeShares, tvl);\n\n\t\t// this enables withdrawals requested prior to this timestamp\n\t\tlastHarvestTimestamp = timestamp;\n\t}\n\n\tfunction enterEmergency() public onlyOwner {}\n\n\t/// @notice this method allows an arbitrary method to be called by the owner in case of emergency\n\t/// owner must be a timelock contract in order to allow users to redeem funds in case they suspect\n\t/// this action to be malicious\n\tfunction emergencyAction(address target, bytes calldata callData) public onlyOwner {\n\t\tAddress.functionCall(target, callData);\n\t\temit EmergencyAction(target, callData);\n\t}\n\n\tfunction _checkSlippage(\n\t\tuint256 expectedValue,\n\t\tuint256 actualValue,\n\t\tuint256 maxDelta\n\t) internal pure {\n\t\tuint256 delta = expectedValue > actualValue\n\t\t\t? expectedValue - actualValue\n\t\t\t: actualValue - expectedValue;\n\t\tif (delta > maxDelta) revert SlippageExceeded();\n\t}\n\n\tfunction totalAssets() public view virtual override returns (uint256) {\n\t\treturn floatAmnt + totalChildHoldings;\n\t}\n\n\t/// INTERFACE UTILS\n\n\t/// @dev returns a cached value used for withdrawals\n\tfunction underlyingBalance(address user) public view returns (uint256) {\n\t\tuint256 shares = balanceOf(user);\n\t\treturn convertToAssets(shares);\n\t}\n\n\tfunction underlyingDecimals() public view returns (uint8) {\n\t\treturn asset.decimals();\n\t}\n\n\tfunction underlying() public view returns (address) {\n\t\treturn address(asset);\n\t}\n\n\t/// OVERRIDES\n\n\tfunction afterDeposit(uint256 assets, uint256) internal override {\n\t\tfloatAmnt += assets;\n\t}\n\n\tfunction beforeWithdraw(uint256 assets, uint256) internal override {\n\t\t// this check prevents withdrawing more underlying from the vault then\n\t\t// what we need to keep to honor withdrawals\n\t\tif (floatAmnt < assets || floatAmnt - assets < pendingWithdraw) revert NotEnoughtFloat();\n\t\tfloatAmnt -= assets;\n\t}\n\n\tevent RegisterDeposit(uint256 total);\n\tevent EmergencyWithdraw(address vault, address client, uint256 shares);\n\tevent EmergencyAction(address target, bytes callData);\n\n\terror MaxRedeemNotZero();\n\terror NotEnoughtFloat();\n\terror WrongUnderlying();\n\terror SlippageExceeded();\n\terror StrategyExists();\n\terror StrategyNotFound();\n\terror MissingDepositValue();\n}\n"
    },
    "src/interfaces/MsgStructs.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nstruct Message {\n    uint256 value;\n    address sender;\n    address client;\n    uint16 chainId;\n}\n\nstruct Vault {\n    uint16 chainId;\n    uint16 postmanId;\n    bool allowed;\n}\n\nstruct Request {\n\taddress vaultAddr;\n\tuint256 amount;\n\taddress allowanceTarget;\n\taddress registry;\n\tbytes txData;\n}\n\nenum messageType {\n    NONE,\n    DEPOSIT,\n    WITHDRAW,\n    EMERGENCYWITHDRAW,\n    HARVEST\n}"
    },
    "src/interfaces/ERC4626/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\ninterface IERC4626 {\n\tevent Deposit(\n\t\taddress indexed sender,\n\t\taddress indexed owner,\n\t\tuint256 assets,\n\t\tuint256 shares\n\t);\n\n\tevent Withdraw(\n\t\taddress indexed sender,\n\t\taddress indexed receiver,\n\t\taddress indexed owner,\n\t\tuint256 assets,\n\t\tuint256 shares\n\t);\n\n\t/*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n\tfunction mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n\tfunction withdraw(\n\t\tuint256 assets,\n\t\taddress receiver,\n\t\taddress owner\n\t) external returns (uint256 shares);\n\n\tfunction redeem(\n\t\tuint256 shares,\n\t\taddress receiver,\n\t\taddress owner\n\t) external returns (uint256 assets);\n\n\t/*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n\tfunction maxMint(address receiver) external view returns (uint256 maxShares);\n\n\tfunction maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n\tfunction maxRedeem(address owner) external view returns (uint256 maxShares);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "src/common/XChainIntegrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { Auth } from \"./Auth.sol\";\nimport \"../interfaces/MsgStructs.sol\";\nimport \"../interfaces/postOffice/IPostman.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @notice Struct encoded in Bungee calldata\n/// @dev Derived from socket registry contract\nstruct MiddlewareRequest {\n\tuint256 id;\n\tuint256 optionalNativeAmount;\n\taddress inputToken;\n\tbytes data;\n}\n\n/// @notice Struct encoded in Bungee calldata\n/// @dev Derived from socket registry contract\nstruct BridgeRequest {\n\tuint256 id;\n\tuint256 optionalNativeAmount;\n\taddress inputToken;\n\tbytes data;\n}\n\n/// @notice Struct encoded in Bungee calldata\n/// @dev Derived from socket registry contract\nstruct UserRequest {\n\taddress receiverAddress;\n\tuint256 toChainId;\n\tuint256 amount;\n\tMiddlewareRequest middlewareRequest;\n\tBridgeRequest bridgeRequest;\n}\n\nabstract contract XChainIntegrator is Auth {\n\tmapping(address => Vault) public addrBook;\n\tmapping(uint16 => mapping(uint16 => address)) public postmanAddr;\n\t// mapping(messageType => function(Message calldata)) internal messageAction;\n\n\tuint16 immutable chainId = uint16(block.chainid);\n\n\tconstructor() {}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\t\tBridge utilities\n\t/////////////////////////////////////////////////////*/\n\n\t/// @notice Decode the socket request calldata\n\t/// @dev Currently not in use due to undertainity in bungee api response\n\t/// @param _data Bungee txn calldata\n\t/// @return userRequest parsed calldata\n\tfunction decodeSocketRegistryCalldata(bytes memory _data)\n\t\tinternal\n\t\tpure\n\t\treturns (UserRequest memory userRequest)\n\t{\n\t\tbytes memory callDataWithoutSelector = slice(_data, 4, _data.length - 4);\n\t\t(userRequest) = abi.decode(callDataWithoutSelector, (UserRequest));\n\t}\n\n\t/// @notice Decodes and verifies socket calldata\n\t/// @param _data Bungee txn calldata\n\t/// @param _chainId chainId to check in bungee calldata\n\t/// @param _inputToken inputWantToken to check in bungee calldata\n\t/// @param _receiverAddress receiving address to check in bungee calldata\n\tfunction verifySocketCalldata(\n\t\tbytes memory _data,\n\t\tuint256 _chainId,\n\t\taddress _inputToken,\n\t\taddress _receiverAddress\n\t) internal pure {\n\t\tUserRequest memory userRequest;\n\t\t(userRequest) = decodeSocketRegistryCalldata(_data);\n\n\t\tif (userRequest.toChainId != _chainId) {\n\t\t\trevert(\"Invalid chainId\");\n\t\t}\n\t\tif (userRequest.receiverAddress != _receiverAddress) {\n\t\t\trevert(\"Invalid receiver address\");\n\t\t}\n\t\tif (userRequest.bridgeRequest.inputToken != _inputToken) {\n\t\t\trevert(\"Invalid input token\");\n\t\t}\n\t}\n\n\t/// @notice Sends tokens using Bungee middleware. Assumes tokens already present in contract. Manages allowance and transfer.\n\t/// @dev Currently not verifying the middleware request calldata. Use very carefully\n\t/// @param allowanceTarget address to allow tokens to swipe\n\t/// @param socketRegistry address to send bridge txn to\n\t/// @param destinationAddress address of receiver\n\t/// @param amount amount of tokens to bridge\n\t/// @param destinationChainId chain Id of receiving chain\n\t/// @param data calldata of txn to be sent\n\tfunction _sendTokens(\n\t\taddress asset,\n\t\taddress allowanceTarget,\n\t\taddress socketRegistry,\n\t\taddress destinationAddress,\n\t\tuint256 amount,\n\t\tuint256 destinationChainId,\n\t\tbytes calldata data\n\t) internal onlyRole(MANAGER) {\n\t\tverifySocketCalldata(data, destinationChainId, asset, destinationAddress);\n\n\t\tERC20(asset).approve(allowanceTarget, amount);\n\t\t(bool success, ) = socketRegistry.call(data);\n\n\t\tif (!success) revert BridgeError();\n\t}\n\n\t/*\n\t * @notice Helper to slice memory bytes\n\t * @author Gonalo S <goncalo.sa@consensys.net>\n\t *\n\t * @dev refer https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n\t */\n\tfunction slice(\n\t\tbytes memory _bytes,\n\t\tuint256 _start,\n\t\tuint256 _length\n\t) internal pure returns (bytes memory) {\n\t\trequire(_length + 31 >= _length, \"slice_overflow\");\n\t\trequire(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n\t\tbytes memory tempBytes;\n\n\t\tassembly {\n\t\t\tswitch iszero(_length)\n\t\t\tcase 0 {\n\t\t\t\t// Get a location of some free memory and store it in tempBytes as\n\t\t\t\t// Solidity does for memory variables.\n\t\t\t\ttempBytes := mload(0x40)\n\n\t\t\t\t// The first word of the slice result is potentially a partial\n\t\t\t\t// word read from the original array. To read it, we calculate\n\t\t\t\t// the length of that partial word and start copying that many\n\t\t\t\t// bytes into the array. The first word we copy will start with\n\t\t\t\t// data we don't care about, but the last `lengthmod` bytes will\n\t\t\t\t// land at the beginning of the contents of the new array. When\n\t\t\t\t// we're done copying, we overwrite the full first word with\n\t\t\t\t// the actual length of the slice.\n\t\t\t\tlet lengthmod := and(_length, 31)\n\n\t\t\t\t// The multiplication in the next line is necessary\n\t\t\t\t// because when slicing multiples of 32 bytes (lengthmod == 0)\n\t\t\t\t// the following copy loop was copying the origin's length\n\t\t\t\t// and then ending prematurely not copying everything it should.\n\t\t\t\tlet mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n\t\t\t\tlet end := add(mc, _length)\n\n\t\t\t\tfor {\n\t\t\t\t\t// The multiplication in the next line has the same exact purpose\n\t\t\t\t\t// as the one above.\n\t\t\t\t\tlet cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n\t\t\t\t} lt(mc, end) {\n\t\t\t\t\tmc := add(mc, 0x20)\n\t\t\t\t\tcc := add(cc, 0x20)\n\t\t\t\t} {\n\t\t\t\t\tmstore(mc, mload(cc))\n\t\t\t\t}\n\n\t\t\t\tmstore(tempBytes, _length)\n\n\t\t\t\t//update free-memory pointer\n\t\t\t\t//allocating the array padded to 32 bytes like the compiler does now\n\t\t\t\tmstore(0x40, and(add(mc, 31), not(31)))\n\t\t\t}\n\t\t\t//if we want a zero-length slice let's just return a zero-length array\n\t\t\tdefault {\n\t\t\t\ttempBytes := mload(0x40)\n\t\t\t\t//zero out the 32 bytes slice we are about to return\n\t\t\t\t//we need to do it because Solidity does not garbage collect\n\t\t\t\tmstore(tempBytes, 0)\n\n\t\t\t\tmstore(0x40, add(tempBytes, 0x20))\n\t\t\t}\n\t\t}\n\n\t\treturn tempBytes;\n\t}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\tAddress book management\n\t/////////////////////////////////////////////////////*/\n\n\tfunction addVault(\n\t\taddress _vault,\n\t\tuint16 _chainId,\n\t\tuint16 _postmanId,\n\t\tbool _allowed\n\t) external virtual onlyOwner {\n\t\t_addVault(_vault, _chainId, _postmanId, _allowed);\n\t}\n\n\tfunction _addVault(\n\t\taddress _vault,\n\t\tuint16 _chainId,\n\t\tuint16 _postmanId,\n\t\tbool _allowed\n\t) internal onlyOwner {\n\t\tVault memory vault = addrBook[_vault];\n\n\t\tif (vault.chainId != 0) revert VaultAlreadyAdded();\n\n\t\taddrBook[_vault] = Vault(_chainId, _postmanId, _allowed);\n\t\temit AddedVault(_vault, _chainId);\n\t}\n\n\tfunction changeVaultStatus(address _vault, bool _allowed) external onlyOwner {\n\t\taddrBook[_vault].allowed = _allowed;\n\n\t\temit ChangedVaultStatus(_vault, _allowed);\n\t}\n\n\tfunction updateVaultPostman(address _vault, uint16 _postmanId) external onlyOwner {\n\t\tVault memory vault = addrBook[_vault];\n\n\t\tif (vault.chainId == 0) revert VaultMissing(_vault);\n\n\t\taddrBook[_vault].postmanId = _postmanId;\n\n\t\temit UpdatedVaultPostman(_vault, _postmanId);\n\t}\n\n\tfunction managePostman(\n\t\tuint16 _postmanId,\n\t\tuint16 _chainId,\n\t\taddress _postman\n\t) external onlyOwner {\n\t\tpostmanAddr[_postmanId][_chainId] = _postman;\n\n\t\temit PostmanUpdated(_postmanId, _chainId, _postman);\n\t}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\tCross-chain logic\n\t/////////////////////////////////////////////////////*/\n\n\tfunction _sendMessage(\n\t\taddress receiverAddr,\n\t\tVault memory vault,\n\t\tMessage memory message,\n\t\tmessageType msgType\n\t) internal {\n\t\taddress srcPostman = postmanAddr[vault.postmanId][chainId];\n\t\taddress dstPostman = postmanAddr[vault.postmanId][vault.chainId];\n\n\t\tIPostman(srcPostman).deliverMessage(\n\t\t\tmessage,\n\t\t\treceiverAddr,\n\t\t\tdstPostman,\n\t\t\tmsgType,\n\t\t\tvault.chainId\n\t\t);\n\n\t\temit MessageSent(message.value, receiverAddr, vault.chainId, msgType, srcPostman);\n\t}\n\n\tfunction receiveMessage(Message calldata _msg, messageType _type) external {\n\t\t// First check if postman is allowed\n\t\tVault memory vault = addrBook[_msg.sender];\n\t\tif (!vault.allowed || _msg.chainId != vault.chainId) revert SenderNotAllowed(_msg.sender);\n\t\tif (msg.sender != postmanAddr[vault.postmanId][chainId]) revert WrongPostman(msg.sender);\n\n\t\t// messageAction[_type](_msg);\n\t\t_handleMessage(_type, _msg);\n\t\temit MessageReceived(_msg.value, _msg.sender, _msg.chainId, _type, msg.sender);\n\t}\n\n\tfunction _handleMessage(messageType _type, Message calldata _msg) internal virtual {}\n\tfunction processIncomingXFunds() external virtual {}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\t\t\tEvents\n\t/////////////////////////////////////////////////////*/\n\n\tevent MessageReceived(\n\t\tuint256 value,\n\t\taddress indexed sender,\n\t\tuint16 indexed srcChainId,\n\t\tmessageType mType,\n\t\taddress postman\n\t);\n\tevent MessageSent(\n\t\tuint256 value,\n\t\taddress indexed receiver,\n\t\tuint16 indexed dstChainId,\n\t\tmessageType mtype,\n\t\taddress postman\n\t);\n\tevent AddedVault(address indexed vault, uint16 chainId);\n\tevent ChangedVaultStatus(address indexed vault, bool status);\n\tevent UpdatedVaultPostman(address indexed vault, uint16 postmanId);\n\tevent PostmanUpdated(uint16 indexed postmanId, uint16 chanId, address postman);\n\tevent BridgeAsset(uint16 _fromChainId, uint16 _toChainId, uint256 amount);\n\tevent RegisterIncomingFunds(uint256 total);\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\t\t\tErrors\n\t/////////////////////////////////////////////////////*/\n\n\terror SenderNotAllowed(address sender);\n\terror WrongPostman(address postman);\n\terror VaultNotAllowed(address vault);\n\terror VaultMissing(address vault);\n\terror VaultAlreadyAdded();\n\terror BridgeError();\n\terror SameChainOperation();\n\terror MissingIncomingXFunds();\n}\n"
    },
    "src/interfaces/postOffice/IPostman.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\nimport \"../MsgStructs.sol\";\n\ninterface IPostman {\n\tfunction deliverMessage(\n\t\tMessage calldata _msg,\n\t\taddress _dstVautAddress,\n\t\taddress _dstPostman,\n\t\tmessageType _messageType,\n\t\tuint16 _dstChainId\n\t) external;\n}\n"
    },
    "src/vaults/SectorCrossVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { BatchedWithdraw } from \"./ERC4626/BatchedWithdraw.sol\";\nimport { SectorVault } from \"./SectorVault.sol\";\nimport { ERC4626, FixedPointMathLib, Fees, FeeConfig, Auth, AuthConfig } from \"./ERC4626/ERC4626.sol\";\nimport { IPostOffice } from \"../interfaces/postOffice/IPostOffice.sol\";\nimport { XChainIntegrator } from \"../common/XChainIntegrator.sol\";\nimport { SectorBase } from \"./SectorBase.sol\";\nimport \"../interfaces/MsgStructs.sol\";\n\n// import \"hardhat/console.sol\";\n\nstruct HarvestLedger {\n\tuint256 localDepositValue;\n\tuint256 crossDepositValue;\n\tuint256 pendingAnswers;\n\tuint256 receivedAnswers;\n}\n\ncontract SectorCrossVault is SectorBase {\n\tusing SafeERC20 for ERC20;\n\tusing FixedPointMathLib for uint256;\n\n\t// Used to harvest from deposited vaults\n\taddress[] internal vaultList;\n\t// Harvest state\n\tHarvestLedger public harvestLedger;\n\tMessage[] internal withdrawQueue;\n\n\tconstructor(\n\t\tERC20 _asset,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\tAuthConfig memory authConfig,\n\t\tFeeConfig memory feeConfig\n\t) ERC4626(_asset, _name, _symbol) Auth(authConfig) Fees(feeConfig) BatchedWithdraw() {}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\tCross Vault Interface\n\t/////////////////////////////////////////////////////*/\n\n\tfunction depositIntoXVaults(Request[] calldata vaults) public onlyRole(MANAGER) {\n\t\tuint256 totalAmount = 0;\n\n\t\tfor (uint256 i = 0; i < vaults.length; ) {\n\t\t\taddress vaultAddr = vaults[i].vaultAddr;\n\t\t\tuint256 amount = vaults[i].amount;\n\n\t\t\tVault memory vault = checkVault(vaultAddr);\n\t\t\tif (vault.chainId == chainId) revert SameChainOperation();\n\n\t\t\ttotalAmount += amount;\n\n\t\t\t_sendMessage(\n\t\t\t\tvaultAddr,\n\t\t\t\tvault,\n\t\t\t\tMessage(amount, address(this), address(0), chainId),\n\t\t\t\tmessageType.DEPOSIT\n\t\t\t);\n\n\t\t\t// This is fucked but dont know why\n\t\t\t_sendTokens(\n\t\t\t\tunderlying(),\n\t\t\t\tvaults[i].allowanceTarget,\n\t\t\t\tvaults[i].registry,\n\t\t\t\tvaultAddr,\n\t\t\t\tamount,\n\t\t\t\tuint256(addrBook[vaultAddr].chainId),\n\t\t\t\tvaults[i].txData\n\t\t\t);\n\n\t\t\temit BridgeAsset(chainId, vault.chainId, amount);\n\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tbeforeWithdraw(totalAmount, 0);\n\t\ttotalChildHoldings += totalAmount;\n\t}\n\n\tfunction withdrawFromXVaults(Request[] calldata vaults) public onlyRole(MANAGER) {\n\t\tfor (uint256 i = 0; i < vaults.length; ) {\n\t\t\taddress vaultAddr = vaults[i].vaultAddr;\n\t\t\tuint256 amount = vaults[i].amount;\n\n\t\t\tVault memory vault = checkVault(vaultAddr);\n\n\t\t\tif (vault.chainId == chainId) revert SameChainOperation();\n\n\t\t\t_sendMessage(\n\t\t\t\tvaultAddr,\n\t\t\t\tvault,\n\t\t\t\tMessage(amount, address(this), address(0), chainId),\n\t\t\t\tmessageType.WITHDRAW\n\t\t\t);\n\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction harvestVaults() public onlyRole(MANAGER) {\n\t\tuint256 localDepositValue = 0;\n\n\t\tif (harvestLedger.pendingAnswers != 0) revert OnGoingHarvest();\n\n\t\tuint256 vaultsLength = vaultList.length;\n\t\tuint256 xvaultsCount = 0;\n\n\t\tfor (uint256 i = 0; i < vaultsLength; ) {\n\t\t\taddress vaultAddr = vaultList[i];\n\t\t\tVault memory vault = addrBook[vaultAddr];\n\n\t\t\tif (vault.chainId == chainId) {\n\t\t\t\tlocalDepositValue += SectorVault(vaultAddr).underlyingBalance(address(this));\n\t\t\t} else {\n\t\t\t\t_sendMessage(\n\t\t\t\t\tvaultAddr,\n\t\t\t\t\tvault,\n\t\t\t\t\tMessage(0, address(this), address(0), chainId),\n\t\t\t\t\tmessageType.HARVEST\n\t\t\t\t);\n\n\t\t\t\tunchecked {\n\t\t\t\t\txvaultsCount += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tharvestLedger = HarvestLedger(localDepositValue, 0, xvaultsCount, 0);\n\t}\n\n\tfunction finalizeHarvest(uint256 expectedValue, uint256 maxDelta) public onlyRole(MANAGER) {\n\t\tHarvestLedger memory ledger = harvestLedger;\n\n\t\tif (ledger.pendingAnswers == 0) revert HarvestNotOpen();\n\t\tif (ledger.receivedAnswers < ledger.pendingAnswers) revert MissingMessages();\n\n\t\tuint256 currentChildHoldings = ledger.localDepositValue + ledger.crossDepositValue;\n\n\t\t// TODO should expectedValue include balance?\n\t\t// uint256 tvl = currentChildHoldings + asset.balanceOf(address(this));\n\t\t_checkSlippage(expectedValue, currentChildHoldings, maxDelta);\n\t\t_harvest(currentChildHoldings);\n\n\t\t// Change harvest status\n\t\tharvestLedger = HarvestLedger(0, 0, 0, 0);\n\t}\n\n\tfunction emergencyWithdraw() external {\n\t\tuint256 userShares = balanceOf(msg.sender);\n\n\t\t_burn(msg.sender, userShares);\n\t\tuint256 userPerc = userShares.divWadDown(totalSupply());\n\n\t\tuint256 vaultsLength = vaultList.length;\n\t\tfor (uint256 i = 0; i < vaultsLength; ) {\n\t\t\taddress vaultAddr = vaultList[i];\n\t\t\tVault memory vault = checkVault(vaultAddr);\n\n\t\t\tif (vault.chainId == chainId) {\n\t\t\t\tBatchedWithdraw _vault = BatchedWithdraw(vaultAddr);\n\t\t\t\tuint256 transferShares = userPerc.mulWadDown(_vault.balanceOf(address(this)));\n\t\t\t\t_vault.transfer(msg.sender, transferShares);\n\t\t\t} else {\n\t\t\t\t_sendMessage(\n\t\t\t\t\tvaultAddr,\n\t\t\t\t\tvault,\n\t\t\t\t\tMessage(userPerc, address(this), msg.sender, chainId),\n\t\t\t\t\tmessageType.EMERGENCYWITHDRAW\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Do linear search on vaultList -> O(n)\n\tfunction removeVault(address _vault) external onlyOwner {\n\t\taddrBook[_vault].allowed = false;\n\n\t\tuint256 length = vaultList.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\tif (vaultList[i] == _vault) {\n\t\t\t\tvaultList[i] = vaultList[length - 1];\n\t\t\t\tvaultList.pop();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\t\t\tOverrides\n\t/////////////////////////////////////////////////////*/\n\n\tfunction addVault(\n\t\taddress _vault,\n\t\tuint16 _chainId,\n\t\tuint16 _postmanId,\n\t\tbool _allowed\n\t) external override onlyOwner {\n\t\t_addVault(_vault, _chainId, _postmanId, _allowed);\n\t\tvaultList.push(_vault);\n\t}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\t\t\tInternals\n\t/////////////////////////////////////////////////////*/\n\n\tfunction _handleMessage(messageType _type, Message calldata _msg) internal override {\n\t\tif (_type == messageType.WITHDRAW) _receiveWithdraw(_msg);\n\t\telse if (_type == messageType.HARVEST) _receiveHarvest(_msg);\n\t\telse revert NotImplemented();\n\t}\n\n\tfunction checkVault(address _vault) internal view returns (Vault memory) {\n\t\tVault memory vault = addrBook[_vault];\n\t\tif (!vault.allowed) revert VaultNotAllowed(_vault);\n\t\treturn vault;\n\t}\n\n\tfunction _receiveWithdraw(Message calldata _msg) internal {\n\t\twithdrawQueue.push(_msg);\n\t}\n\n\tfunction processIncomingXFunds() external override onlyRole(MANAGER) {\n\t\tuint256 length = withdrawQueue.length;\n\t\tuint256 total = 0;\n\t\tfor (uint256 i = length; i > 0; ) {\n\t\t\tMessage memory _msg = withdrawQueue[i - 1];\n\t\t\twithdrawQueue.pop();\n\n\t\t\ttotal += _msg.value;\n\n\t\t\tunchecked {\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t// Should account for fees paid in tokens for using bridge\n\t\t// Also, if a value hasn't arrived manager will not be able to register any value\n\t\tif (total < (asset.balanceOf(address(this)) - floatAmnt - pendingWithdraw))\n\t\t\trevert MissingIncomingXFunds();\n\n\t\t_finalizedWithdraw(total);\n\t\temit RegisterIncomingFunds(total);\n\t}\n\n\tfunction _receiveHarvest(Message calldata _msg) internal {\n\t\tharvestLedger.crossDepositValue += _msg.value;\n\t\tharvestLedger.receivedAnswers += 1;\n\t}\n\n\tfunction _finalizedWithdraw(uint256 totalWithdraw) internal {\n\t\t// uint256 totalWithdraw;\n\t\ttotalChildHoldings -= totalWithdraw;\n\t\tafterDeposit(totalWithdraw, 0);\n\t}\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\t\t\tModifiers\n\t/////////////////////////////////////////////////////*/\n\n\t// modifier harvestLock() {\n\t// \tif (harvestLedger.count != 0) revert OnGoingHarvest();\n\t// \t_;\n\t// }\n\n\t/*/////////////////////////////////////////////////////\n\t\t\t\t\t\t\tErrors\n\t/////////////////////////////////////////////////////*/\n\n\terror HarvestNotOpen();\n\terror OnGoingHarvest();\n\terror MissingMessages();\n}\n"
    },
    "src/interfaces/postOffice/IPostOffice.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\nimport \"../MsgStructs.sol\";\n\ninterface IPostOffice {\n\tfunction sendMessage(\n\t\taddress receiverAddr,\n\t\tMessage calldata message,\n\t\tuint16 receiverChainId,\n\t\tmessageType msgType\n\t) external;\n\n\tfunction writeMessage(\n\t\taddress receiver,\n\t\tMessage calldata message,\n\t\tmessageType msgType\n\t) external;\n\n\tfunction readMessage(messageType msgType) external returns (Message[] memory messages);\n\n\tfunction readMessageSumReduce(messageType msgType)\n\t\texternal\n\t\treturns (uint256 acc, uint256 count);\n}\n"
    },
    "src/vaults/HLPVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.16;\n\nimport { SCYStrategy, Strategy } from \"./scy/SCYStrategy.sol\";\nimport { HLPCore } from \"../strategies/hlp/HLPCore.sol\";\nimport { SCYVault, IERC20 } from \"./scy/SCYVault.sol\";\nimport { AuthConfig, Auth } from \"../common/Auth.sol\";\nimport { FeeConfig, Fees } from \"../common/Fees.sol\";\n\ncontract HLPVault is SCYStrategy, SCYVault {\n\tconstructor(\n\t\tAuthConfig memory authConfig,\n\t\tFeeConfig memory feeConfig,\n\t\tStrategy memory _strategy\n\t) Auth(authConfig) Fees(feeConfig) SCYVault(_strategy) {}\n\n\tfunction _stratValidate() internal view override {\n\t\tif (address(underlying) != address(HLPCore(strategy).underlying()))\n\t\t\trevert InvalidStrategy();\n\t}\n\n\tfunction _stratDeposit(uint256 amount) internal override returns (uint256) {\n\t\treturn HLPCore(strategy).deposit(amount);\n\t}\n\n\tfunction _stratRedeem(address recipient, uint256 yeildTokenAmnt)\n\t\tinternal\n\t\toverride\n\t\treturns (uint256 amountOut, uint256 amntToTransfer)\n\t{\n\t\t// strategy doesn't transfer tokens to user\n\t\t// TODO it should?\n\t\tamountOut = HLPCore(strategy).redeem(yeildTokenAmnt, recipient);\n\t\tamntToTransfer = 0;\n\t}\n\n\tfunction _stratGetAndUpdateTvl() internal override returns (uint256) {\n\t\treturn HLPCore(strategy).getAndUpdateTVL();\n\t}\n\n\tfunction _strategyTvl() internal view override returns (uint256) {\n\t\treturn HLPCore(strategy).getTotalTVL();\n\t}\n\n\tfunction _stratClosePosition(uint256 slippageParam) internal override returns (uint256) {\n\t\treturn HLPCore(strategy).closePosition(slippageParam);\n\t}\n\n\tfunction _stratMaxTvl() internal view override returns (uint256) {\n\t\treturn HLPCore(strategy).getMaxTvl();\n\t}\n\n\tfunction _stratCollateralToUnderlying() internal view override returns (uint256) {\n\t\treturn HLPCore(strategy).collateralToUnderlying();\n\t}\n\n\tfunction _selfBalance(address token) internal view virtual override returns (uint256) {\n\t\tif (token == yieldToken) return HLPCore(strategy).getLiquidity();\n\t\treturn (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n\t}\n}\n"
    },
    "src/strategies/hlp/HLPCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport { IBase, HarvestSwapParms } from \"../mixins/IBase.sol\";\nimport { ILending } from \"../mixins/ILending.sol\";\nimport { IUniFarm, SafeERC20, IERC20 } from \"../mixins/IUniFarm.sol\";\nimport { IWETH } from \"../../interfaces/uniswap/IWETH.sol\";\nimport { UniUtils, IUniswapV2Pair } from \"../../libraries/UniUtils.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Auth } from \"../../common/Auth.sol\";\nimport { FixedPointMathLib } from \"../../libraries/FixedPointMathLib.sol\";\n\nimport \"hardhat/console.sol\";\n\n// @custom: alphabetize dependencies to avoid linearization conflicts\nabstract contract HLPCore is Auth, ReentrancyGuard, IBase, ILending, IUniFarm {\n\tusing UniUtils for IUniswapV2Pair;\n\tusing SafeERC20 for IERC20;\n\tusing FixedPointMathLib for uint256;\n\n\tevent Deposit(address sender, uint256 amount);\n\tevent Redeem(address sender, uint256 amount);\n\tevent Harvest(uint256 harvested); // this is actual the tvl before harvest\n\tevent Rebalance(uint256 shortPrice, uint256 tvlBeforeRebalance, uint256 positionOffset);\n\tevent EmergencyWithdraw(address indexed recipient, IERC20[] tokens);\n\tevent UpdatePosition();\n\n\tevent RebalanceLoan(address indexed sender, uint256 startLoanHealth, uint256 updatedLoanHealth);\n\tevent setMinLoanHealth(uint256 loanHealth);\n\tevent SetMaxDefaultPriceMismatch(uint256 maxDefaultPriceMismatch);\n\tevent SetRebalanceThreshold(uint256 rebalanceThreshold);\n\tevent SetMaxTvl(uint256 maxTvl);\n\tevent SetSafeCollateralRaio(uint256 collateralRatio);\n\n\tuint256 constant MIN_LIQUIDITY = 1000;\n\tuint256 public constant maxPriceOffset = 2000; // maximum offset for rebalanceLoan & manager  methods 20%\n\tuint256 constant BPS_ADJUST = 10000;\n\n\tuint256 public lastHarvest; // block.timestamp;\n\n\tIERC20 private _underlying;\n\tIERC20 private _short;\n\n\tuint256 public maxDefaultPriceMismatch = 100; // 1%\n\tuint256 public constant maxAllowedMismatch = 300; // manager cannot set user-price mismatch to more than 3%\n\tuint256 public minLoanHealth = 1.15e18; // how close to liquidation we get\n\n\tuint16 public rebalanceThreshold = 400; // 4% of lp\n\n\tuint256 private _maxTvl;\n\tuint256 private _safeCollateralRatio = 8000; // 80%\n\n\tuint256 public constant version = 1;\n\n\taddress public vault;\n\n\tbool public harvestIsEnabled = true;\n\n\tmodifier onlyVault() {\n\t\trequire(msg.sender == vault, \"Strat: ONLY_VAULT\");\n\t\t_;\n\t}\n\n\tmodifier isPaused() {\n\t\tif (_maxTvl != 0) revert NotPaused();\n\t\t_;\n\t}\n\n\tmodifier checkPrice(uint256 maxSlippage) {\n\t\tif (maxSlippage == 0)\n\t\t\tmaxSlippage = maxDefaultPriceMismatch;\n\t\t\t// manager accounts cannot set maxSlippage bigger than maxPriceOffset\n\t\telse\n\t\t\trequire(\n\t\t\t\tmaxSlippage <= maxPriceOffset ||\n\t\t\t\t\thasRole(GUARDIAN, msg.sender) ||\n\t\t\t\t\tmsg.sender == vault,\n\t\t\t\t\"HLP: MAX_MISMATCH\"\n\t\t\t);\n\t\trequire(getPriceOffset() <= maxSlippage, \"HLP: PRICE_MISMATCH\");\n\t\t_;\n\t}\n\n\tfunction __HedgedLP_init_(\n\t\taddress underlying_,\n\t\taddress short_,\n\t\tuint256 maxTvl_,\n\t\taddress _vault\n\t) internal initializer {\n\t\t_underlying = IERC20(underlying_);\n\t\t_short = IERC20(short_);\n\n\t\tvault = _vault;\n\n\t\t_underlying.safeApprove(address(this), type(uint256).max);\n\n\t\t// init params\n\t\tsetMaxTvl(maxTvl_);\n\n\t\t// emit default settings events\n\t\temit setMinLoanHealth(minLoanHealth);\n\t\temit SetMaxDefaultPriceMismatch(maxDefaultPriceMismatch);\n\t\temit SetRebalanceThreshold(rebalanceThreshold);\n\t\temit SetSafeCollateralRaio(_safeCollateralRatio);\n\n\t\t// TODO should we add a revoke aprovals methods?\n\t\t_addLendingApprovals();\n\t\t_addFarmApprovals();\n\n\t\tisInitialized = true;\n\t}\n\n\tfunction safeCollateralRatio() public view override returns (uint256) {\n\t\treturn _safeCollateralRatio;\n\t}\n\n\tfunction setSafeCollateralRatio(uint256 safeCollateralRatio_) public onlyOwner {\n\t\trequire(safeCollateralRatio_ >= 1000 && safeCollateralRatio_ <= 8500, \"HLP: BAD_INPUT\");\n\t\t_safeCollateralRatio = safeCollateralRatio_;\n\t\temit SetSafeCollateralRaio(safeCollateralRatio_);\n\t}\n\n\tfunction decimals() public view returns (uint8) {\n\t\treturn IERC20Metadata(address(_underlying)).decimals();\n\t}\n\n\t// OWNER CONFIG\n\tfunction setMinLoanHeath(uint256 minLoanHealth_) public onlyOwner {\n\t\trequire(minLoanHealth_ > 1e18, \"HLP: BAD_INPUT\");\n\t\tminLoanHealth = minLoanHealth_;\n\t\temit setMinLoanHealth(minLoanHealth_);\n\t}\n\n\t// guardian can adjust max default price mismatch if needed\n\tfunction setMaxDefaultPriceMismatch(uint256 maxDefaultPriceMismatch_)\n\t\tpublic\n\t\tonlyRole(GUARDIAN)\n\t{\n\t\trequire(maxDefaultPriceMismatch_ >= 25, \"HLP: BAD_INPUT\"); // no less than .25%\n\t\trequire(\n\t\t\tmsg.sender == owner || maxAllowedMismatch >= maxDefaultPriceMismatch_,\n\t\t\t\"HLP: BAD_INPUT\"\n\t\t);\n\t\tmaxDefaultPriceMismatch = maxDefaultPriceMismatch_;\n\t\temit SetMaxDefaultPriceMismatch(maxDefaultPriceMismatch_);\n\t}\n\n\tfunction setRebalanceThreshold(uint16 rebalanceThreshold_) public onlyOwner {\n\t\t// rebalance threshold should not be lower than 1% (2% price move)\n\t\trequire(rebalanceThreshold_ >= 100, \"HLP: BAD_INPUT\");\n\t\trebalanceThreshold = rebalanceThreshold_;\n\t\temit SetRebalanceThreshold(rebalanceThreshold_);\n\t}\n\n\tfunction setMaxTvl(uint256 maxTvl_) public onlyRole(GUARDIAN) {\n\t\t_maxTvl = maxTvl_;\n\t\temit SetMaxTvl(maxTvl_);\n\t}\n\n\t// PUBLIC METHODS\n\n\tfunction short() public view override returns (IERC20) {\n\t\treturn _short;\n\t}\n\n\tfunction underlying() public view override returns (IERC20) {\n\t\treturn _underlying;\n\t}\n\n\t// public method that anyone can call if loan health falls below minLoanHealth\n\t// this method will succeed only when loanHealth is below minimum\n\tfunction rebalanceLoan() public nonReentrant {\n\t\t// limit offset to maxPriceOffset manager to prevent misuse\n\t\tif (hasRole(GUARDIAN, msg.sender)) {} else if (hasRole(MANAGER, msg.sender))\n\t\t\trequire(getPriceOffset() <= maxPriceOffset, \"HLP: MAX_MISMATCH\");\n\t\t\t// public methods need more protection agains griefing\n\t\t\t// NOTE: this may prevent gelato bots from executing the tx in the case of\n\t\t\t// a sudden price spike on a CEX\n\t\telse require(getPriceOffset() <= maxDefaultPriceMismatch, \"HLP: PRICE_MISMATCH\");\n\n\t\tuint256 _loanHealth = loanHealth();\n\t\trequire(_loanHealth <= minLoanHealth, \"HLP: SAFE\");\n\t\t_rebalanceLoan(_loanHealth);\n\t}\n\n\tfunction _rebalanceLoan(uint256 _loanHealth) internal {\n\t\t(uint256 underlyingLp, ) = _getLPBalances();\n\t\tuint256 collateral = _getCollateralBalance();\n\n\t\t// get back to our target _safeCollateralRatio\n\t\tuint256 targetHealth = (10000 * 1e18) / _safeCollateralRatio;\n\t\tuint256 addCollateral = (1e18 * ((collateral * targetHealth) / _loanHealth - collateral)) /\n\t\t\t((targetHealth * 1e18) / _getCollateralFactor() + 1e18);\n\n\t\t// remove lp\n\t\t(uint256 underlyingBalance, uint256 shortBalance) = _decreaseULpTo(\n\t\t\tunderlyingLp - addCollateral\n\t\t);\n\n\t\t_repay(shortBalance);\n\t\t_lend(underlyingBalance);\n\t\temit RebalanceLoan(msg.sender, _loanHealth, loanHealth());\n\t}\n\n\t// deposit underlying and recieve lp tokens\n\tfunction deposit(uint256 underlyingAmnt) external onlyVault nonReentrant returns (uint256) {\n\t\tif (underlyingAmnt == 0) return 0; // cannot deposit 0\n\n\t\t// TODO this can cause DOS attack\n\t\tif (underlyingAmnt < _underlying.balanceOf(address(this))) revert NonZeroFloat();\n\n\t\t// deposit is already included in tvl\n\t\tuint256 tvl = getAndUpdateTVL();\n\t\trequire(tvl <= getMaxTvl(), \"STRAT: OVER_MAX_TVL\");\n\n\t\tuint256 startBalance = _getLiquidity();\n\t\t// this method should not change % allocation to lp vs collateral\n\t\t_increasePosition(underlyingAmnt);\n\t\tuint256 endBalance = _getLiquidity();\n\t\treturn endBalance - startBalance;\n\t}\n\n\t/// @notice decreases position based to desired LP amount\n\t/// @dev ** does not rebalance remaining portfolio\n\t/// @param removeLp amount of lp amount to remove\n\tfunction redeem(uint256 removeLp, address recipient)\n\t\tpublic\n\t\tonlyVault\n\t\treturns (uint256 amountTokenOut)\n\t{\n\t\tif (removeLp == 0) return 0;\n\t\t// this is the full amount of LP tokens totalSupply of shares is entitled to\n\t\t_decreasePosition(removeLp);\n\n\t\t// TODO make sure we never have any extra underlying dust sitting around\n\t\t// all 'extra' underlying should allways be transferred back to the vault\n\n\t\tunchecked {\n\t\t\tamountTokenOut = _underlying.balanceOf(address(this));\n\t\t}\n\t\t_underlying.safeTransfer(recipient, amountTokenOut);\n\t\temit Redeem(msg.sender, amountTokenOut);\n\t}\n\n\t/// @notice decreases position based on current ratio\n\t/// @dev ** does not rebalance any part of portfolio\n\tfunction _decreasePosition(uint256 removeLp) internal {\n\t\tuint256 collateralBalance = _updateAndGetCollateralBalance();\n\t\tuint256 shortPosition = _updateAndGetBorrowBalance();\n\n\t\tuint256 totalLp = _getLiquidity();\n\t\tif (removeLp > totalLp) removeLp = totalLp;\n\n\t\tuint256 redeemAmnt = collateralBalance.mulDivDown(removeLp, totalLp);\n\t\tuint256 repayAmnt = shortPosition.mulDivUp(removeLp, totalLp);\n\n\t\t// TODO do we need this?\n\t\t// uint256 shortBalance = _short.balanceOf(address(this));\n\n\t\t// remove lp\n\t\t(, uint256 sLp) = _removeLp(removeLp);\n\t\t_tradeExact(repayAmnt, sLp, address(_short), address(_underlying));\n\t\t_repay(repayAmnt);\n\t\t_redeem(redeemAmnt);\n\t}\n\n\tfunction _tradeExact(\n\t\tuint256 target,\n\t\tuint256 balance,\n\t\taddress exactToken,\n\t\taddress token\n\t) internal returns (uint256 addToken, uint256 subtractToken) {\n\t\tif (target > balance)\n\t\t\tsubtractToken = pair()._swapTokensForExactTokens(target - balance, token, exactToken);\n\t\telse if (balance > target)\n\t\t\taddToken = pair()._swapExactTokensForTokens(balance - target, exactToken, token);\n\t}\n\n\t/// @notice decreases position proportionally based on current position ratio\n\t// ** does not rebalance remaining portfolio\n\tfunction _increasePosition(uint256 underlyingAmnt) internal {\n\t\tif (underlyingAmnt < MIN_LIQUIDITY) revert MinLiquidity(); // avoid imprecision\n\t\tuint256 tvl = getAndUpdateTVL() - underlyingAmnt;\n\n\t\t// if this is the first deposit, we use our desire ratio\n\t\tif (tvl == 0) {\n\t\t\tuint256 addULp = _totalToLp(underlyingAmnt);\n\t\t\tuint256 borrowAmnt = _underlyingToShort(addULp);\n\t\t\tuint256 collateralAmnt = underlyingAmnt - addULp;\n\t\t\t_lend(collateralAmnt);\n\t\t\t_borrow(borrowAmnt);\n\t\t\tuint256 liquidity = _addLiquidity(addULp, borrowAmnt);\n\t\t\t_depositIntoFarm(liquidity);\n\t\t\treturn;\n\t\t}\n\n\t\t{\n\t\t\tuint256 collateralBalance = _updateAndGetCollateralBalance();\n\t\t\tuint256 shortPosition = _updateAndGetBorrowBalance();\n\n\t\t\t// else we use whatever the current ratio is\n\t\t\t(, uint256 sLp) = _getLPBalances();\n\t\t\tuint256 addSLp = (underlyingAmnt * sLp) / tvl;\n\t\t\tuint256 collateralAmnt = (collateralBalance * underlyingAmnt) / tvl;\n\t\t\tuint256 borrowAmnt = (shortPosition * underlyingAmnt) / tvl;\n\n\t\t\t_lend(collateralAmnt);\n\t\t\t_borrow(borrowAmnt);\n\n\t\t\t_increaseLpPosition(addSLp + sLp);\n\t\t}\n\t}\n\n\t// use the return of the function to estimate pending harvest via staticCall\n\tfunction harvest(\n\t\tHarvestSwapParms[] calldata uniParams,\n\t\tHarvestSwapParms[] calldata lendingParams\n\t)\n\t\texternal\n\t\tonlyRole(MANAGER)\n\t\tcheckPrice(0)\n\t\tnonReentrant\n\t\treturns (uint256[] memory farmHarvest, uint256[] memory lendHarvest)\n\t{\n\t\t(uint256 startTvl, , , , , ) = getTVL();\n\t\tif (uniParams.length != 0) farmHarvest = _harvestFarm(uniParams);\n\t\tif (lendingParams.length != 0) lendHarvest = _harvestLending(lendingParams);\n\n\t\t// compound our lp position\n\t\t_increasePosition(underlying().balanceOf(address(this)));\n\t\temit Harvest(startTvl);\n\t}\n\n\tfunction rebalance(uint256 maxSlippage)\n\t\texternal\n\t\tonlyRole(MANAGER)\n\t\tcheckPrice(maxSlippage)\n\t\tnonReentrant\n\t{\n\t\t// call this first to ensure we use an updated borrowBalance when computing offset\n\t\tuint256 tvl = getAndUpdateTVL();\n\t\tuint256 positionOffset = getPositionOffset();\n\n\t\tif (positionOffset < rebalanceThreshold) revert RebalanceThreshold();\n\n\t\tif (tvl == 0) return;\n\t\tuint256 targetUnderlyingLP = _totalToLp(tvl);\n\n\t\t// add .1% room for fees\n\t\t_rebalancePosition((targetUnderlyingLP * 999) / 1000, tvl - targetUnderlyingLP);\n\t\temit Rebalance(_shortToUnderlying(1e18), positionOffset, tvl);\n\t}\n\n\t// note: one should call harvest before closing position\n\tfunction closePosition(uint256 maxSlippage)\n\t\tpublic\n\t\tcheckPrice(maxSlippage)\n\t\tonlyVault\n\t\treturns (uint256 balance)\n\t{\n\t\t// lock deposits\n\t\t_maxTvl = 0;\n\t\temit SetMaxTvl(0);\n\t\t_closePosition();\n\t\tbalance = _underlying.balanceOf(address(this));\n\t\t_underlying.safeTransfer(vault, balance);\n\t\temit UpdatePosition();\n\t}\n\n\t// in case of emergency - remove LP\n\tfunction removeLiquidity(uint256 removeLp, uint256 maxSlippage)\n\t\tpublic\n\t\tcheckPrice(maxSlippage)\n\t\tonlyRole(GUARDIAN)\n\t\tisPaused\n\t{\n\t\t_removeLiquidity(removeLp);\n\t\temit UpdatePosition();\n\t}\n\n\t// in case of emergency - withdraw lp tokens from farm\n\tfunction withdrawFromFarm() public isPaused onlyRole(GUARDIAN) {\n\t\t_withdrawFromFarm(_getFarmLp());\n\t\temit UpdatePosition();\n\t}\n\n\t// in case of emergency - withdraw stuck collateral\n\tfunction redeemCollateral(uint256 repayAmnt, uint256 withdrawAmnt)\n\t\tpublic\n\t\tisPaused\n\t\tonlyRole(GUARDIAN)\n\t{\n\t\t_repay(repayAmnt);\n\t\t_redeem(withdrawAmnt);\n\t\temit UpdatePosition();\n\t}\n\n\tfunction _closePosition() internal {\n\t\t_decreaseULpTo(0);\n\t\tuint256 shortPosition = _updateAndGetBorrowBalance();\n\t\tuint256 shortBalance = _short.balanceOf(address(this));\n\t\tif (shortPosition > shortBalance) {\n\t\t\tpair()._swapTokensForExactTokens(\n\t\t\t\tshortPosition - shortBalance,\n\t\t\t\taddress(_underlying),\n\t\t\t\taddress(_short)\n\t\t\t);\n\t\t} else if (shortBalance > shortPosition) {\n\t\t\tpair()._swapExactTokensForTokens(\n\t\t\t\tshortBalance - shortPosition,\n\t\t\t\taddress(_short),\n\t\t\t\taddress(_underlying)\n\t\t\t);\n\t\t}\n\t\t_repay(_short.balanceOf(address(this)));\n\t\tuint256 collateralBalance = _updateAndGetCollateralBalance();\n\t\t_redeem(collateralBalance);\n\t}\n\n\tfunction _decreaseULpTo(uint256 targetUnderlyingLP)\n\t\tinternal\n\t\treturns (uint256 underlyingRemove, uint256 shortRemove)\n\t{\n\t\t(uint256 underlyingLp, ) = _getLPBalances();\n\t\tif (targetUnderlyingLP >= underlyingLp) return (0, 0); // nothing to withdraw\n\t\tuint256 liquidity = _getLiquidity();\n\t\tuint256 targetLiquidity = (liquidity * targetUnderlyingLP) / underlyingLp;\n\t\tuint256 removeLp = liquidity - targetLiquidity;\n\t\tuint256 liquidityBalance = pair().balanceOf(address(this));\n\t\tif (removeLp > liquidityBalance) _withdrawFromFarm(removeLp - liquidityBalance);\n\t\treturn removeLp == 0 ? (0, 0) : _removeLiquidity(removeLp);\n\t}\n\n\tfunction _removeLp(uint256 removeLp)\n\t\tinternal\n\t\treturns (uint256 underlyingRemove, uint256 shortRemove)\n\t{\n\t\t// TODO ensure that we never have LP not in farm\n\t\t_withdrawFromFarm(removeLp);\n\t\treturn _removeLiquidity(removeLp);\n\t}\n\n\tfunction _rebalancePosition(uint256 targetUnderlyingLP, uint256 targetCollateral) internal {\n\t\tuint256 targetBorrow = _underlyingToShort(targetUnderlyingLP);\n\t\t// we already updated tvl\n\t\tuint256 currentBorrow = _getBorrowBalance();\n\n\t\t// borrow funds or repay loan\n\t\tif (targetBorrow > currentBorrow) {\n\t\t\t// remove extra lp (we may need to remove more in order to add more collateral)\n\t\t\t_decreaseULpTo(\n\t\t\t\t_needUnderlying(targetUnderlyingLP, targetCollateral) > 0 ? 0 : targetUnderlyingLP\n\t\t\t);\n\t\t\t// add collateral\n\t\t\t_adjustCollateral(targetCollateral);\n\t\t\t_borrow(targetBorrow - currentBorrow);\n\t\t} else if (targetBorrow < currentBorrow) {\n\t\t\t// remove all of lp so we can repay loan\n\t\t\t_decreaseULpTo(0);\n\t\t\tuint256 repayAmnt = min(_short.balanceOf(address(this)), currentBorrow - targetBorrow);\n\t\t\tif (repayAmnt > 0) _repay(repayAmnt);\n\t\t\t// remove extra collateral\n\t\t\t_adjustCollateral(targetCollateral);\n\t\t}\n\t\t_increaseLpPosition(targetBorrow);\n\t}\n\n\t///////////////////////////\n\t//// INCREASE LP POSITION\n\t///////////////////////\n\tfunction _increaseLpPosition(uint256 targetShortLp) internal {\n\t\tuint256 uBalance = _underlying.balanceOf(address(this));\n\t\tuint256 sBalance = _short.balanceOf(address(this));\n\n\t\t// here we make sure we don't add extra lp\n\t\t(, uint256 shortLP) = _getLPBalances();\n\t\tif (targetShortLp <= shortLP) return;\n\n\t\tuint256 addShort = targetShortLp - shortLP;\n\t\tuint256 addUnderlying = _shortToUnderlying(addShort);\n\n\t\t(uint256 addU, uint256 subtractU) = _tradeExact(\n\t\t\taddShort,\n\t\t\tsBalance,\n\t\t\taddress(_short),\n\t\t\taddress(_underlying)\n\t\t);\n\n\t\tuBalance = uBalance + addU - subtractU;\n\n\t\t// we know that now our short balance is exact sBalance = sAmnt\n\t\t// if we don't have enough underlying, we need to decrase sAmnt slighlty\n\t\t// TODO have trades account for slippage\n\t\tif (uBalance < addUnderlying) {\n\t\t\taddUnderlying = uBalance;\n\t\t\taddShort = _underlyingToShort(uBalance);\n\t\t\t// if we have short dust, we can leave it for next rebalance\n\t\t} else if (uBalance > addUnderlying) {\n\t\t\t// if we have extra underlying, lend it back to avoid extra float\n\t\t\t_lend(uBalance - addUnderlying);\n\t\t}\n\n\t\tif (addUnderlying == 0) return;\n\n\t\t// add liquidity\n\t\t// don't need to use min with underlying and short because we did oracle check\n\t\t// amounts are exact because we used swap price above\n\t\tuint256 liquidity = _addLiquidity(addUnderlying, addShort);\n\t\t_depositIntoFarm(liquidity);\n\t}\n\n\tfunction _needUnderlying(uint256 tragetUnderlying, uint256 targetCollateral)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\tuint256 collateralBalance = _getCollateralBalance();\n\t\tif (targetCollateral < collateralBalance) return 0;\n\t\t(uint256 underlyingLp, ) = _getLPBalances();\n\t\tuint256 uBalance = tragetUnderlying > underlyingLp ? tragetUnderlying - underlyingLp : 0;\n\t\tuint256 addCollateral = targetCollateral - collateralBalance;\n\t\tif (uBalance >= addCollateral) return 0;\n\t\treturn addCollateral - uBalance;\n\t}\n\n\t// TVL\n\n\tfunction getMaxTvl() public view returns (uint256) {\n\t\t// we don't want to get precise max borrow amaount available,\n\t\t// we want to stay at least a getCollateralRatio away from max borrow\n\t\treturn min(_maxTvl, _oraclePriceOfShort(_maxBorrow() + _getBorrowBalance()));\n\t}\n\n\tfunction getAndUpdateTVL() public returns (uint256 tvl) {\n\t\tuint256 collateralBalance = _updateAndGetCollateralBalance();\n\t\tuint256 shortPosition = _updateAndGetBorrowBalance();\n\t\tuint256 borrowBalance = _shortToUnderlying(shortPosition);\n\t\tuint256 shortP = _short.balanceOf(address(this));\n\t\tuint256 shortBalance = shortP == 0 ? 0 : _shortToUnderlying(shortP);\n\t\t(uint256 underlyingLp, ) = _getLPBalances();\n\t\tuint256 underlyingBalance = _underlying.balanceOf(address(this));\n\t\ttvl =\n\t\t\tcollateralBalance +\n\t\t\tunderlyingLp *\n\t\t\t2 -\n\t\t\tborrowBalance +\n\t\t\tunderlyingBalance +\n\t\t\tshortBalance;\n\t}\n\n\t// We can include a checkPrice(0) here for extra security\n\t// but it's not necessary with latestvault updates\n\tfunction balanceOfUnderlying() public view returns (uint256 assets) {\n\t\t(assets, , , , , ) = getTVL();\n\t}\n\n\tfunction getTotalTVL() public view returns (uint256 tvl) {\n\t\t(tvl, , , , , ) = getTVL();\n\t}\n\n\tfunction getTVL()\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tuint256 tvl,\n\t\t\tuint256 collateralBalance,\n\t\t\tuint256 borrowPosition,\n\t\t\tuint256 borrowBalance,\n\t\t\tuint256 lpBalance,\n\t\t\tuint256 underlyingBalance\n\t\t)\n\t{\n\t\tcollateralBalance = _getCollateralBalance();\n\t\tborrowPosition = _getBorrowBalance();\n\t\tborrowBalance = _shortToUnderlying(borrowPosition);\n\n\t\tuint256 shortPosition = _short.balanceOf(address(this));\n\t\tuint256 shortBalance = shortPosition == 0 ? 0 : _shortToUnderlying(shortPosition);\n\n\t\t(uint256 underlyingLp, uint256 shortLp) = _getLPBalances();\n\t\tlpBalance = underlyingLp + _shortToUnderlying(shortLp);\n\n\t\tunderlyingBalance = _underlying.balanceOf(address(this));\n\n\t\ttvl = collateralBalance + lpBalance - borrowBalance + underlyingBalance + shortBalance;\n\t}\n\n\tfunction getLPBalances() public view returns (uint256 underlyingLp, uint256 shortLp) {\n\t\treturn _getLPBalances();\n\t}\n\n\tfunction getLiquidity() public view returns (uint256) {\n\t\treturn _getLiquidity();\n\t}\n\n\tfunction getPositionOffset() public view returns (uint256 positionOffset) {\n\t\t(, uint256 shortLp) = _getLPBalances();\n\t\tuint256 borrowBalance = _getBorrowBalance();\n\t\tuint256 shortBalance = shortLp + _short.balanceOf(address(this));\n\n\t\tif (shortBalance == borrowBalance) return 0;\n\t\t// if short lp > 0 and borrowBalance is 0 we are off by inf, returning 100% should be enough\n\t\tif (borrowBalance == 0) return 10000;\n\n\t\t// this is the % by which our position has moved from beeing balanced\n\t\tpositionOffset = shortBalance > borrowBalance\n\t\t\t? ((shortBalance - borrowBalance) * BPS_ADJUST) / borrowBalance\n\t\t\t: ((borrowBalance - shortBalance) * BPS_ADJUST) / borrowBalance;\n\t}\n\n\tfunction getPriceOffset() public view returns (uint256 offset) {\n\t\tuint256 minPrice = _shortToUnderlying(1e18);\n\t\tuint256 maxPrice = _oraclePriceOfShort(1e18);\n\t\t(minPrice, maxPrice) = maxPrice > minPrice ? (minPrice, maxPrice) : (maxPrice, minPrice);\n\t\toffset = ((maxPrice - minPrice) * BPS_ADJUST) / maxPrice;\n\t}\n\n\t// used to estimate the expected return of lp tokens for first deposit\n\tfunction collateralToUnderlying() external view returns (uint256) {\n\t\t(uint256 uR, uint256 sR, ) = pair().getReserves();\n\t\t(uR, sR) = address(_underlying) == pair().token0() ? (uR, sR) : (sR, uR);\n\t\tuint256 lp = pair().totalSupply();\n\t\treturn (1e18 * (uR * _getLiquidity(1e18))) / lp / _totalToLp(1e18);\n\t}\n\n\t// UTILS\n\n\tfunction _totalToLp(uint256 total) internal view returns (uint256) {\n\t\tuint256 cRatio = getCollateralRatio();\n\t\treturn (total * cRatio) / (BPS_ADJUST + cRatio);\n\t}\n\n\t// this is the current uniswap price\n\tfunction _shortToUnderlying(uint256 amount) internal view returns (uint256) {\n\t\treturn amount == 0 ? 0 : _quote(amount, address(_short), address(_underlying));\n\t}\n\n\t// this is the current uniswap price\n\tfunction _underlyingToShort(uint256 amount) internal view returns (uint256) {\n\t\treturn amount == 0 ? 0 : _quote(amount, address(_underlying), address(_short));\n\t}\n\n\t/**\n\t * @dev Returns the smallest of two numbers.\n\t */\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a < b ? a : b;\n\t}\n\n\treceive() external payable {}\n\n\terror NotPaused();\n\terror RebalanceThreshold();\n\terror NonZeroFloat();\n\terror MinLiquidity();\n}\n"
    },
    "src/strategies/mixins/IBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { HarvestSwapParms } from \"../../interfaces/Structs.sol\";\n\n// all interfaces need to inherit from base\nabstract contract IBase {\n\tbool public isInitialized;\n\n\tmodifier initializer() {\n\t\trequire(isInitialized == false, \"INITIALIZED\");\n\t\t_;\n\t}\n\n\tfunction short() public view virtual returns (IERC20);\n\n\tfunction underlying() public view virtual returns (IERC20);\n}\n"
    },
    "src/strategies/mixins/ILending.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IBase, HarvestSwapParms } from \"./IBase.sol\";\nimport { IFarmable, IUniswapV2Router01 } from \"./IFarmable.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract ILending is IBase {\n\tfunction _addLendingApprovals() internal virtual;\n\n\tfunction _getCollateralBalance() internal view virtual returns (uint256);\n\n\tfunction _getBorrowBalance() internal view virtual returns (uint256);\n\n\tfunction _updateAndGetCollateralBalance() internal virtual returns (uint256);\n\n\tfunction _updateAndGetBorrowBalance() internal virtual returns (uint256);\n\n\tfunction _getCollateralFactor() internal view virtual returns (uint256);\n\n\tfunction safeCollateralRatio() public view virtual returns (uint256);\n\n\tfunction _oraclePriceOfShort(uint256 amount) internal view virtual returns (uint256);\n\n\tfunction _oraclePriceOfUnderlying(uint256 amount) internal view virtual returns (uint256);\n\n\tfunction _lend(uint256 amount) internal virtual;\n\n\tfunction _redeem(uint256 amount) internal virtual;\n\n\tfunction _borrow(uint256 amount) internal virtual;\n\n\tfunction _repay(uint256 amount) internal virtual;\n\n\tfunction _harvestLending(HarvestSwapParms[] calldata swapParams)\n\t\tinternal\n\t\tvirtual\n\t\treturns (uint256[] memory);\n\n\tfunction lendFarmRouter() public view virtual returns (IUniswapV2Router01);\n\n\tfunction getCollateralRatio() public view virtual returns (uint256) {\n\t\treturn (_getCollateralFactor() * safeCollateralRatio()) / 1e18;\n\t}\n\n\t// returns loan health value which is collateralBalance / minCollateral\n\tfunction loanHealth() public view returns (uint256) {\n\t\tuint256 borrowValue = _oraclePriceOfShort(_getBorrowBalance());\n\t\tif (borrowValue == 0) return 100e18;\n\t\tuint256 collateralBalance = _getCollateralBalance();\n\t\tuint256 minCollateral = (borrowValue * 1e18) / _getCollateralFactor();\n\t\treturn (1e18 * collateralBalance) / minCollateral;\n\t}\n\n\tfunction _adjustCollateral(uint256 targetCollateral)\n\t\tinternal\n\t\treturns (uint256 added, uint256 removed)\n\t{\n\t\tuint256 collateralBalance = _getCollateralBalance();\n\t\tif (collateralBalance == targetCollateral) return (0, 0);\n\t\t(added, removed) = collateralBalance > targetCollateral\n\t\t\t? (uint256(0), _removeCollateral(collateralBalance - targetCollateral))\n\t\t\t: (_addCollateral(targetCollateral - collateralBalance), uint256(0));\n\t}\n\n\tfunction _removeCollateral(uint256 amountToRemove) internal returns (uint256 removed) {\n\t\tuint256 maxRemove = _freeCollateral();\n\t\tremoved = maxRemove > amountToRemove ? amountToRemove : maxRemove;\n\t\tif (removed > 0) _redeem(removed);\n\t}\n\n\tfunction _freeCollateral() internal view returns (uint256) {\n\t\tuint256 collateral = _getCollateralBalance();\n\t\tuint256 borrowValue = _oraclePriceOfShort(_getBorrowBalance());\n\t\t// stay within 1% of the liquidation threshold (this is allways temporary)\n\t\tuint256 minCollateral = (100 * (borrowValue * 1e18)) / _getCollateralFactor() / 99;\n\t\tif (minCollateral > collateral) return 0;\n\t\treturn collateral - minCollateral;\n\t}\n\n\tfunction _addCollateral(uint256 amountToAdd) internal returns (uint256 added) {\n\t\tuint256 underlyingBalance = underlying().balanceOf(address(this));\n\t\tadded = underlyingBalance > amountToAdd ? amountToAdd : underlyingBalance;\n\t\tif (added != 0) _lend(added);\n\t}\n\n\tfunction _maxBorrow() internal view virtual returns (uint256);\n}\n"
    },
    "src/strategies/mixins/IUniFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IBase, HarvestSwapParms } from \"./IBase.sol\";\nimport { IUniLp, SafeERC20, IERC20 } from \"./IUniLp.sol\";\nimport { IFarmable, IUniswapV2Router01 } from \"./IFarmable.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract IUniFarm is IBase, IUniLp, IFarmable {\n\tfunction _depositIntoFarm(uint256 amount) internal virtual;\n\n\tfunction _withdrawFromFarm(uint256 amount) internal virtual;\n\n\tfunction _harvestFarm(HarvestSwapParms[] calldata swapParams)\n\t\tinternal\n\t\tvirtual\n\t\treturns (uint256[] memory);\n\n\tfunction _getFarmLp() internal view virtual returns (uint256);\n\n\tfunction _addFarmApprovals() internal virtual;\n\n\tfunction farmRouter() public view virtual returns (IUniswapV2Router01);\n}\n"
    },
    "src/strategies/mixins/IFarmable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IUniswapV2Router01 } from \"../../interfaces/uniswap/IUniswapV2Router01.sol\";\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { HarvestSwapParms, IBase } from \"./IBase.sol\";\n\nabstract contract IFarmable is IBase {\n\tusing SafeERC20 for IERC20;\n\n\tevent HarvestedToken(address indexed token, uint256 amount);\n\n\tfunction _swap(\n\t\tIUniswapV2Router01 router,\n\t\tHarvestSwapParms calldata swapParams,\n\t\taddress from,\n\t\tuint256 amount\n\t) internal {\n\t\taddress out = swapParams.path[swapParams.path.length - 1];\n\t\t// ensure malicious harvester is not trading with wrong tokens\n\t\t// TODO should we add more validation to prevent malicious path?\n\t\trequire(\n\t\t\t((swapParams.path[0] == address(from) && (out == address(short()))) ||\n\t\t\t\tout == address(underlying())),\n\t\t\t\"IFarmable: WRONG_PATH\"\n\t\t);\n\t\trouter.swapExactTokensForTokens(\n\t\t\tamount,\n\t\t\tswapParams.min,\n\t\t\tswapParams.path, // optimal route determined externally\n\t\t\taddress(this),\n\t\t\tswapParams.deadline\n\t\t);\n\t}\n}\n"
    },
    "src/strategies/mixins/IUniLp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IUniswapV2Pair } from \"../../interfaces/uniswap/IUniswapV2Pair.sol\";\nimport { UniUtils } from \"../../libraries/UniUtils.sol\";\n\nimport { IBase } from \"./IBase.sol\";\nimport { ILp } from \"./ILp.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract IUniLp is IBase, ILp {\n\tusing SafeERC20 for IERC20;\n\tusing UniUtils for IUniswapV2Pair;\n\n\tfunction pair() public view virtual returns (IUniswapV2Pair);\n\n\t// should only be called after oracle or user-input swap price check\n\tfunction _addLiquidity(uint256 amountToken0, uint256 amountToken1)\n\t\tinternal\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256 liquidity)\n\t{\n\t\tunderlying().safeTransfer(address(pair()), amountToken0);\n\t\tshort().safeTransfer(address(pair()), amountToken1);\n\t\tliquidity = pair().mint(address(this));\n\t}\n\n\tfunction _removeLiquidity(uint256 liquidity)\n\t\tinternal\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256, uint256)\n\t{\n\t\tIERC20(address(pair())).safeTransfer(address(pair()), liquidity);\n\t\t(address tokenA, ) = UniUtils._sortTokens(address(underlying()), address(short()));\n\t\t(uint256 amountToken0, uint256 amountToken1) = pair().burn(address(this));\n\t\treturn\n\t\t\ttokenA == address(underlying())\n\t\t\t\t? (amountToken0, amountToken1)\n\t\t\t\t: (amountToken1, amountToken0);\n\t}\n\n\tfunction _quote(\n\t\tuint256 amount,\n\t\taddress token0,\n\t\taddress token1\n\t) internal view virtual override returns (uint256 price) {\n\t\tif (amount == 0) return 0;\n\t\t(uint256 reserve0, uint256 reserve1) = pair()._getPairReserves(token0, token1);\n\t\tprice = UniUtils._quote(amount, reserve0, reserve1);\n\t}\n\n\t// fetches and sorts the reserves for a uniswap pair\n\tfunction getUnderlyingShortReserves() public view returns (uint256 reserveA, uint256 reserveB) {\n\t\t(reserveA, reserveB) = pair()._getPairReserves(address(underlying()), address(short()));\n\t}\n\n\tfunction _getLPBalances()\n\t\tinternal\n\t\tview\n\t\toverride\n\t\treturns (uint256 underlyingBalance, uint256 shortBalance)\n\t{\n\t\tuint256 totalLp = _getLiquidity();\n\t\t(uint256 totalUnderlyingBalance, uint256 totalShortBalance) = getUnderlyingShortReserves();\n\t\tuint256 total = pair().totalSupply();\n\t\tunderlyingBalance = (totalUnderlyingBalance * totalLp) / total;\n\t\tshortBalance = (totalShortBalance * totalLp) / total;\n\t}\n}\n"
    },
    "src/strategies/hlp/implementations/MasterChefCompMulti.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { HLPConfig, NativeToken } from \"../../../interfaces/Structs.sol\";\nimport { HLPCore } from \"../HLPCore.sol\";\nimport { Compound } from \"../adapters/Compound.sol\";\nimport { MasterChefFarm } from \"../adapters/MasterChefFarm.sol\";\nimport { CompMultiFarm } from \"../adapters/CompMultiFarm.sol\";\nimport { Auth, AuthConfig } from \"../../../common/Auth.sol\";\n\n// import \"hardhat/console.sol\";\n\n// USED BY:\n// USDCmovrSOLARwell\ncontract MasterChefCompMulti is HLPCore, Compound, CompMultiFarm, MasterChefFarm {\n\t// HedgedLP should allways be intialized last\n\tconstructor(AuthConfig memory authConfig, HLPConfig memory config) Auth(authConfig) {\n\t\t__MasterChefFarm_init_(\n\t\t\tconfig.uniPair,\n\t\t\tconfig.uniFarm,\n\t\t\tconfig.farmRouter,\n\t\t\tconfig.farmToken,\n\t\t\tconfig.farmId\n\t\t);\n\n\t\t__Compound_init_(config.comptroller, config.cTokenLend, config.cTokenBorrow);\n\n\t\t__CompoundFarm_init_(config.lendRewardRouter, config.lendRewardToken);\n\n\t\t__HedgedLP_init_(config.underlying, config.short, config.maxTvl, config.vault);\n\n\t\tnativeToken = config.nativeToken;\n\t}\n}\n"
    },
    "src/strategies/hlp/adapters/Compound.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { ICTokenErc20 } from \"../../../interfaces/compound/ICTokenInterfaces.sol\";\nimport { IComptroller } from \"../../../interfaces/compound/IComptroller.sol\";\nimport { ICompPriceOracle } from \"../../../interfaces/compound/ICompPriceOracle.sol\";\nimport { IComptroller, ComptrollerV1Storage } from \"../../../interfaces/compound/IComptroller.sol\";\n\nimport { ICompound, SafeERC20, IERC20 } from \"../../mixins/ICompound.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract Compound is ICompound {\n\tusing SafeERC20 for IERC20;\n\n\tICTokenErc20 private _cTokenLend;\n\tICTokenErc20 private _cTokenBorrow;\n\n\tIComptroller private _comptroller;\n\tICompPriceOracle private _oracle;\n\n\tfunction __Compound_init_(\n\t\taddress comptroller_,\n\t\taddress cTokenLend_,\n\t\taddress cTokenBorrow_\n\t) internal {\n\t\t_cTokenLend = ICTokenErc20(cTokenLend_);\n\t\t_cTokenBorrow = ICTokenErc20(cTokenBorrow_);\n\t\t_comptroller = IComptroller(comptroller_);\n\t\t_oracle = ICompPriceOracle(ComptrollerV1Storage(comptroller_).oracle());\n\t\t_enterMarket();\n\t}\n\n\tfunction _addLendingApprovals() internal override {\n\t\t// ensure USDC approval - assume we trust USDC\n\t\tunderlying().safeApprove(address(_cTokenLend), type(uint256).max);\n\t\tshort().safeApprove(address(_cTokenBorrow), type(uint256).max);\n\t}\n\n\tfunction cTokenLend() public view override returns (ICTokenErc20) {\n\t\treturn _cTokenLend;\n\t}\n\n\tfunction cTokenBorrow() public view override returns (ICTokenErc20) {\n\t\treturn _cTokenBorrow;\n\t}\n\n\tfunction oracle() public view override returns (ICompPriceOracle) {\n\t\treturn _oracle;\n\t}\n\n\tfunction comptroller() public view override returns (IComptroller) {\n\t\treturn _comptroller;\n\t}\n}\n"
    },
    "src/strategies/hlp/adapters/MasterChefFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IMasterChef } from \"../../../interfaces/uniswap/IStakingRewards.sol\";\nimport { IUniswapV2Pair } from \"../../../interfaces/uniswap/IUniswapV2Pair.sol\";\n\nimport { IUniFarm, IUniswapV2Router01, HarvestSwapParms } from \"../../mixins/IUniFarm.sol\";\nimport { IWETH } from \"../../../interfaces/uniswap/IWETH.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract MasterChefFarm is IUniFarm {\n\tusing SafeERC20 for IERC20;\n\n\tIMasterChef private _farm;\n\tIUniswapV2Router01 private _router;\n\tIERC20 private _farmToken;\n\tIUniswapV2Pair private _pair;\n\tuint256 private _farmId;\n\n\tfunction __MasterChefFarm_init_(\n\t\taddress pair_,\n\t\taddress farm_,\n\t\taddress router_,\n\t\taddress farmToken_,\n\t\tuint256 farmPid_\n\t) internal initializer {\n\t\t_farm = IMasterChef(farm_);\n\t\t_router = IUniswapV2Router01(router_);\n\t\t_farmToken = IERC20(farmToken_);\n\t\t_pair = IUniswapV2Pair(pair_);\n\t\t_farmId = farmPid_;\n\t}\n\n\t// assumption that _router and _farm are trusted\n\tfunction _addFarmApprovals() internal override {\n\t\tIERC20(address(_pair)).safeApprove(address(_farm), type(uint256).max);\n\t\tif (_farmToken.allowance(address(this), address(_router)) == 0)\n\t\t\t_farmToken.safeApprove(address(_router), type(uint256).max);\n\t}\n\n\tfunction farmRouter() public view override returns (IUniswapV2Router01) {\n\t\treturn _router;\n\t}\n\n\tfunction pair() public view override returns (IUniswapV2Pair) {\n\t\treturn _pair;\n\t}\n\n\tfunction _withdrawFromFarm(uint256 amount) internal override {\n\t\t_farm.withdraw(_farmId, amount);\n\t}\n\n\tfunction _depositIntoFarm(uint256 amount) internal override {\n\t\t_farm.deposit(_farmId, amount);\n\t}\n\n\tfunction _harvestFarm(HarvestSwapParms[] calldata swapParams)\n\t\tinternal\n\t\toverride\n\t\treturns (uint256[] memory harvested)\n\t{\n\t\taddress[] memory addresses;\n\t\tuint256[] memory amounts;\n\n\t\t_farm.deposit(_farmId, 0);\n\t\tharvested = new uint256[](1);\n\t\tharvested[0] = _farmToken.balanceOf(address(this));\n\t\tif (harvested[0] == 0) return harvested;\n\n\t\t_swap(_router, swapParams[0], address(_farmToken), harvested[0]);\n\t\temit HarvestedToken(address(_farmToken), harvested[0]);\n\n\t\t// additional chain token rewards\n\t\tuint256 ethBalance = address(this).balance;\n\t\tif (ethBalance > 0) {\n\t\t\tIWETH(address(short())).deposit{ value: ethBalance }();\n\t\t\temit HarvestedToken(address(short()), ethBalance);\n\t\t}\n\t}\n\n\tfunction _getFarmLp() internal view override returns (uint256) {\n\t\t(uint256 lp, ) = _farm.userInfo(_farmId, address(this));\n\t\treturn lp;\n\t}\n\n\tfunction _getLiquidity(uint256 lpTokenBalance) internal view override returns (uint256) {\n\t\tuint256 farmLp = _getFarmLp();\n\t\treturn farmLp + lpTokenBalance;\n\t}\n\n\tfunction _getLiquidity() internal view override returns (uint256) {\n\t\tuint256 farmLp = _getFarmLp();\n\t\tuint256 poolLp = _pair.balanceOf(address(this));\n\t\treturn farmLp + poolLp;\n\t}\n}\n"
    },
    "src/strategies/hlp/adapters/CompMultiFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IClaimReward } from \"../../../interfaces/compound/IClaimReward.sol\";\nimport { CompoundFarm, HarvestSwapParms } from \"./CompoundFarm.sol\";\nimport { IWETH } from \"../../../interfaces/uniswap/IWETH.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract CompMultiFarm is CompoundFarm {\n\t// BenQi has two two token rewards\n\t// pid 0 is Qi token and pid 1 is AVAX (not wrapped)\n\tfunction _harvestLending(HarvestSwapParms[] calldata swapParams)\n\t\tinternal\n\t\toverride\n\t\treturns (uint256[] memory harvested)\n\t{\n\t\t// farm token on id 0\n\t\tIClaimReward(address(comptroller())).claimReward(0, payable(address(this)));\n\t\tharvested = new uint256[](1);\n\t\tharvested[0] = _farmToken.balanceOf(address(this));\n\n\t\tif (harvested[0] > 0) {\n\t\t\t_swap(lendFarmRouter(), swapParams[0], address(_farmToken), harvested[0]);\n\t\t\temit HarvestedToken(address(_farmToken), harvested[0]);\n\t\t}\n\n\t\t// base token rewards on id 1\n\t\tIClaimReward(address(comptroller())).claimReward(1, payable(address(this)));\n\n\t\tuint256 avaxBalance = address(this).balance;\n\t\tif (avaxBalance > 0) {\n\t\t\tIWETH(address(short())).deposit{ value: avaxBalance }();\n\t\t\temit HarvestedToken(address(short()), avaxBalance);\n\t\t}\n\t}\n}\n"
    },
    "src/interfaces/compound/ICTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"./IComptroller.sol\";\nimport \"./InterestRateModel.sol\";\n\ninterface ICTokenStorage {\n\t/**\n\t * @dev Container for borrow balance information\n\t * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n\t * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n\t */\n\tstruct BorrowSnapshot {\n\t\tuint256 principal;\n\t\tuint256 interestIndex;\n\t}\n}\n\ninterface ICToken is ICTokenStorage {\n\t/*** Market Events ***/\n\n\t/**\n\t * @dev Event emitted when interest is accrued\n\t */\n\tevent AccrueInterest(\n\t\tuint256 cashPrior,\n\t\tuint256 interestAccumulated,\n\t\tuint256 borrowIndex,\n\t\tuint256 totalBorrows\n\t);\n\n\t/**\n\t * @dev Event emitted when tokens are minted\n\t */\n\tevent Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n\t/**\n\t * @dev Event emitted when tokens are redeemed\n\t */\n\tevent Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n\t/**\n\t * @dev Event emitted when underlying is borrowed\n\t */\n\tevent Borrow(\n\t\taddress borrower,\n\t\tuint256 borrowAmount,\n\t\tuint256 accountBorrows,\n\t\tuint256 totalBorrows\n\t);\n\n\t/**\n\t * @dev Event emitted when a borrow is repaid\n\t */\n\tevent RepayBorrow(\n\t\taddress payer,\n\t\taddress borrower,\n\t\tuint256 repayAmount,\n\t\tuint256 accountBorrows,\n\t\tuint256 totalBorrows\n\t);\n\n\t/**\n\t * @dev Event emitted when a borrow is liquidated\n\t */\n\tevent LiquidateBorrow(\n\t\taddress liquidator,\n\t\taddress borrower,\n\t\tuint256 repayAmount,\n\t\taddress cTokenCollateral,\n\t\tuint256 seizeTokens\n\t);\n\n\t/*** Admin Events ***/\n\n\t/**\n\t * @dev Event emitted when pendingAdmin is changed\n\t */\n\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n\t/**\n\t * @dev Event emitted when pendingAdmin is accepted, which means admin is updated\n\t */\n\tevent NewAdmin(address oldAdmin, address newAdmin);\n\n\t/**\n\t * @dev Event emitted when comptroller is changed\n\t */\n\tevent NewComptroller(IComptroller oldComptroller, IComptroller newComptroller);\n\n\t/**\n\t * @dev Event emitted when interestRateModel is changed\n\t */\n\tevent NewMarketInterestRateModel(\n\t\tInterestRateModel oldInterestRateModel,\n\t\tInterestRateModel newInterestRateModel\n\t);\n\n\t/**\n\t * @dev Event emitted when the reserve factor is changed\n\t */\n\tevent NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\n\n\t/**\n\t * @dev Event emitted when the reserves are added\n\t */\n\tevent ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);\n\n\t/**\n\t * @dev Event emitted when the reserves are reduced\n\t */\n\tevent ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);\n\n\t/**\n\t * @dev EIP20 Transfer event\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 amount);\n\n\t/**\n\t * @dev EIP20 Approval event\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 amount);\n\n\t/**\n\t * @dev Failure event\n\t */\n\tevent Failure(uint256 error, uint256 info, uint256 detail);\n\n\t/*** User Interface ***/\n\tfunction totalBorrows() external view returns (uint256);\n\n\tfunction totalReserves() external view returns (uint256);\n\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction transfer(address dst, uint256 amount) external returns (bool);\n\n\tfunction transferFrom(\n\t\taddress src,\n\t\taddress dst,\n\t\tuint256 amount\n\t) external returns (bool);\n\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\tfunction balanceOf(address owner) external view returns (uint256);\n\n\tfunction balanceOfUnderlying(address owner) external returns (uint256);\n\n\tfunction getAccountSnapshot(address account)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256,\n\t\t\tuint256,\n\t\t\tuint256,\n\t\t\tuint256\n\t\t);\n\n\tfunction borrowRatePerBlock() external view returns (uint256);\n\n\tfunction supplyRatePerBlock() external view returns (uint256);\n\n\tfunction totalBorrowsCurrent() external returns (uint256);\n\n\tfunction borrowBalanceCurrent(address account) external returns (uint256);\n\n\tfunction borrowBalanceStored(address account) external view returns (uint256);\n\n\tfunction exchangeRateCurrent() external returns (uint256);\n\n\tfunction exchangeRateStored() external view returns (uint256);\n\n\tfunction getCash() external view returns (uint256);\n\n\tfunction accrueInterest() external returns (uint256);\n\n\tfunction seize(\n\t\taddress liquidator,\n\t\taddress borrower,\n\t\tuint256 seizeTokens\n\t) external returns (uint256);\n\n\t/*** Admin Functions ***/\n\n\tfunction _setPendingAdmin(address payable newPendingAdmin) external returns (uint256);\n\n\tfunction _acceptAdmin() external returns (uint256);\n\n\tfunction _setComptroller(IComptroller newComptroller) external returns (uint256);\n\n\tfunction _setReserveFactor(uint256 newReserveFactorMantissa) external returns (uint256);\n\n\tfunction _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n\tfunction _setInterestRateModel(InterestRateModel newInterestRateModel)\n\t\texternal\n\t\treturns (uint256);\n}\n\ninterface ICTokenErc20 is ICToken {\n\t/*** User Interface ***/\n\n\tfunction mint(uint256 mintAmount) external returns (uint256);\n\n\tfunction redeem(uint256 redeemTokens) external returns (uint256);\n\n\tfunction redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n\tfunction borrow(uint256 borrowAmount) external returns (uint256);\n\n\tfunction repayBorrow(uint256 repayAmount) external returns (uint256);\n\n\tfunction liquidateBorrow(\n\t\taddress borrower,\n\t\tuint256 repayAmount,\n\t\tICToken cTokenCollateral\n\t) external returns (uint256);\n\n\t/*** Admin Functions ***/\n\n\tfunction _addReserves(uint256 addAmount) external returns (uint256);\n}\n\ninterface ICTokenBase is ICToken {\n\tfunction repayBorrow() external payable;\n}\n"
    },
    "src/interfaces/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"./ICTokenInterfaces.sol\";\n\ninterface IComptroller {\n\t/*** Assets You Are In ***/\n\n\tfunction enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\n\n\tfunction exitMarket(address cToken) external returns (uint256);\n\n\t/*** Policy Hooks ***/\n\n\tfunction mintAllowed(\n\t\taddress cToken,\n\t\taddress minter,\n\t\tuint256 mintAmount\n\t) external returns (uint256);\n\n\tfunction mintVerify(\n\t\taddress cToken,\n\t\taddress minter,\n\t\tuint256 mintAmount,\n\t\tuint256 mintTokens\n\t) external;\n\n\tfunction redeemAllowed(\n\t\taddress cToken,\n\t\taddress redeemer,\n\t\tuint256 redeemTokens\n\t) external returns (uint256);\n\n\tfunction redeemVerify(\n\t\taddress cToken,\n\t\taddress redeemer,\n\t\tuint256 redeemAmount,\n\t\tuint256 redeemTokens\n\t) external;\n\n\tfunction borrowAllowed(\n\t\taddress cToken,\n\t\taddress borrower,\n\t\tuint256 borrowAmount\n\t) external returns (uint256);\n\n\tfunction borrowVerify(\n\t\taddress cToken,\n\t\taddress borrower,\n\t\tuint256 borrowAmount\n\t) external;\n\n\tfunction repayBorrowAllowed(\n\t\taddress cToken,\n\t\taddress payer,\n\t\taddress borrower,\n\t\tuint256 repayAmount\n\t) external returns (uint256);\n\n\tfunction repayBorrowVerify(\n\t\taddress cToken,\n\t\taddress payer,\n\t\taddress borrower,\n\t\tuint256 repayAmount,\n\t\tuint256 borrowerIndex\n\t) external;\n\n\tfunction liquidateBorrowAllowed(\n\t\taddress cTokenBorrowed,\n\t\taddress cTokenCollateral,\n\t\taddress liquidator,\n\t\taddress borrower,\n\t\tuint256 repayAmount\n\t) external returns (uint256);\n\n\tfunction liquidateBorrowVerify(\n\t\taddress cTokenBorrowed,\n\t\taddress cTokenCollateral,\n\t\taddress liquidator,\n\t\taddress borrower,\n\t\tuint256 repayAmount,\n\t\tuint256 seizeTokens\n\t) external;\n\n\tfunction seizeAllowed(\n\t\taddress cTokenCollateral,\n\t\taddress cTokenBorrowed,\n\t\taddress liquidator,\n\t\taddress borrower,\n\t\tuint256 seizeTokens\n\t) external returns (uint256);\n\n\tfunction seizeVerify(\n\t\taddress cTokenCollateral,\n\t\taddress cTokenBorrowed,\n\t\taddress liquidator,\n\t\taddress borrower,\n\t\tuint256 seizeTokens\n\t) external;\n\n\tfunction transferAllowed(\n\t\taddress cToken,\n\t\taddress src,\n\t\taddress dst,\n\t\tuint256 transferTokens\n\t) external returns (uint256);\n\n\tfunction transferVerify(\n\t\taddress cToken,\n\t\taddress src,\n\t\taddress dst,\n\t\tuint256 transferTokens\n\t) external;\n\n\tfunction claimComp(address holder) external;\n\n\tfunction claimComp(address holder, ICTokenErc20[] memory cTokens) external;\n\n\t/*** Liquidity/Liquidation Calculations ***/\n\n\tfunction liquidateCalculateSeizeTokens(\n\t\taddress cTokenBorrowed,\n\t\taddress cTokenCollateral,\n\t\tuint256 repayAmount\n\t) external view returns (uint256, uint256);\n}\n\ninterface UnitrollerAdminStorage {\n\t/**\n\t * @notice Administrator for this contract\n\t */\n\t// address external admin;\n\tfunction admin() external view returns (address);\n\n\t/**\n\t * @notice Pending administrator for this contract\n\t */\n\t// address external pendingAdmin;\n\tfunction pendingAdmin() external view returns (address);\n\n\t/**\n\t * @notice Active brains of Unitroller\n\t */\n\t// address external comptrollerImplementation;\n\tfunction comptrollerImplementation() external view returns (address);\n\n\t/**\n\t * @notice Pending brains of Unitroller\n\t */\n\t// address external pendingComptrollerImplementation;\n\tfunction pendingComptrollerImplementation() external view returns (address);\n}\n\ninterface ComptrollerV1Storage is UnitrollerAdminStorage {\n\t/**\n\t * @notice Oracle which gives the price of any given asset\n\t */\n\t// PriceOracle external oracle;\n\tfunction oracle() external view returns (address);\n\n\t/**\n\t * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n\t */\n\t// uint external closeFactorMantissa;\n\tfunction closeFactorMantissa() external view returns (uint256);\n\n\t/**\n\t * @notice Multiplier representing the discount on collateral that a liquidator receives\n\t */\n\t// uint external liquidationIncentiveMantissa;\n\tfunction liquidationIncentiveMantissa() external view returns (uint256);\n\n\t/**\n\t * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n\t */\n\t// uint external maxAssets;\n\tfunction maxAssets() external view returns (uint256);\n\n\t/**\n\t * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n\t */\n\t// mapping(address => CToken[]) external accountAssets;\n\t// function accountAssets(address) external view returns (CToken[]);\n}\n\nabstract contract ComptrollerV2Storage is ComptrollerV1Storage {\n\tenum Version {\n\t\tVANILLA,\n\t\tCOLLATERALCAP,\n\t\tWRAPPEDNATIVE\n\t}\n\n\tstruct Market {\n\t\tbool isListed;\n\t\tuint256 collateralFactorMantissa;\n\t\tmapping(address => bool) accountMembership;\n\t\tbool isComped;\n\t\t// Version version;\n\t}\n\n\t/**\n\t * @notice Official mapping of cTokens -> Market metadata\n\t * @dev Used e.g. to determine if a market is supported\n\t */\n\tmapping(address => Market) public markets;\n\n\t/**\n\t * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n\t *  Actions which allow users to remove their own assets cannot be paused.\n\t *  Liquidation / seizing / transfer can only be paused globally, not by market.\n\t */\n\t// address external pauseGuardian;\n\t// bool external _mintGuardianPaused;\n\t// bool external _borrowGuardianPaused;\n\t// bool external transferGuardianPaused;\n\t// bool external seizeGuardianPaused;\n\t// mapping(address => bool) external mintGuardianPaused;\n\t// mapping(address => bool) external borrowGuardianPaused;\n}\n\nabstract contract ComptrollerV3Storage is ComptrollerV2Storage {\n\t// struct CompMarketState {\n\t//     /// @notice The market's last updated compBorrowIndex or compSupplyIndex\n\t//     uint224 index;\n\t//     /// @notice The block number the index was last updated at\n\t//     uint32 block;\n\t// }\n\t// /// @notice A list of all markets\n\t// CToken[] external allMarkets;\n\t// /// @notice The rate at which the flywheel distributes COMP, per block\n\t// uint external compRate;\n\t// /// @notice The portion of compRate that each market currently receives\n\t// mapping(address => uint) external compSpeeds;\n\t// /// @notice The COMP market supply state for each market\n\t// mapping(address => CompMarketState) external compSupplyState;\n\t// /// @notice The COMP market borrow state for each market\n\t// mapping(address => CompMarketState) external compBorrowState;\n\t// /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\n\t// mapping(address => mapping(address => uint)) external compSupplierIndex;\n\t// /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\n\t// mapping(address => mapping(address => uint)) external compBorrowerIndex;\n\t// /// @notice The COMP accrued but not yet transferred to each user\n\t// mapping(address => uint) external compAccrued;\n}\n\nabstract contract ComptrollerV4Storage is ComptrollerV3Storage {\n\t// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n\t// address external borrowCapGuardian;\n\tfunction borrowCapGuardian() external view virtual returns (address);\n\n\t// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n\t// mapping(address => uint) external borrowCaps;\n\tfunction borrowCaps(address) external view virtual returns (uint256);\n}\n\nabstract contract ComptrollerV5Storage is ComptrollerV4Storage {\n\t// @notice The supplyCapGuardian can set supplyCaps to any number for any market. Lowering the supply cap could disable supplying to the given market.\n\t// address external supplyCapGuardian;\n\tfunction supplyCapGuardian() external view virtual returns (address);\n\n\t// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n\t// mapping(address => uint) external supplyCaps;\n\tfunction supplyCaps(address) external view virtual returns (uint256);\n}\n"
    },
    "src/interfaces/compound/ICompPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"./ICTokenInterfaces.sol\";\n\ninterface ICompPriceOracle {\n\tfunction isPriceOracle() external view returns (bool);\n\n\t/**\n\t * @notice Get the underlying price of a cToken asset\n\t * @param cToken The cToken to get the underlying price of\n\t * @return The underlying asset price mantissa (scaled by 1e18).\n\t *  Zero means the price is unavailable.\n\t */\n\tfunction getUnderlyingPrice(address cToken) external view returns (uint256);\n}\n"
    },
    "src/strategies/mixins/ICompound.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC20, SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ICTokenErc20, ICTokenBase } from \"../../interfaces/compound/ICTokenInterfaces.sol\";\nimport { IComptroller, ComptrollerV2Storage } from \"../../interfaces/compound/IComptroller.sol\";\nimport { ICompPriceOracle } from \"../../interfaces/compound/ICompPriceOracle.sol\";\n\nimport { IWETH } from \"../../interfaces/uniswap/IWETH.sol\";\n\nimport { ILending } from \"./ILending.sol\";\nimport { IBase } from \"./IBase.sol\";\nimport { NativeToken } from \"../../interfaces/Structs.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract ICompound is ILending {\n\tusing SafeERC20 for IERC20;\n\n\tNativeToken public nativeToken = NativeToken.None;\n\n\tfunction cTokenLend() public view virtual returns (ICTokenErc20);\n\n\tfunction cTokenBorrow() public view virtual returns (ICTokenErc20);\n\n\tfunction oracle() public view virtual returns (ICompPriceOracle);\n\n\tfunction comptroller() public view virtual returns (IComptroller);\n\n\tfunction _enterMarket() internal {\n\t\taddress[] memory cTokens = new address[](2);\n\t\tcTokens[0] = address(cTokenLend());\n\t\tcTokens[1] = address(cTokenBorrow());\n\t\tcomptroller().enterMarkets(cTokens);\n\t}\n\n\tfunction _getCollateralFactor() internal view override returns (uint256) {\n\t\t(, uint256 collateralFactorMantissa, ) = ComptrollerV2Storage(address(comptroller()))\n\t\t\t.markets(address(cTokenLend()));\n\t\treturn collateralFactorMantissa;\n\t}\n\n\tfunction _redeem(uint256 amount) internal override {\n\t\t// TODO handle native underlying\n\t\tuint256 err = cTokenLend().redeemUnderlying(amount);\n\t\trequire(err == 0, \"Compund: error redeeming underlying\");\n\t}\n\n\tfunction _borrow(uint256 amount) internal override {\n\t\tcTokenBorrow().borrow(amount);\n\n\t\t// in case we need to wrap the tokens\n\t\tif (nativeToken == NativeToken.Short) IWETH(address(short())).deposit{ value: amount }();\n\t}\n\n\tfunction _lend(uint256 amount) internal override {\n\t\t// TODO handle native underlying\n\t\tcTokenLend().mint(amount);\n\t}\n\n\tfunction _repay(uint256 amount) internal override {\n\t\tif (nativeToken == NativeToken.Short) {\n\t\t\t// need to convert to base first\n\t\t\tIWETH(address(short())).withdraw(amount);\n\n\t\t\t// then repay in the base\n\t\t\t_repayBase(amount);\n\t\t\treturn;\n\t\t}\n\t\tcTokenBorrow().repayBorrow(amount);\n\t}\n\n\tfunction _repayBase(uint256 amount) internal {\n\t\tICTokenBase(address(cTokenBorrow())).repayBorrow{ value: amount }();\n\t}\n\n\tfunction _updateAndGetCollateralBalance() internal override returns (uint256) {\n\t\treturn cTokenLend().balanceOfUnderlying(address(this));\n\t}\n\n\tfunction _getCollateralBalance() internal view override returns (uint256) {\n\t\tuint256 b = cTokenLend().balanceOf(address(this));\n\t\treturn (b * cTokenLend().exchangeRateStored()) / 1e18;\n\t}\n\n\tfunction _updateAndGetBorrowBalance() internal override returns (uint256) {\n\t\treturn cTokenBorrow().borrowBalanceCurrent(address(this));\n\t}\n\n\tfunction _getBorrowBalance() internal view override returns (uint256 shortBorrow) {\n\t\tshortBorrow = cTokenBorrow().borrowBalanceStored(address(this));\n\t}\n\n\tfunction _oraclePriceOfShort(uint256 amount) internal view override returns (uint256) {\n\t\treturn\n\t\t\t(amount * oracle().getUnderlyingPrice(address(cTokenBorrow()))) /\n\t\t\toracle().getUnderlyingPrice(address(cTokenLend()));\n\t}\n\n\tfunction _oraclePriceOfUnderlying(uint256 amount) internal view override returns (uint256) {\n\t\treturn\n\t\t\t(amount * oracle().getUnderlyingPrice(address(cTokenLend()))) /\n\t\t\toracle().getUnderlyingPrice(address(cTokenBorrow()));\n\t}\n\n\tfunction _maxBorrow() internal view virtual override returns (uint256) {\n\t\treturn cTokenBorrow().getCash();\n\t}\n}\n"
    },
    "src/interfaces/compound/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\ninterface InterestRateModel {\n\t/**\n\t * @dev Calculates the current borrow interest rate per block\n\t * @param cash The total amount of cash the market has\n\t * @param borrows The total amount of borrows the market has outstanding\n\t * @param reserves The total amnount of reserves the market has\n\t * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n\t */\n\tfunction getBorrowRate(\n\t\tuint256 cash,\n\t\tuint256 borrows,\n\t\tuint256 reserves\n\t) external view returns (uint256);\n\n\t/**\n\t * @dev Calculates the current supply interest rate per block\n\t * @param cash The total amount of cash the market has\n\t * @param borrows The total amount of borrows the market has outstanding\n\t * @param reserves The total amnount of reserves the market has\n\t * @param reserveFactorMantissa The current reserve factor the market has\n\t * @return The supply rate per block (as a percentage, and scaled by 1e18)\n\t */\n\tfunction getSupplyRate(\n\t\tuint256 cash,\n\t\tuint256 borrows,\n\t\tuint256 reserves,\n\t\tuint256 reserveFactorMantissa\n\t) external view returns (uint256);\n}\n"
    },
    "src/interfaces/uniswap/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStakingRewards is IERC20 {\n\tfunction stakingToken() external view returns (address);\n\n\tfunction lastTimeRewardApplicable() external view returns (uint256);\n\n\tfunction rewardPerToken() external view returns (uint256);\n\n\tfunction earned(address account) external view returns (uint256);\n\n\tfunction getRewardForDuration() external view returns (uint256);\n\n\tfunction stakeWithPermit(\n\t\tuint256 amount,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\tfunction stake(uint256 amount) external;\n\n\tfunction withdraw(uint256 amount) external;\n\n\tfunction getReward() external;\n\n\tfunction exit() external;\n}\n\n// some farms use sushi interface\ninterface IMasterChef {\n\t// depositing 0 amount will withdraw the rewards (harvest)\n\tfunction deposit(uint256 _pid, uint256 _amount) external;\n\n\tfunction withdraw(uint256 _pid, uint256 _amount) external;\n\n\tfunction userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n\n\tfunction emergencyWithdraw(uint256 _pid) external;\n\n\tfunction pendingTokens(uint256 _pid, address _user)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256,\n\t\t\taddress,\n\t\t\tstring memory,\n\t\t\tuint256\n\t\t);\n}\n\ninterface IMiniChefV2 {\n\tstruct UserInfo {\n\t\tuint256 amount;\n\t\tint256 rewardDebt;\n\t}\n\n\tstruct PoolInfo {\n\t\tuint128 accSushiPerShare;\n\t\tuint64 lastRewardTime;\n\t\tuint64 allocPoint;\n\t}\n\n\tfunction poolLength() external view returns (uint256);\n\n\tfunction updatePool(uint256 pid) external returns (IMiniChefV2.PoolInfo memory);\n\n\tfunction userInfo(uint256 _pid, address _user) external view returns (uint256, int256);\n\n\tfunction deposit(\n\t\tuint256 pid,\n\t\tuint256 amount,\n\t\taddress to\n\t) external;\n\n\tfunction withdraw(\n\t\tuint256 pid,\n\t\tuint256 amount,\n\t\taddress to\n\t) external;\n\n\tfunction harvest(uint256 pid, address to) external;\n\n\tfunction withdrawAndHarvest(\n\t\tuint256 pid,\n\t\tuint256 amount,\n\t\taddress to\n\t) external;\n\n\tfunction emergencyWithdraw(uint256 pid, address to) external;\n}\n"
    },
    "src/interfaces/compound/IClaimReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nabstract contract IClaimReward {\n\tfunction claimReward(uint8 rewardType, address payable holder) external virtual;\n}\n"
    },
    "src/strategies/hlp/adapters/CompoundFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ICompound, ICTokenErc20 } from \"../../mixins/ICompound.sol\";\nimport { IUniswapV2Pair } from \"../../../interfaces/uniswap/IUniswapV2Pair.sol\";\nimport { IFarmable, HarvestSwapParms, IUniswapV2Router01 } from \"../../mixins/IFarmable.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract CompoundFarm is ICompound, IFarmable {\n\tusing SafeERC20 for IERC20;\n\n\tIUniswapV2Router01 private _router;\n\tIERC20 _farmToken;\n\n\tfunction __CompoundFarm_init_(address router_, address token_) internal initializer {\n\t\t_farmToken = IERC20(token_);\n\t\t_router = IUniswapV2Router01(router_);\n\t\t_farmToken.safeApprove(address(_router), type(uint256).max);\n\t}\n\n\tfunction lendFarmRouter() public view override returns (IUniswapV2Router01) {\n\t\treturn _router;\n\t}\n\n\tfunction _harvestLending(HarvestSwapParms[] calldata swapParams)\n\t\tinternal\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256[] memory harvested)\n\t{\n\t\t// comp token rewards\n\t\tICTokenErc20[] memory cTokens = new ICTokenErc20[](2);\n\t\tcTokens[0] = cTokenLend();\n\t\tcTokens[1] = cTokenBorrow();\n\t\tcomptroller().claimComp(address(this), cTokens);\n\n\t\tharvested = new uint256[](1);\n\t\tharvested[0] = _farmToken.balanceOf(address(this));\n\t\tif (harvested[0] == 0) return harvested;\n\n\t\tif (address(_router) != address(0))\n\t\t\t_swap(_router, swapParams[0], address(_farmToken), harvested[0]);\n\t\temit HarvestedToken(address(_farmToken), harvested[0]);\n\t}\n}\n"
    },
    "src/strategies/hlp/adapters/MiniChefFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IMiniChefV2 } from \"../../../interfaces/uniswap/IStakingRewards.sol\";\nimport { IUniswapV2Pair } from \"../../../interfaces/uniswap/IUniswapV2Pair.sol\";\n\nimport { IUniFarm, IUniswapV2Router01, HarvestSwapParms } from \"../../mixins/IUniFarm.sol\";\nimport { UniUtils } from \"../../../libraries/UniUtils.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract MiniChefFarm is IUniFarm {\n\tusing UniUtils for IUniswapV2Pair;\n\tusing SafeERC20 for IERC20;\n\n\tIMiniChefV2 private _farm;\n\tIUniswapV2Router01 private _router;\n\tIERC20 private _farmToken;\n\tIUniswapV2Pair private _pair;\n\tuint256 private _farmId;\n\n\tfunction __MiniChefFarm_init_(\n\t\taddress pair_,\n\t\taddress farm_,\n\t\taddress router_,\n\t\taddress farmToken_,\n\t\tuint256 farmPid_\n\t) internal initializer {\n\t\t_farm = IMiniChefV2(farm_);\n\t\t_router = IUniswapV2Router01(router_);\n\t\t_farmToken = IERC20(farmToken_);\n\t\t_pair = IUniswapV2Pair(pair_);\n\t\t_farmId = farmPid_;\n\t}\n\n\tfunction _addFarmApprovals() internal override {\n\t\t// farm approvals\n\t\tIERC20(address(_pair)).safeApprove(address(_farm), type(uint256).max);\n\t\t_farmToken.safeApprove(address(_router), type(uint256).max);\n\t}\n\n\tfunction farmRouter() public view override returns (IUniswapV2Router01) {\n\t\treturn _router;\n\t}\n\n\tfunction pair() public view override returns (IUniswapV2Pair) {\n\t\treturn _pair;\n\t}\n\n\tfunction _withdrawFromFarm(uint256 amount) internal override {\n\t\t_farm.withdraw(_farmId, amount, address(this));\n\t}\n\n\tfunction _depositIntoFarm(uint256 amount) internal override {\n\t\t_farm.deposit(_farmId, amount, address(this));\n\t}\n\n\tfunction _harvestFarm(HarvestSwapParms[] calldata swapParams)\n\t\tinternal\n\t\toverride\n\t\treturns (uint256[] memory harvested)\n\t{\n\t\t_farm.harvest(_farmId, address(this));\n\t\tharvested = new uint256[](1);\n\t\tharvested[0] = _farmToken.balanceOf(address(this));\n\t\tif (harvested[0] == 0) return harvested;\n\n\t\t_swap(_router, swapParams[0], address(_farmToken), harvested[0]);\n\t\temit HarvestedToken(address(_farmToken), harvested[0]);\n\t}\n\n\tfunction _getFarmLp() internal view override returns (uint256) {\n\t\t(uint256 lp, ) = _farm.userInfo(_farmId, address(this));\n\t\treturn lp;\n\t}\n\n\tfunction _getLiquidity(uint256 lpTokenBalance) internal view override returns (uint256) {\n\t\tuint256 farmLp = _getFarmLp();\n\t\treturn farmLp + lpTokenBalance;\n\t}\n\n\tfunction _getLiquidity() internal view override returns (uint256) {\n\t\tuint256 farmLp = _getFarmLp();\n\t\tuint256 poolLp = _pair.balanceOf(address(this));\n\t\treturn farmLp + poolLp;\n\t}\n}\n"
    },
    "src/common/FeesU.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { SafeERC20Upgradeable as SafeERC20, IERC20Upgradeable as IERC20 } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport { AuthU } from \"./AuthU.sol\";\nimport { FeeConfig } from \"./Fees.sol\";\n\n// import \"hardhat/console.sol\";\n\nabstract contract FeesU is AuthU {\n\tuint256 public constant MAX_MANAGEMENT_FEE = .05e18; // 5%\n\tuint256 public constant MAX_PERFORMANCE_FEE = .25e18; // 25%\n\n\t/// @notice The percentage of profit recognized each harvest to reserve as fees.\n\t/// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\n\tuint256 public performanceFee;\n\n\t/// @notice Annual management fee.\n\t/// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\n\tuint256 public managementFee;\n\n\t/// @notice address where all fees are sent to\n\taddress public treasury;\n\n\tfunction __INIT_FEES_(FeeConfig memory feeConfig) public onlyInitializing {\n\t\ttreasury = feeConfig.treasury;\n\t\tperformanceFee = feeConfig.performanceFee;\n\t\tmanagementFee = feeConfig.managementFee;\n\t\temit SetTreasury(feeConfig.treasury);\n\t\temit SetPerformanceFee(feeConfig.performanceFee);\n\t\temit SetManagementFee(feeConfig.managementFee);\n\t}\n\n\t/// @notice Sets a new performanceFee.\n\t/// @param _performanceFee The new performance fee.\n\tfunction setPerformanceFee(uint256 _performanceFee) public onlyOwner {\n\t\tif (_performanceFee > MAX_PERFORMANCE_FEE) revert OverMaxFee();\n\n\t\tperformanceFee = _performanceFee;\n\t\temit SetPerformanceFee(performanceFee);\n\t}\n\n\t/// @notice Sets a new performanceFee.\n\t/// @param _managementFee The new performance fee.\n\tfunction setManagementFee(uint256 _managementFee) public onlyOwner {\n\t\tif (_managementFee > MAX_MANAGEMENT_FEE) revert OverMaxFee();\n\n\t\tmanagementFee = _managementFee;\n\t\temit SetManagementFee(_managementFee);\n\t}\n\n\t/// @notice Updates treasury.\n\t/// @param _treasury New treasury address.\n\tfunction setTreasury(address _treasury) public onlyOwner {\n\t\ttreasury = _treasury;\n\t\temit SetTreasury(_treasury);\n\t}\n\n\t/// @notice Emitted when performance fee is updated.\n\t/// @param performanceFee The new perforamance fee.\n\tevent SetPerformanceFee(uint256 performanceFee);\n\n\t/// @notice Emitted when management fee is updated.\n\t/// @param managementFee The new management fee.\n\tevent SetManagementFee(uint256 managementFee);\n\n\tevent SetTreasury(address indexed treasury);\n\n\terror OverMaxFee();\n\n\tuint256[50] private __gap;\n}\n"
    },
    "src/interfaces/imx/IVaultToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.16;\n\nimport { IUniswapV2Router01 } from \"../uniswap/IUniswapV2Router01.sol\";\n\ninterface IVaultToken {\n\t/*** Tarot ERC20 ***/\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\tfunction name() external pure returns (string memory);\n\n\tfunction symbol() external pure returns (string memory);\n\n\tfunction decimals() external pure returns (uint8);\n\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction balanceOf(address owner) external view returns (uint256);\n\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\tfunction approve(address spender, uint256 value) external returns (bool);\n\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) external returns (bool);\n\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\n\tfunction nonces(address owner) external view returns (uint256);\n\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\t/*** Pool Token ***/\n\n\tevent Mint(\n\t\taddress indexed sender,\n\t\taddress indexed minter,\n\t\tuint256 mintAmount,\n\t\tuint256 mintTokens\n\t);\n\tevent Redeem(\n\t\taddress indexed sender,\n\t\taddress indexed redeemer,\n\t\tuint256 redeemAmount,\n\t\tuint256 redeemTokens\n\t);\n\tevent Sync(uint256 totalBalance);\n\n\tfunction underlying() external view returns (address);\n\n\tfunction factory() external view returns (address);\n\n\tfunction totalBalance() external view returns (uint256);\n\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n\tfunction exchangeRate() external view returns (uint256);\n\n\tfunction mint(address minter) external returns (uint256 mintTokens);\n\n\tfunction redeem(address redeemer) external returns (uint256 redeemAmount);\n\n\tfunction skim(address to) external;\n\n\tfunction sync() external;\n\n\tfunction _setFactory() external;\n\n\t/*** VaultToken ***/\n\n\tevent Reinvest(address indexed caller, uint256 reward, uint256 bounty);\n\n\tfunction isVaultToken() external pure returns (bool);\n\n\tfunction router() external view returns (IUniswapV2Router01);\n\n\t// function masterChef() external view returns (IMasterChef);\n\n\tfunction rewardsToken() external view returns (address);\n\n\tfunction WETH() external view returns (address);\n\n\tfunction token0() external view returns (address);\n\n\tfunction token1() external view returns (address);\n\n\tfunction swapFeeFactor() external view returns (uint256);\n\n\tfunction pid() external view returns (uint256);\n\n\tfunction REINVEST_BOUNTY() external pure returns (uint256);\n\n\tfunction getReserves()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint112 reserve0,\n\t\t\tuint112 reserve1,\n\t\t\tuint32 blockTimestampLast\n\t\t);\n\n\tfunction price0CumulativeLast() external view returns (uint256);\n\n\tfunction price1CumulativeLast() external view returns (uint256);\n\n\tfunction reinvest() external;\n}\n"
    },
    "src/SectorTimelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/TimelockController.sol)\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract SectorTimelock is AccessControl {\n\tbytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n\tbytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n\tbytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n\tuint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n\tmapping(bytes32 => uint256) private _timestamps;\n\tuint256 private _minDelay;\n\n\t/**\n\t * @dev Emitted when a call is scheduled as part of operation `id`.\n\t */\n\tevent CallScheduled(\n\t\tbytes32 indexed id,\n\t\tuint256 indexed index,\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes data,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt,\n\t\tuint256 delay\n\t);\n\n\t/**\n\t * @dev Emitted when a call is performed as part of operation `id`.\n\t */\n\tevent CallExecuted(\n\t\tbytes32 indexed id,\n\t\tuint256 indexed index,\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes data\n\t);\n\n\t/**\n\t * @dev Emitted when operation `id` is cancelled.\n\t */\n\tevent Cancelled(bytes32 indexed id);\n\n\t/**\n\t * @dev Emitted when the minimum delay for future operations is modified.\n\t */\n\tevent MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n\t/**\n\t * @dev Initializes the contract with a given `minDelay`.\n\t */\n\tconstructor(\n\t\tuint256 minDelay,\n\t\taddress[] memory proposers,\n\t\taddress[] memory executors\n\t) {\n\t\t_setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n\t\t_setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n\t\t_setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n\t\t// deployer + self administration\n\t\t_setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n\t\t_setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n\t\t// register proposers\n\t\tfor (uint256 i = 0; i < proposers.length; ++i) {\n\t\t\t_setupRole(PROPOSER_ROLE, proposers[i]);\n\t\t}\n\n\t\t// register executors\n\t\tfor (uint256 i = 0; i < executors.length; ++i) {\n\t\t\t_setupRole(EXECUTOR_ROLE, executors[i]);\n\t\t}\n\n\t\t_minDelay = minDelay;\n\t\temit MinDelayChange(0, minDelay);\n\t}\n\n\t/**\n\t * @dev Modifier to make a function callable only by a certain role. In\n\t * addition to checking the sender's role, `address(0)` 's role is also\n\t * considered. Granting a role to `address(0)` is equivalent to enabling\n\t * this role for everyone.\n\t */\n\tmodifier onlyRoleOrOpenRole(bytes32 role) {\n\t\tif (!hasRole(role, address(0))) {\n\t\t\t_checkRole(role, _msgSender());\n\t\t}\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Contract might receive/hold ETH as part of the maintenance process.\n\t */\n\treceive() external payable {}\n\n\t/**\n\t * @dev Returns whether an id correspond to a registered operation. This\n\t * includes both Pending, Ready and Done operations.\n\t */\n\tfunction isOperation(bytes32 id) public view virtual returns (bool pending) {\n\t\treturn getTimestamp(id) > 0;\n\t}\n\n\t/**\n\t * @dev Returns whether an operation is pending or not.\n\t */\n\tfunction isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n\t\treturn getTimestamp(id) > _DONE_TIMESTAMP;\n\t}\n\n\t/**\n\t * @dev Returns whether an operation is ready or not.\n\t */\n\tfunction isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n\t\tuint256 timestamp = getTimestamp(id);\n\t\treturn timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n\t}\n\n\t/**\n\t * @dev Returns whether an operation is done or not.\n\t */\n\tfunction isOperationDone(bytes32 id) public view virtual returns (bool done) {\n\t\treturn getTimestamp(id) == _DONE_TIMESTAMP;\n\t}\n\n\t/**\n\t * @dev Returns the timestamp at with an operation becomes ready (0 for\n\t * unset operations, 1 for done operations).\n\t */\n\tfunction getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n\t\treturn _timestamps[id];\n\t}\n\n\t/**\n\t * @dev Returns the minimum delay for an operation to become valid.\n\t *\n\t * This value can be changed by executing an operation that calls `updateDelay`.\n\t */\n\tfunction getMinDelay() public view virtual returns (uint256 duration) {\n\t\treturn _minDelay;\n\t}\n\n\t/**\n\t * @dev Returns the identifier of an operation containing a single\n\t * transaction.\n\t */\n\tfunction hashOperation(\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt\n\t) public pure virtual returns (bytes32 hash) {\n\t\treturn keccak256(abi.encode(target, value, data, predecessor, salt));\n\t}\n\n\t/**\n\t * @dev Returns the identifier of an operation containing a batch of\n\t * transactions.\n\t */\n\tfunction hashOperationBatch(\n\t\taddress[] calldata targets,\n\t\tuint256[] calldata values,\n\t\tbytes[] calldata datas,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt\n\t) public pure virtual returns (bytes32 hash) {\n\t\treturn keccak256(abi.encode(targets, values, datas, predecessor, salt));\n\t}\n\n\t/**\n\t * @dev Schedule an operation containing a single transaction.\n\t *\n\t * Emits a {CallScheduled} event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have the 'proposer' role.\n\t */\n\tfunction schedule(\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt,\n\t\tuint256 delay\n\t) public virtual onlyRole(PROPOSER_ROLE) {\n\t\tbytes32 id = hashOperation(target, value, data, predecessor, salt);\n\t\t_schedule(id, delay);\n\t\temit CallScheduled(id, 0, target, value, data, predecessor, salt, delay);\n\t}\n\n\t/**\n\t * @dev Schedule an operation containing a batch of transactions.\n\t *\n\t * Emits one {CallScheduled} event per transaction in the batch.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have the 'proposer' role.\n\t */\n\tfunction scheduleBatch(\n\t\taddress[] calldata targets,\n\t\tuint256[] calldata values,\n\t\tbytes[] calldata datas,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt,\n\t\tuint256 delay\n\t) public virtual onlyRole(PROPOSER_ROLE) {\n\t\trequire(targets.length == values.length, \"TimelockController: length mismatch\");\n\t\trequire(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n\t\tbytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n\t\t_schedule(id, delay);\n\t\tfor (uint256 i = 0; i < targets.length; ++i) {\n\t\t\temit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, salt, delay);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Schedule an operation that is to becomes valid after a given delay.\n\t */\n\tfunction _schedule(bytes32 id, uint256 delay) private {\n\t\trequire(!isOperation(id), \"TimelockController: operation already scheduled\");\n\t\trequire(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n\t\t_timestamps[id] = block.timestamp + delay;\n\t}\n\n\t/**\n\t * @dev Cancel an operation.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have the 'proposer' role.\n\t */\n\tfunction cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n\t\trequire(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n\t\tdelete _timestamps[id];\n\n\t\temit Cancelled(id);\n\t}\n\n\t/**\n\t * @dev Execute an (ready) operation containing a single transaction.\n\t *\n\t * Emits a {CallExecuted} event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have the 'executor' role.\n\t */\n\t// This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n\t// thus any modifications to the operation during reentrancy should be caught.\n\t// slither-disable-next-line reentrancy-eth\n\tfunction execute(\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt\n\t) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n\t\tbytes32 id = hashOperation(target, value, data, predecessor, salt);\n\t\t_beforeCall(id, predecessor);\n\t\t_call(id, 0, target, value, data);\n\t\t_afterCall(id);\n\t}\n\n\t/**\n\t * @dev Execute an (ready) operation containing a batch of transactions.\n\t *\n\t * Emits one {CallExecuted} event per transaction in the batch.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have the 'executor' role.\n\t */\n\tfunction executeBatch(\n\t\taddress[] calldata targets,\n\t\tuint256[] calldata values,\n\t\tbytes[] calldata datas,\n\t\tbytes32 predecessor,\n\t\tbytes32 salt\n\t) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n\t\trequire(targets.length == values.length, \"TimelockController: length mismatch\");\n\t\trequire(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n\t\tbytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n\t\t_beforeCall(id, predecessor);\n\t\tfor (uint256 i = 0; i < targets.length; ++i) {\n\t\t\t_call(id, i, targets[i], values[i], datas[i]);\n\t\t}\n\t\t_afterCall(id);\n\t}\n\n\t/**\n\t * @dev Checks before execution of an operation's calls.\n\t */\n\tfunction _beforeCall(bytes32 id, bytes32 predecessor) private view {\n\t\trequire(isOperationReady(id), \"TimelockController: operation is not ready\");\n\t\trequire(\n\t\t\tpredecessor == bytes32(0) || isOperationDone(predecessor),\n\t\t\t\"TimelockController: missing dependency\"\n\t\t);\n\t}\n\n\t/**\n\t * @dev Checks after execution of an operation's calls.\n\t */\n\tfunction _afterCall(bytes32 id) private {\n\t\trequire(isOperationReady(id), \"TimelockController: operation is not ready\");\n\t\t_timestamps[id] = _DONE_TIMESTAMP;\n\t}\n\n\t/**\n\t * @dev Execute an operation's call.\n\t *\n\t * Emits a {CallExecuted} event.\n\t */\n\tfunction _call(\n\t\tbytes32 id,\n\t\tuint256 index,\n\t\taddress target,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) private {\n\t\t(bool success, ) = target.call{ value: value }(data);\n\t\trequire(success, \"TimelockController: underlying transaction reverted\");\n\n\t\temit CallExecuted(id, index, target, value, data);\n\t}\n\n\t/**\n\t * @dev Changes the minimum timelock duration for future operations.\n\t *\n\t * Emits a {MinDelayChange} event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n\t * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n\t */\n\tfunction updateDelay(uint256 newDelay) external virtual {\n\t\trequire(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n\t\trequire(newDelay < 30 days, \"TimelockController: delay too large\");\n\t\temit MinDelayChange(_minDelay, newDelay);\n\t\t_minDelay = newDelay;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "src/SectorRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/TimelockController.sol)\n\npragma solidity 0.8.16;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract SectorRegistry is Ownable {\n\tevent AddVault(address vault, string vaultType);\n\n\tconstructor() Ownable() {}\n\n\tfunction addVault(address vault, string memory vaultType) public onlyOwner {\n\t\temit AddVault(vault, vaultType);\n\t}\n}\n"
    },
    "src/postOffice/MultichainPostman.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\nimport { CallProxy } from \"../interfaces/adapters/IMultichainAdapter.sol\";\nimport { IPostOffice } from \"../interfaces/postOffice/IPostOffice.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IPostman } from \"../interfaces/postOffice/IPostman.sol\";\nimport { XChainIntegrator } from \"../common/XChainIntegrator.sol\";\nimport \"../interfaces/MsgStructs.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract MultichainPostman is Ownable, IPostman {\n\taddress public anyCall;\n\taddress public anycallExecutor;\n\n\n\tconstructor(address _anyCall) {\n\t\tanyCall = _anyCall;\n\t\tanycallExecutor = CallProxy(_anyCall).executor();\n\t}\n\n\tfunction deliverMessage(\n\t\tMessage calldata _msg,\n\t\taddress _dstVautAddress,\n\t\taddress _dstPostman,\n\t\tmessageType _messageType,\n\t\tuint16 _dstChainId\n\t) external onlyOwner {\n\t\tbytes memory payload = abi.encode(_msg, _dstVautAddress, _messageType);\n\t\tCallProxy(anyCall).anyCall(_dstPostman, payload, address(0), _dstChainId, 2);\n\t}\n\n\tfunction anyExecute(bytes memory _data) external returns (bool success, bytes memory result) {\n\t\t// decode payload sent from source chain\n\t\t(Message memory _msg, address _dstVaultAddress, uint16 _messageType) = abi.decode(\n\t\t\t_data,\n\t\t\t(Message, address, uint16)\n\t\t);\n\n\t\temit MessageReceived(_msg.sender, _msg.value, _dstVaultAddress, _messageType, _msg.chainId);\n\n\t\t// Send message to dst vault\n\t\tXChainIntegrator(_dstVaultAddress).receiveMessage(_msg, messageType(_messageType));\n\n\t\tsuccess = true;\n\t\tresult = \"\";\n\t}\n\n\t/* EVENTS */\n\tevent MessageReceived(\n\t\taddress srcVaultAddress,\n\t\tuint256 amount,\n\t\taddress dstVaultAddress,\n\t\tuint16 messageType,\n\t\tuint256 srcChainId\n\t);\n}\n"
    },
    "src/interfaces/adapters/IMultichainAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.10;\n\ninterface CallProxy {\n\tfunction anyCall(\n\t\taddress _to,\n\t\tbytes calldata _data,\n\t\taddress _fallback,\n\t\tuint256 _toChainID,\n\t\tuint256 _flags\n\t) external;\n\n\tfunction context()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\taddress from,\n\t\t\tuint256 fromChainID,\n\t\t\tuint256 nonce\n\t\t);\n\n\tfunction executor() external view returns (address executor);\n}\n"
    },
    "src/postOffice/LayerZeroPostman.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.16;\n\nimport { ILayerZeroReceiver } from \"../interfaces/adapters/ILayerZeroReceiver.sol\";\nimport { ILayerZeroEndpoint } from \"../interfaces/adapters/ILayerZeroEndpoint.sol\";\nimport { ILayerZeroUserApplicationConfig } from \"../interfaces/adapters/ILayerZeroUserApplicationConfig.sol\";\n// import { IPostOffice } from \"../interfaces/postOffice/IPostOffice.sol\";\nimport { IPostman } from \"../interfaces/postOffice/IPostman.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { XChainIntegrator } from \"../common/XChainIntegrator.sol\";\nimport \"../interfaces/MsgStructs.sol\";\n\nstruct chainPair {\n\tuint16 from;\n\tuint16 to;\n}\n\ncontract LayerZeroPostman is\n\tILayerZeroReceiver,\n\tILayerZeroUserApplicationConfig,\n\tIPostman,\n\tOwnable\n{\n\tILayerZeroEndpoint public endpoint;\n\t// IPostOffice public immutable postOffice;\n\n\t// map original chainIds to layerZero's chainIds\n\tmapping(uint16 => uint16) chains;\n\n\tconstructor(address _layerZeroEndpoint, chainPair[] memory chainPairArr) {\n\t\tendpoint = ILayerZeroEndpoint(_layerZeroEndpoint);\n\n\t\tuint256 length = chainPairArr.length;\n\t\tfor (uint256 i = 0; i < length; ) {\n\t\t\tchainPair memory pair = chainPairArr[i];\n\t\t\tchains[pair.from] = pair.to;\n\n\t\t\tunchecked {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction deliverMessage(\n\t\tMessage calldata _msg,\n\t\taddress _dstVautAddress,\n\t\taddress _dstPostman,\n\t\tmessageType _messageType,\n\t\tuint16 _dstChainId\n\t) external {\n\t\t// if (msg.sender != address(postOffice)) revert OnlyPostOffice();\n\t\tif (address(this).balance == 0) revert NoBalance();\n\n\t\tbytes memory payload = abi.encode(_msg, _dstVautAddress, _messageType);\n\n\t\t// encode adapterParams to specify more gas for the destination\n\t\tuint16 version = 1;\n\t\tuint256 gasForDestinationLzReceive = 350000;\n\t\tbytes memory adapterParams = abi.encodePacked(version, gasForDestinationLzReceive);\n\n\t\t(uint256 messageFee, ) = endpoint.estimateFees(\n\t\t\tuint16(chains[_dstChainId]),\n\t\t\taddress(this),\n\t\t\tpayload,\n\t\t\tfalse,\n\t\t\tadapterParams\n\t\t);\n\t\tif (address(this).balance < messageFee) revert InsufficientBalanceToSendMessage();\n\n\t\t// send LayerZero message\n\t\tendpoint.send{ value: messageFee }( // {value: messageFee} will be paid out of this contract!\n\t\t\tuint16(chains[_dstChainId]), // destination chainId\n\t\t\tabi.encodePacked(_dstPostman, address(this)), // destination address of postman on dst chain\n\t\t\tpayload, // abi.encode()'ed bytes\n\t\t\tpayable(this), // (msg.sender will be this contract) refund address (LayerZero will refund any extra gas back to caller of send()\n\t\t\taddress(0x0), // 'zroPaymentAddress' unused for this mock/example\n\t\t\tadapterParams // 'adapterParams' unused for this mock/example\n\t\t);\n\t}\n\n\tfunction lzReceive(\n\t\tuint16 _srcChainId,\n\t\tbytes memory,\n\t\tuint64, /*_nonce*/\n\t\tbytes memory _payload\n\t) external override {\n\t\t// lzReceive can only be called by the LayerZero endpoint\n\t\tif (msg.sender != address(endpoint)) revert Unauthorized();\n\n\t\t// decode payload sent from source chain\n\t\t(Message memory _msg, address _dstVaultAddress, uint16 _messageType) = abi.decode(\n\t\t\t_payload,\n\t\t\t(Message, address, uint16)\n\t\t);\n\n\t\temit MessageReceived(_msg.sender, _msg.value, _dstVaultAddress, _messageType, _srcChainId);\n\n\t\t// Send message to dst vault\n\t\tXChainIntegrator(_dstVaultAddress).receiveMessage(_msg, messageType(_messageType));\n\t}\n\n\t// With this access control structure we need a way to vault set chain.\n\tfunction setChain(uint16 _chainId, uint16 _lzChainId) external onlyOwner {\n\t\tchains[_chainId] = _lzChainId;\n\t}\n\n\tfunction setConfig(\n\t\tuint16,\n\t\tuint16 _dstChainId,\n\t\tuint256 _configType,\n\t\tbytes memory _config\n\t) external override onlyOwner {\n\t\tendpoint.setConfig(\n\t\t\tchains[_dstChainId],\n\t\t\tendpoint.getSendVersion(address(this)),\n\t\t\t_configType,\n\t\t\t_config\n\t\t);\n\t}\n\n\tfunction getConfig(\n\t\tuint16,\n\t\tuint16 _chainId,\n\t\taddress,\n\t\tuint256 _configType\n\t) external view returns (bytes memory) {\n\t\treturn\n\t\t\tendpoint.getConfig(\n\t\t\t\tendpoint.getSendVersion(address(this)),\n\t\t\t\t_chainId,\n\t\t\t\taddress(this),\n\t\t\t\t_configType\n\t\t\t);\n\t}\n\n\tfunction setSendVersion(uint16 version) external override onlyOwner {\n\t\tendpoint.setSendVersion(version);\n\t}\n\n\tfunction setReceiveVersion(uint16 version) external override onlyOwner {\n\t\tendpoint.setReceiveVersion(version);\n\t}\n\n\tfunction getSendVersion() external view returns (uint16) {\n\t\treturn endpoint.getSendVersion(address(this));\n\t}\n\n\tfunction getReceiveVersion() external view returns (uint16) {\n\t\treturn endpoint.getReceiveVersion(address(this));\n\t}\n\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n\t\t// do nth\n\t}\n\n\t// allow this contract to receive ether\n\tfallback() external payable {}\n\n\treceive() external payable {}\n\n\t/* EVENTS */\n\tevent MessageReceived(\n\t\taddress srcVaultAddress,\n\t\tuint256 amount,\n\t\taddress dstVaultAddress,\n\t\tuint16 messageType,\n\t\tuint256 srcChainId\n\t);\n\n\t/* ERRORS */\n\terror Unauthorized();\n\terror NoBalance();\n\terror InsufficientBalanceToSendMessage();\n\terror OnlyPostOffice();\n}\n"
    },
    "src/interfaces/adapters/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n\t// @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n\t// @param _srcChainId - the source endpoint identifier\n\t// @param _srcAddress - the source sending contract address from the source chain\n\t// @param _nonce - the ordered message nonce\n\t// @param _payload - the signed payload is the UA bytes has encoded to be sent\n\tfunction lzReceive(\n\t\tuint16 _srcChainId,\n\t\tbytes calldata _srcAddress,\n\t\tuint64 _nonce,\n\t\tbytes calldata _payload\n\t) external;\n}\n"
    },
    "src/interfaces/adapters/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport { ILayerZeroUserApplicationConfig } from \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n\t// @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n\t// @param _dstChainId - the destination chain identifier\n\t// @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n\t// @param _payload - a custom bytes payload to send to the destination contract\n\t// @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n\t// @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n\t// @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n\tfunction send(\n\t\tuint16 _dstChainId,\n\t\tbytes calldata _destination,\n\t\tbytes calldata _payload,\n\t\taddress payable _refundAddress,\n\t\taddress _zroPaymentAddress,\n\t\tbytes calldata _adapterParams\n\t) external payable;\n\n\t// @notice used by the messaging library to publish verified payload\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source contract (as bytes) at the source chain\n\t// @param _dstAddress - the address on destination chain\n\t// @param _nonce - the unbound message ordering nonce\n\t// @param _gasLimit - the gas limit for external contract execution\n\t// @param _payload - verified payload to send to the destination contract\n\tfunction receivePayload(\n\t\tuint16 _srcChainId,\n\t\tbytes calldata _srcAddress,\n\t\taddress _dstAddress,\n\t\tuint64 _nonce,\n\t\tuint256 _gasLimit,\n\t\tbytes calldata _payload\n\t) external;\n\n\t// @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\tfunction getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress)\n\t\texternal\n\t\tview\n\t\treturns (uint64);\n\n\t// @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n\t// @param _srcAddress - the source chain contract address\n\tfunction getOutboundNonce(uint16 _dstChainId, address _srcAddress)\n\t\texternal\n\t\tview\n\t\treturns (uint64);\n\n\t// @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n\t// @param _dstChainId - the destination chain identifier\n\t// @param _userApplication - the user app address on this EVM chain\n\t// @param _payload - the custom message to send over LayerZero\n\t// @param _payInZRO - if false, user app pays the protocol fee in native token\n\t// @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n\tfunction estimateFees(\n\t\tuint16 _dstChainId,\n\t\taddress _userApplication,\n\t\tbytes calldata _payload,\n\t\tbool _payInZRO,\n\t\tbytes calldata _adapterParam\n\t) external view returns (uint256 nativeFee, uint256 zroFee);\n\n\t// @notice get this Endpoint's immutable source identifier\n\tfunction getChainId() external view returns (uint16);\n\n\t// @notice the interface to retry failed message on this Endpoint destination\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\t// @param _payload - the payload to be retried\n\tfunction retryPayload(\n\t\tuint16 _srcChainId,\n\t\tbytes calldata _srcAddress,\n\t\tbytes calldata _payload\n\t) external;\n\n\t// @notice query if any STORED payload (message blocking) at the endpoint.\n\t// @param _srcChainId - the source chain identifier\n\t// @param _srcAddress - the source chain contract address\n\tfunction hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress)\n\t\texternal\n\t\tview\n\t\treturns (bool);\n\n\t// @notice query if the _libraryAddress is valid for sending msgs.\n\t// @param _userApplication - the user app address on this EVM chain\n\tfunction getSendLibraryAddress(address _userApplication) external view returns (address);\n\n\t// @notice query if the _libraryAddress is valid for receiving msgs.\n\t// @param _userApplication - the user app address on this EVM chain\n\tfunction getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n\t// @notice query if the non-reentrancy guard for send() is on\n\t// @return true if the guard is on. false otherwise\n\tfunction isSendingPayload() external view returns (bool);\n\n\t// @notice query if the non-reentrancy guard for receive() is on\n\t// @return true if the guard is on. false otherwise\n\tfunction isReceivingPayload() external view returns (bool);\n\n\t// @notice get the configuration of the LayerZero messaging library of the specified version\n\t// @param _version - messaging library version\n\t// @param _chainId - the chainId for the pending config change\n\t// @param _userApplication - the contract address of the user application\n\t// @param _configType - type of configuration. every messaging library has its own convention.\n\tfunction getConfig(\n\t\tuint16 _version,\n\t\tuint16 _chainId,\n\t\taddress _userApplication,\n\t\tuint256 _configType\n\t) external view returns (bytes memory);\n\n\t// @notice get the send() LayerZero messaging library version\n\t// @param _userApplication - the contract address of the user application\n\tfunction getSendVersion(address _userApplication) external view returns (uint16);\n\n\t// @notice get the lzReceive() LayerZero messaging library version\n\t// @param _userApplication - the contract address of the user application\n\tfunction getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "src/interfaces/adapters/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n\t// @notice set the configuration of the LayerZero messaging library of the specified version\n\t// @param _version - messaging library version\n\t// @param _chainId - the chainId for the pending config change\n\t// @param _configType - type of configuration. every messaging library has its own convention.\n\t// @param _config - configuration in the bytes. can encode arbitrary content.\n\tfunction setConfig(\n\t\tuint16 _version,\n\t\tuint16 _chainId,\n\t\tuint256 _configType,\n\t\tbytes calldata _config\n\t) external;\n\n\t// @notice set the send() LayerZero messaging library version to _version\n\t// @param _version - new messaging library version\n\tfunction setSendVersion(uint16 _version) external;\n\n\t// @notice set the lzReceive() LayerZero messaging library version to _version\n\t// @param _version - new messaging library version\n\tfunction setReceiveVersion(uint16 _version) external;\n\n\t// @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n\t// @param _srcChainId - the chainId of the source chain\n\t// @param _srcAddress - the contract address of the source contract at the source chain\n\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "src/USDCMock/USDCMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract USDCMock is ERC20 {\n\tconstructor(uint256 initialSupply) ERC20(\"USDC\", \"USDC\") {\n\t\t_mint(msg.sender, initialSupply);\n\t}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}